{
    "ACCEL_AXIS_X": {
        "description": "<p>Accelerometer's X axis. The positive direction along the X axis goes toward the right of the watch. </p>", 
        "kind": "enum", 
        "name": "ACCEL_AXIS_X", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACCEL_AXIS_Y": {
        "description": "<p>Accelerometer's Y axis. The positive direction along the Y axis goes toward the top of the watch. </p>", 
        "kind": "enum", 
        "name": "ACCEL_AXIS_Y", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACCEL_AXIS_Z": {
        "description": "<p>Accelerometer's Z axis. The positive direction along the Z axis goes vertically out of the watchface. </p>", 
        "kind": "enum", 
        "name": "ACCEL_AXIS_Z", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACCEL_SAMPLING_100HZ": {
        "description": "<p>100 HZ sampling rate </p>", 
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_100HZ", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACCEL_SAMPLING_10HZ": {
        "description": "<p>10 HZ sampling rate </p>", 
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_10HZ", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACCEL_SAMPLING_25HZ": {
        "description": "<p>25 HZ sampling rate [Default] </p>", 
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_25HZ", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACCEL_SAMPLING_50HZ": {
        "description": "<p>50 HZ sampling rate </p>", 
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_50HZ", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ACTION_BAR_WIDTH": {
        "description": "<p>The width of the action bar in pixels. </p>", 
        "kind": "def", 
        "name": "ACTION_BAR_WIDTH", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ANIMATION_DURATION_INFINITE": {
        "description": "<p>Constant to indicate \"infinite\" duration. This can be used with <code>animation_set_duration()</code> to indicate that the animation should run indefinitely. This is useful when implementing for example a frame-by-frame simulation that does not have a clear ending (e.g. a game). </p>", 
        "kind": "def", 
        "name": "ANIMATION_DURATION_INFINITE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>Note that <code>distance_normalized</code> parameter that is passed into the .update implementation is meaningless in when an infinite duration is used. </p>"
    }, 
    "ANIMATION_NORMALIZED_MAX": {
        "description": "<p>The normalized distance at the end of the animation. </p>", 
        "kind": "def", 
        "name": "ANIMATION_NORMALIZED_MAX", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ANIMATION_NORMALIZED_MIN": {
        "description": "<p>The normalized distance at the start of the animation. </p>", 
        "kind": "def", 
        "name": "ANIMATION_NORMALIZED_MIN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ANIMATION_PLAY_COUNT_INFINITE": {
        "description": "<p>Constant to indicate infinite play count. Can be passed to <code>animation_set_play_count()</code> to repeat indefinitely. </p>", 
        "kind": "def", 
        "name": "ANIMATION_PLAY_COUNT_INFINITE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>This can be returned by <code>animation_get_play_count()</code>. </p>"
    }, 
    "APP_EXIT_ACTION_PERFORMED_SUCCESSFULLY": {
        "description": "<p>Application performed an action when it exited. </p>", 
        "kind": "enum", 
        "name": "APP_EXIT_ACTION_PERFORMED_SUCCESSFULLY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_EXIT_NOT_SPECIFIED": {
        "description": "<p>Exit reason not specified. </p>", 
        "kind": "enum", 
        "name": "APP_EXIT_NOT_SPECIFIED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_EXPIRES_IN_THE_PAST": {
        "description": "<p>The <code>expiration_time</code> provided in the slice expires in the past. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_EXPIRES_IN_THE_PAST", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_INVALID_ICON": {
        "description": "<p>The icon provided in the slice was invalid. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_INVALID_ICON", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_INVALID_SESSION": {
        "description": "<p>The AppGlanceReloadSession provided was invalid. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_INVALID_SESSION", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_INVALID_TEMPLATE_STRING": {
        "description": "<p>The <code>subtitle_template_string</code> provided in the slice was invalid. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_INVALID_TEMPLATE_STRING", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_SLICE_CAPACITY_EXCEEDED": {
        "description": "<p>The provided slice would exceed the app glance's slice capacity. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_SLICE_CAPACITY_EXCEEDED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_SUCCESS": {
        "description": "<p>The slice was successfully added to the app's glance. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_SUCCESS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_RESULT_TEMPLATE_STRING_TOO_LONG": {
        "description": "<p>The <code>subtitle_template_string</code> provided in the slice was longer than 150 bytes. </p>", 
        "kind": "enum", 
        "name": "APP_GLANCE_RESULT_TEMPLATE_STRING_TOO_LONG", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_SLICE_DEFAULT_ICON": {
        "description": "<p>Can be used for the icon of an AppGlanceSlice so that the slice displays the app's default icon. </p>", 
        "kind": "def", 
        "name": "APP_GLANCE_SLICE_DEFAULT_ICON", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_GLANCE_SLICE_NO_EXPIRATION": {
        "description": "<p>Can be used for the <code>expiration_time</code> of an AppGlanceSlice so that the slice never expires. </p>", 
        "kind": "def", 
        "name": "APP_GLANCE_SLICE_NO_EXPIRATION", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_PHONE": {
        "description": "<p>App launched by mobile or companion app. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_PHONE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_QUICK_LAUNCH": {
        "description": "<p>App launched by user using quick launch. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_QUICK_LAUNCH", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_SMARTSTRAP": {
        "description": "<p>App launched by a smartstrap. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_SMARTSTRAP", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_SYSTEM": {
        "description": "<p>App launched by the system. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_SYSTEM", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_TIMELINE_ACTION": {
        "description": "<p>App launched by user opening it from a pin. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_TIMELINE_ACTION", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_USER": {
        "description": "<p>App launched by user selection in launcher menu. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_USER", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_WAKEUP": {
        "description": "<p>App launched by wakeup event. </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_WAKEUP", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LAUNCH_WORKER": {
        "description": "<p>App launched by worker calling <code>worker_launch_app()</code> </p>", 
        "kind": "enum", 
        "name": "APP_LAUNCH_WORKER", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LOG": {
        "description": "<p>A helper macro that simplifies the use of the <code>app_log</code> function. </p>", 
        "kind": "def", 
        "name": "APP_LOG", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LOG_LEVEL_DEBUG": {
        "description": "<p>Debug level log message. </p>", 
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_DEBUG", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LOG_LEVEL_DEBUG_VERBOSE": {
        "description": "<p>Verbose Debug level log message. </p>", 
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_DEBUG_VERBOSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LOG_LEVEL_ERROR": {
        "description": "<p>Error level log message. </p>", 
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_ERROR", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LOG_LEVEL_INFO": {
        "description": "<p>Info level log message. </p>", 
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_INFO", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_LOG_LEVEL_WARNING": {
        "description": "<p>Warning level log message. </p>", 
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_WARNING", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MESSAGE_INBOX_SIZE_MINIMUM": {
        "description": "<p>As long as the firmware maintains its current major version, inboxes of this size or smaller will be allowed. </p>", 
        "kind": "def", 
        "name": "APP_MESSAGE_INBOX_SIZE_MINIMUM", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MESSAGE_OUTBOX_SIZE_MINIMUM": {
        "description": "<p>As long as the firmware maintains its current major version, outboxes of this size or smaller will be allowed. </p>", 
        "kind": "def", 
        "name": "APP_MESSAGE_OUTBOX_SIZE_MINIMUM", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_ALREADY_RELEASED": {
        "description": "<p>(512) The resource had already been released. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_ALREADY_RELEASED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_APP_NOT_RUNNING": {
        "description": "<p>(16) The local application was not running. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_APP_NOT_RUNNING", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_BUFFER_OVERFLOW": {
        "description": "<p>(128) The buffer was too small to contain the incoming message. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_BUFFER_OVERFLOW", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_BUSY": {
        "description": "<p>(64) There are pending (in or outbound) messages that need to be processed first before new ones can be received or sent. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_BUSY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_CALLBACK_ALREADY_REGISTERED": {
        "description": "<p>(1024) The callback was already registered. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_CALLBACK_ALREADY_REGISTERED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_CALLBACK_NOT_REGISTERED": {
        "description": "<p>(2048) The callback could not be deregistered, because it had not been registered before. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_CALLBACK_NOT_REGISTERED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_CLOSED": {
        "description": "<p>(8192) App message was closed. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_CLOSED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_INTERNAL_ERROR": {
        "description": "<p>(16384) An internal OS error prevented AppMessage from completing an operation. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_INTERNAL_ERROR", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_INVALID_ARGS": {
        "description": "<p>(32) The function was called with invalid arguments. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_INVALID_ARGS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_INVALID_STATE": {
        "description": "<p>(32768) The function was called while App Message was not in the appropriate state. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_INVALID_STATE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_NOT_CONNECTED": {
        "description": "<p>(8) The other end was not connected. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_NOT_CONNECTED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_OK": {
        "description": "<p>(0) All good, operation was successful. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_OK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_OUT_OF_MEMORY": {
        "description": "<p>(4096) The system did not have sufficient application memory to perform the requested operation. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_OUT_OF_MEMORY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_SEND_REJECTED": {
        "description": "<p>(4) The other end rejected the sent data, with a \"nack\" reply. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_SEND_REJECTED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_MSG_SEND_TIMEOUT": {
        "description": "<p>(2) The other end did not confirm receiving the sent data with an (n)ack in time. </p>", 
        "kind": "enum", 
        "name": "APP_MSG_SEND_TIMEOUT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_WORKER_RESULT_ALREADY_RUNNING": {
        "description": "<p>The worker is already running. </p>", 
        "kind": "enum", 
        "name": "APP_WORKER_RESULT_ALREADY_RUNNING", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_WORKER_RESULT_ASKING_CONFIRMATION": {
        "description": "<p>The user will be asked for confirmation. </p>", 
        "kind": "enum", 
        "name": "APP_WORKER_RESULT_ASKING_CONFIRMATION", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_WORKER_RESULT_DIFFERENT_APP": {
        "description": "<p>A worker for a different app is already running. </p>", 
        "kind": "enum", 
        "name": "APP_WORKER_RESULT_DIFFERENT_APP", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_WORKER_RESULT_NOT_RUNNING": {
        "description": "<p>The worker is not running. </p>", 
        "kind": "enum", 
        "name": "APP_WORKER_RESULT_NOT_RUNNING", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_WORKER_RESULT_NO_WORKER": {
        "description": "<p>No worker found for the current app. </p>", 
        "kind": "enum", 
        "name": "APP_WORKER_RESULT_NO_WORKER", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "APP_WORKER_RESULT_SUCCESS": {
        "description": "<p>Success. </p>", 
        "kind": "enum", 
        "name": "APP_WORKER_RESULT_SUCCESS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ARRAY_LENGTH": {
        "description": "<p>Calculate the length of an array, based on the size of the element type. </p>", 
        "kind": "def", 
        "name": "ARRAY_LENGTH", 
        "params": [], 
        "return_desc": "<p>The length of the array. </p>", 
        "returns": "", 
        "warning": null
    }, 
    "AccelDataHandler": {
        "description": "<p>Callback type for accelerometer data events. </p>", 
        "kind": "typedef", 
        "name": "AccelDataHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AccelRawDataHandler": {
        "description": "<p>Callback type for accelerometer raw data events. </p>", 
        "kind": "typedef", 
        "name": "AccelRawDataHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AccelTapHandler": {
        "description": "<p>Callback type for accelerometer tap events. </p>", 
        "kind": "typedef", 
        "name": "AccelTapHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "ActionBarLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "ActionBarLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct ActionBarLayer", 
        "warning": null
    }, 
    "ActionBarLayerIconPressAnimationMoveDown": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionBarLayerIconPressAnimationMoveDown", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionBarLayerIconPressAnimationMoveLeft": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionBarLayerIconPressAnimationMoveLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionBarLayerIconPressAnimationMoveRight": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionBarLayerIconPressAnimationMoveRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionBarLayerIconPressAnimationMoveUp": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionBarLayerIconPressAnimationMoveUp", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionBarLayerIconPressAnimationNone": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionBarLayerIconPressAnimationNone", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionMenu": {
        "description": "", 
        "kind": "typedef", 
        "name": "ActionMenu", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct ActionMenu", 
        "warning": null
    }, 
    "ActionMenuAlignCenter": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionMenuAlignCenter", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionMenuAlignTop": {
        "description": "", 
        "kind": "enum", 
        "name": "ActionMenuAlignTop", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionMenuDidCloseCb": {
        "description": "<p>Callback executed after the ActionMenu has closed, so memory may be freed. </p>", 
        "kind": "typedef", 
        "name": "ActionMenuDidCloseCb", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "ActionMenuEachItemCb": {
        "description": "<p>Callback invoked for each item in an action menu hierarchy. </p>", 
        "kind": "typedef", 
        "name": "ActionMenuEachItemCb", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "ActionMenuItem": {
        "description": "", 
        "kind": "typedef", 
        "name": "ActionMenuItem", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct ActionMenuItem", 
        "warning": null
    }, 
    "ActionMenuLevel": {
        "description": "", 
        "kind": "typedef", 
        "name": "ActionMenuLevel", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct ActionMenuLevel", 
        "warning": null
    }, 
    "ActionMenuLevelDisplayModeThin": {
        "description": "<p>Grid view: multiple items per row. </p>", 
        "kind": "enum", 
        "name": "ActionMenuLevelDisplayModeThin", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionMenuLevelDisplayModeWide": {
        "description": "<p>Each item gets its own row. </p>", 
        "kind": "enum", 
        "name": "ActionMenuLevelDisplayModeWide", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ActionMenuPerformActionCb": {
        "description": "<p>Callback executed when a given action is selected. </p>", 
        "kind": "typedef", 
        "name": "ActionMenuPerformActionCb", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>the action menu is closed immediately after an action is performed, unless it is frozen in the ActionMenuPerformActionCb </p>"
    }, 
    "AmbientLightLevelDark": {
        "description": "", 
        "kind": "enum", 
        "name": "AmbientLightLevelDark", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AmbientLightLevelLight": {
        "description": "", 
        "kind": "enum", 
        "name": "AmbientLightLevelLight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AmbientLightLevelUnknown": {
        "description": "", 
        "kind": "enum", 
        "name": "AmbientLightLevelUnknown", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AmbientLightLevelVeryDark": {
        "description": "", 
        "kind": "enum", 
        "name": "AmbientLightLevelVeryDark", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AmbientLightLevelVeryLight": {
        "description": "", 
        "kind": "enum", 
        "name": "AmbientLightLevelVeryLight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "Animation": {
        "description": "", 
        "kind": "typedef", 
        "name": "Animation", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct Animation", 
        "warning": null
    }, 
    "AnimationCurveCustomFunction": {
        "description": "<p>Custom (user-provided) animation curve. </p>", 
        "kind": "enum", 
        "name": "AnimationCurveCustomFunction", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurveCustomInterpolationFunction": {
        "description": "<p>User-provided interpolation function. </p>", 
        "kind": "enum", 
        "name": "AnimationCurveCustomInterpolationFunction", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurveDefault": {
        "description": "", 
        "kind": "enum", 
        "name": "AnimationCurveDefault", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurveEaseIn": {
        "description": "<p>Bicubic ease-in: accelerate from zero velocity. </p>", 
        "kind": "enum", 
        "name": "AnimationCurveEaseIn", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurveEaseInOut": {
        "description": "<p>Bicubic ease-in-out: accelerate from zero velocity, decelerate to zero velocity. </p>", 
        "kind": "enum", 
        "name": "AnimationCurveEaseInOut", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurveEaseOut": {
        "description": "<p>Bicubic ease-in: decelerate to zero velocity. </p>", 
        "kind": "enum", 
        "name": "AnimationCurveEaseOut", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurveFunction": {
        "description": "<p>The function pointer type of a custom animation curve. </p>", 
        "kind": "typedef", 
        "name": "AnimationCurveFunction", 
        "params": [], 
        "return_desc": null, 
        "returns": "AnimationProgress(*", 
        "warning": null
    }, 
    "AnimationCurveLinear": {
        "description": "<p>Linear curve: the velocity is constant. </p>", 
        "kind": "enum", 
        "name": "AnimationCurveLinear", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurve_Reserved1": {
        "description": "", 
        "kind": "enum", 
        "name": "AnimationCurve_Reserved1", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationCurve_Reserved2": {
        "description": "", 
        "kind": "enum", 
        "name": "AnimationCurve_Reserved2", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "AnimationProgress": {
        "description": "<p>The type used to represent how far an animation has progressed. This is passed to the animation's update handler. </p>", 
        "kind": "typedef", 
        "name": "AnimationProgress", 
        "params": [], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "AnimationSetupImplementation": {
        "description": "<p>Pointer to function that (optionally) prepares the animation for running. This callback is called when the animation is added to the scheduler. </p>", 
        "kind": "typedef", 
        "name": "AnimationSetupImplementation", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AnimationStartedHandler": {
        "description": "<p>The function pointer type of the handler that will be called when an animation is started, just before updating the first frame of the animation. </p>", 
        "kind": "typedef", 
        "name": "AnimationStartedHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>This is called after any optional delay as set by <code>animation_set_delay()</code> has expired. </p>"
    }, 
    "AnimationStoppedHandler": {
        "description": "<p>The function pointer type of the handler that will be called when the animation is stopped. </p>", 
        "kind": "typedef", 
        "name": "AnimationStoppedHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>This animation (i.e.: the animation parameter) may be destroyed here. It is not recommended to unschedule or destroy a different Animation within this Animation's stopped handler. </p>"
    }, 
    "AnimationTeardownImplementation": {
        "description": "<p>Pointer to function that (optionally) cleans up the animation. This callback is called when the animation is removed from the scheduler. In case the .setup implementation allocated any memory, this is a good place to release that memory again. </p>", 
        "kind": "typedef", 
        "name": "AnimationTeardownImplementation", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AnimationUpdateImplementation": {
        "description": "<p>Pointer to function that updates the animation according to the given normalized progress. This callback will be called repeatedly by the animation scheduler whenever the animation needs to be updated. </p>", 
        "kind": "typedef", 
        "name": "AnimationUpdateImplementation", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppFocusHandler": {
        "description": "<p>Callback type for focus events. </p>", 
        "kind": "typedef", 
        "name": "AppFocusHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppGlanceReloadCallback": {
        "description": "<p>User-provided callback for reloading the slices in the app's glance. </p>", 
        "kind": "typedef", 
        "name": "AppGlanceReloadCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppGlanceReloadSession": {
        "description": "", 
        "kind": "typedef", 
        "name": "AppGlanceReloadSession", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct AppGlanceReloadSession", 
        "warning": null
    }, 
    "AppMessageInboxDropped": {
        "description": "<p><code>app_message_outbox_begin()</code> from this handler to prepare a new message. This will invalidate the previous dictionary iterator; do not use it after calling <code>app_message_outbox_begin()</code>. </p>", 
        "kind": "typedef", 
        "name": "AppMessageInboxDropped", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppMessageInboxReceived": {
        "description": "<p>Called after an incoming message is received. </p>", 
        "kind": "typedef", 
        "name": "AppMessageInboxReceived", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppMessageOutboxFailed": {
        "description": "<p><code>app_message_outbox_begin()</code> from this handler to prepare a new message. This will invalidate the previous dictionary iterator; do not use it after calling <code>app_message_outbox_begin()</code>. </p>", 
        "kind": "typedef", 
        "name": "AppMessageOutboxFailed", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppMessageOutboxSent": {
        "description": "<p>Called after an outbound message has been sent and the reply has been received. </p>", 
        "kind": "typedef", 
        "name": "AppMessageOutboxSent", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppSyncErrorCallback": {
        "description": "<p>Called whenever there was an error. </p>", 
        "kind": "typedef", 
        "name": "AppSyncErrorCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppSyncTupleChangedCallback": {
        "description": "<p>Called whenever a Tuple changes. This does not necessarily mean the value in the Tuple has changed. When the internal \"current\" dictionary gets updated, existing Tuples might get shuffled around in the backing buffer, even though the values stay the same. In this callback, the client code gets the chance to remove the old reference and start using the new one. In this callback, your application MUST clean up any references to the <code>old_tuple</code> of a PREVIOUS call to this callback (and replace it with the <code>new_tuple</code> that is passed in with the current call). </p>", 
        "kind": "typedef", 
        "name": "AppSyncTupleChangedCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppTimer": {
        "description": "", 
        "kind": "typedef", 
        "name": "AppTimer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct AppTimer", 
        "warning": null
    }, 
    "AppTimerCallback": {
        "description": "<p>The type of function which can be called when a timer fires. The argument will be the <code>callback_data</code> passed to <code>app_timer_register()</code>. </p>", 
        "kind": "typedef", 
        "name": "AppTimerCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "AppWorkerMessageHandler": {
        "description": "<p>Callback type for worker messages. Messages can be sent from worker to app or vice versa. </p>", 
        "kind": "typedef", 
        "name": "AppWorkerMessageHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "BUTTON_ID_BACK": {
        "description": "<p>Back button. </p>", 
        "kind": "enum", 
        "name": "BUTTON_ID_BACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "BUTTON_ID_DOWN": {
        "description": "<p>Down button. </p>", 
        "kind": "enum", 
        "name": "BUTTON_ID_DOWN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "BUTTON_ID_SELECT": {
        "description": "<p>Select (middle) button. </p>", 
        "kind": "enum", 
        "name": "BUTTON_ID_SELECT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "BUTTON_ID_UP": {
        "description": "<p>Up button. </p>", 
        "kind": "enum", 
        "name": "BUTTON_ID_UP", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "BatteryStateHandler": {
        "description": "<p>Callback type for battery state change events. </p>", 
        "kind": "typedef", 
        "name": "BatteryStateHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "BitmapLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "BitmapLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct BitmapLayer", 
        "warning": null
    }, 
    "BluetoothConnectionHandler": {
        "description": "<p>Deprecated<p>Backwards compatibility typedef for ConnectionHandler. New code should use ConnectionHandler directly. This will be removed in a future version of the Pebble SDK. </p></p>", 
        "kind": "typedef", 
        "name": "BluetoothConnectionHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "ConnectionHandler", 
        "warning": null
    }, 
    "COLOR_FALLBACK": {
        "description": "<p>Convenience macro allowing use of a fallback color for black and white platforms. On color platforms, the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "COLOR_FALLBACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ClickConfigProvider": {
        "description": "<p>Subscribe to click events using <code>window_single_click_subscribe()</code> <code>window_single_repeating_click_subscribe()</code> <code>window_multi_click_subscribe()</code> <code>window_long_click_subscribe()</code> <code>window_raw_click_subscribe()</code> These subscriptions will get used by the click recognizers of each of the 4 buttons.", 
        "kind": "typedef", 
        "name": "ClickConfigProvider", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "ClickHandler": {
        "description": "<p>Function signature of the callback that handles a recognized click pattern. </p>", 
        "kind": "typedef", 
        "name": "ClickHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "ClickRecognizerRef": {
        "description": "<p>Reference to opaque click recognizer When a ClickHandler callback is called, the recognizer that fired the handler is passed in. </p>", 
        "kind": "typedef", 
        "name": "ClickRecognizerRef", 
        "params": [], 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null
    }, 
    "CompassHeading": {
        "description": "<p>Represents an angle relative to get to a reference direction, e.g. (magnetic) north. The angle value is scaled linearly, such that a value of <code>TRIG_MAX_ANGLE</code> corresponds to 360 degrees or 2 PI radians. Thus, if heading towards north, north is 0, west is <code>TRIG_MAX_ANGLE</code>/4, south is <code>TRIG_MAX_ANGLE</code>/2, and so on. </p>", 
        "kind": "typedef", 
        "name": "CompassHeading", 
        "params": [], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "CompassHeadingHandler": {
        "description": "<p>Callback type for compass heading events. </p>", 
        "kind": "typedef", 
        "name": "CompassHeadingHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "CompassStatusCalibrated": {
        "description": "<p>Compass data is valid and the calibration has completed. </p>", 
        "kind": "enum", 
        "name": "CompassStatusCalibrated", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "CompassStatusCalibrating": {
        "description": "<p>Compass is calibrating: the data is valid but the calibration is still being refined. </p>", 
        "kind": "enum", 
        "name": "CompassStatusCalibrating", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "CompassStatusDataInvalid": {
        "description": "<p>Compass is calibrating: data is invalid and should not be used Data will become valid once calibration is complete. </p>", 
        "kind": "enum", 
        "name": "CompassStatusDataInvalid", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "CompassStatusUnavailable": {
        "description": "<p>The Compass Service is unavailable. </p>", 
        "kind": "enum", 
        "name": "CompassStatusUnavailable", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ConnectionHandler": {
        "description": "", 
        "kind": "typedef", 
        "name": "ConnectionHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "ContentIndicator": {
        "description": "", 
        "kind": "typedef", 
        "name": "ContentIndicator", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct ContentIndicator", 
        "warning": null
    }, 
    "ContentIndicatorDirectionDown": {
        "description": "<p>The down direction. </p>", 
        "kind": "enum", 
        "name": "ContentIndicatorDirectionDown", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ContentIndicatorDirectionUp": {
        "description": "<p>The up direction. </p>", 
        "kind": "enum", 
        "name": "ContentIndicatorDirectionUp", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_BUSY": {
        "description": "<p>Someone else is writing to this logging session. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_BUSY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_BYTE_ARRAY": {
        "description": "<p>Array of bytes. Remember that this is the type of a single item in the logging session, so using this type means you'll be logging multiple byte arrays (each a fixed length described by <code>item_length</code>) for the duration of the session. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_BYTE_ARRAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_CLOSED": {
        "description": "<p>The logging session was made inactive. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_CLOSED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_FULL": {
        "description": "<p>No more space to save data. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_FULL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_INT": {
        "description": "<p>Signed integer. This may be a 1, 2, or 4 byte integer depending on the <code>item_length</code> parameter. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_INT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_INTERNAL_ERR": {
        "description": "<p>An internal error occurred. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_INTERNAL_ERR", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_INVALID_PARAMS": {
        "description": "<p>An invalid parameter was passed to one of the functions. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_INVALID_PARAMS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_NOT_FOUND": {
        "description": "<p>The logging session does not exist. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_NOT_FOUND", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_SUCCESS": {
        "description": "<p>Successful operation. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_SUCCESS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DATA_LOGGING_UINT": {
        "description": "<p>Unsigned integer. This may be a 1, 2, or 4 byte integer depending on the <code>item_length</code> parameter. </p>", 
        "kind": "enum", 
        "name": "DATA_LOGGING_UINT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DAY_UNIT": {
        "description": "<p>Flag to represent the \"days\" time unit. </p>", 
        "kind": "enum", 
        "name": "DAY_UNIT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DEG_TO_TRIGANGLE": {
        "description": "<p>Converts from an angle in degrees to the equivalent fixed point value representation. </p>", 
        "kind": "def", 
        "name": "DEG_TO_TRIGANGLE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DICT_INTERNAL_INCONSISTENCY": {
        "description": "<p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>", 
        "kind": "enum", 
        "name": "DICT_INTERNAL_INCONSISTENCY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DICT_INVALID_ARGS": {
        "description": "<p>One or more arguments were invalid or uninitialized. </p>", 
        "kind": "enum", 
        "name": "DICT_INVALID_ARGS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DICT_MALLOC_FAILED": {
        "description": "<p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>", 
        "kind": "enum", 
        "name": "DICT_MALLOC_FAILED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DICT_NOT_ENOUGH_STORAGE": {
        "description": "<p>There was not enough backing storage to complete the operation. </p>", 
        "kind": "enum", 
        "name": "DICT_NOT_ENOUGH_STORAGE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DICT_OK": {
        "description": "<p>The operation returned successfully. </p>", 
        "kind": "enum", 
        "name": "DICT_OK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DataLoggingSessionRef": {
        "description": "", 
        "kind": "typedef", 
        "name": "DataLoggingSessionRef", 
        "params": [], 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null
    }, 
    "DictationSession": {
        "description": "", 
        "kind": "typedef", 
        "name": "DictationSession", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct DictationSession", 
        "warning": null
    }, 
    "DictationSessionStatusCallback": {
        "description": "<p>Dictation status callback. Indicates success or failure of the dictation session and, if successful, passes the transcribed string to the user of the dictation session. The transcribed string will be freed after this call returns, so the string should be copied if it needs to be retained afterwards. </p>", 
        "kind": "typedef", 
        "name": "DictationSessionStatusCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "DictationSessionStatusFailureConnectivityError": {
        "description": "<p>No BT or internet connection. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureConnectivityError", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureDisabled": {
        "description": "<p>Voice transcription disabled for this user. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureDisabled", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureInternalError": {
        "description": "<p>Voice transcription failed due to internal error. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureInternalError", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureNoSpeechDetected": {
        "description": "<p>No speech was detected and UI exited. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureNoSpeechDetected", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureRecognizerError": {
        "description": "<p>Cloud recognizer failed to transcribe speech (only possible if error dialogs disabled) </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureRecognizerError", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureSystemAborted": {
        "description": "<p>Too many errors occurred during transcription and the UI exited. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureSystemAborted", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureTranscriptionRejected": {
        "description": "<p>User rejected transcription and exited UI. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureTranscriptionRejected", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusFailureTranscriptionRejectedWithError": {
        "description": "<p>User exited UI after transcription error. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusFailureTranscriptionRejectedWithError", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "DictationSessionStatusSuccess": {
        "description": "<p>Transcription successful, with a valid result. </p>", 
        "kind": "enum", 
        "name": "DictationSessionStatusSuccess", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "Dictionary": {
        "description": "", 
        "kind": "typedef", 
        "name": "Dictionary", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct Dictionary", 
        "warning": null
    }, 
    "DictionaryKeyUpdatedCallback": {
        "description": "<p>Type of the callback used in <code>dict_merge()</code> </p>", 
        "kind": "typedef", 
        "name": "DictionaryKeyUpdatedCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "DictionarySerializeCallback": {
        "description": "<p>Callback for <code>dict_serialize_tuplets()</code> utility. </p>", 
        "kind": "typedef", 
        "name": "DictionarySerializeCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "E_AGAIN": {
        "description": "<p>Operation not completed; try again. </p>", 
        "kind": "enum", 
        "name": "E_AGAIN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_BUSY": {
        "description": "<p>Another operation prevented this one. </p>", 
        "kind": "enum", 
        "name": "E_BUSY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_DOES_NOT_EXIST": {
        "description": "<p>Target of operation does not exist. </p>", 
        "kind": "enum", 
        "name": "E_DOES_NOT_EXIST", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_ERROR": {
        "description": "<p>An error occurred (no description). </p>", 
        "kind": "enum", 
        "name": "E_ERROR", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_INTERNAL": {
        "description": "<p>There was a generic internal logic error. </p>", 
        "kind": "enum", 
        "name": "E_INTERNAL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_INVALID_ARGUMENT": {
        "description": "<p>The function was not called correctly. </p>", 
        "kind": "enum", 
        "name": "E_INVALID_ARGUMENT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_INVALID_OPERATION": {
        "description": "<p>Operation not allowed (may depend on state). </p>", 
        "kind": "enum", 
        "name": "E_INVALID_OPERATION", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_OUT_OF_MEMORY": {
        "description": "<p>Insufficient allocatable memory available. </p>", 
        "kind": "enum", 
        "name": "E_OUT_OF_MEMORY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_OUT_OF_RESOURCES": {
        "description": "<p>Insufficient resources available. </p>", 
        "kind": "enum", 
        "name": "E_OUT_OF_RESOURCES", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_OUT_OF_STORAGE": {
        "description": "<p>Insufficient long-term storage available. </p>", 
        "kind": "enum", 
        "name": "E_OUT_OF_STORAGE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_RANGE": {
        "description": "<p>Argument out of range (may be dynamic). </p>", 
        "kind": "enum", 
        "name": "E_RANGE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "E_UNKNOWN": {
        "description": "<p>No idea what went wrong. </p>", 
        "kind": "enum", 
        "name": "E_UNKNOWN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "FRIDAY": {
        "description": "<p>Friday. </p>", 
        "kind": "enum", 
        "name": "FRIDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "FontInfo": {
        "description": "", 
        "kind": "typedef", 
        "name": "FontInfo", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct FontInfo", 
        "warning": null
    }, 
    "GAlignBottom": {
        "description": "<p>Align by making the bottom edges overlap and centered horizontally. </p>", 
        "kind": "enum", 
        "name": "GAlignBottom", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignBottomLeft": {
        "description": "<p>Align by making the bottom edges overlap and left edges overlap. </p>", 
        "kind": "enum", 
        "name": "GAlignBottomLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignBottomRight": {
        "description": "<p>Align by making the bottom edges overlap and right edges overlap. </p>", 
        "kind": "enum", 
        "name": "GAlignBottomRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignCenter": {
        "description": "<p>Align by centering. </p>", 
        "kind": "enum", 
        "name": "GAlignCenter", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignLeft": {
        "description": "<p>Align by making the left edges overlap and centered vertically. </p>", 
        "kind": "enum", 
        "name": "GAlignLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignRight": {
        "description": "<p>Align by making the right edges overlap and centered vertically. </p>", 
        "kind": "enum", 
        "name": "GAlignRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignTop": {
        "description": "<p>Align by making the top edges overlap and centered horizontally. </p>", 
        "kind": "enum", 
        "name": "GAlignTop", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignTopLeft": {
        "description": "<p>Align by making the top edges overlap and left edges overlap. </p>", 
        "kind": "enum", 
        "name": "GAlignTopLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GAlignTopRight": {
        "description": "<p>Align by making the top edges overlap and left edges overlap. </p>", 
        "kind": "enum", 
        "name": "GAlignTopRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmap": {
        "description": "", 
        "kind": "typedef", 
        "name": "GBitmap", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GBitmap", 
        "warning": null
    }, 
    "GBitmapFormat1Bit": {
        "description": "", 
        "kind": "enum", 
        "name": "GBitmapFormat1Bit", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmapFormat1BitPalette": {
        "description": "", 
        "kind": "enum", 
        "name": "GBitmapFormat1BitPalette", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmapFormat2BitPalette": {
        "description": "", 
        "kind": "enum", 
        "name": "GBitmapFormat2BitPalette", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmapFormat4BitPalette": {
        "description": "", 
        "kind": "enum", 
        "name": "GBitmapFormat4BitPalette", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmapFormat8Bit": {
        "description": "", 
        "kind": "enum", 
        "name": "GBitmapFormat8Bit", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmapFormat8BitCircular": {
        "description": "", 
        "kind": "enum", 
        "name": "GBitmapFormat8BitCircular", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GBitmapSequence": {
        "description": "", 
        "kind": "typedef", 
        "name": "GBitmapSequence", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GBitmapSequence", 
        "warning": null
    }, 
    "GColor": {
        "description": "", 
        "kind": "typedef", 
        "name": "GColor", 
        "params": [], 
        "return_desc": null, 
        "returns": "GColor8", 
        "warning": null
    }, 
    "GColor8Getter": {
        "description": "<p>Function signature of a getter function to get the current property of type GColor8 of the subject. </p>", 
        "kind": "typedef", 
        "name": "GColor8Getter", 
        "params": [], 
        "return_desc": null, 
        "returns": "GColor8(*", 
        "warning": null
    }, 
    "GColor8Setter": {
        "description": "<p>Function signature of a setter function to set a property of type GColor8 onto the subject. </p>", 
        "kind": "typedef", 
        "name": "GColor8Setter", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "GCompOpAnd": {
        "description": "<p>Use the boolean operator AND to composite the source and destination pixels. The visual result of this compositing mode is the source's black pixels are painted onto the destination and the source's white pixels are treated as clear. </p>", 
        "kind": "enum", 
        "name": "GCompOpAnd", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </p>"
    }, 
    "GCompOpAssign": {
        "description": "<p>Assign the pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. For color displays, when drawing a palettized or 8-bit GBitmap image, the opacity value is ignored. </p>", 
        "kind": "enum", 
        "name": "GCompOpAssign", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCompOpAssignInverted": {
        "description": "<p>Assign the inverted pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p>", 
        "kind": "enum", 
        "name": "GCompOpAssignInverted", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </p>"
    }, 
    "GCompOpClear": {
        "description": "<p>Clears the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is white, the destination image will be painted black. Other parts will be left untouched. </p>", 
        "kind": "enum", 
        "name": "GCompOpClear", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </p>"
    }, 
    "GCompOpOr": {
        "description": "<p>Use the boolean operator OR to composite the source and destination pixels. The visual result of this compositing mode is the source's white pixels are painted onto the destination and the source's black pixels are treated as clear. </p>", 
        "kind": "enum", 
        "name": "GCompOpOr", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </p>"
    }, 
    "GCompOpSet": {
        "description": "<p>Sets the bits in the destination image, using the source image as mask. This mode is required to apply any transparency of your bitmap. </p>", 
        "kind": "enum", 
        "name": "GCompOpSet", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>For bitmaps of the format GBitmapFormat1Bit, the visual result of this compositing mode is that for the parts where the source image is black, the destination image will be painted white. Other parts will be left untouched. </p>"
    }, 
    "GContext": {
        "description": "", 
        "kind": "typedef", 
        "name": "GContext", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GContext", 
        "warning": null
    }, 
    "GCornerBottomLeft": {
        "description": "<p>Bottom-Left corner. </p>", 
        "kind": "enum", 
        "name": "GCornerBottomLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornerBottomRight": {
        "description": "<p>Bottom-Right corner. </p>", 
        "kind": "enum", 
        "name": "GCornerBottomRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornerNone": {
        "description": "<p>No corners. </p>", 
        "kind": "enum", 
        "name": "GCornerNone", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornerTopLeft": {
        "description": "<p>Top-Left corner. </p>", 
        "kind": "enum", 
        "name": "GCornerTopLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornerTopRight": {
        "description": "<p>Top-Right corner. </p>", 
        "kind": "enum", 
        "name": "GCornerTopRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornersAll": {
        "description": "<p>All corners. </p>", 
        "kind": "enum", 
        "name": "GCornersAll", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornersBottom": {
        "description": "<p>Bottom corners. </p>", 
        "kind": "enum", 
        "name": "GCornersBottom", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornersLeft": {
        "description": "<p>Left corners. </p>", 
        "kind": "enum", 
        "name": "GCornersLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornersRight": {
        "description": "<p>Right corners. </p>", 
        "kind": "enum", 
        "name": "GCornersRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GCornersTop": {
        "description": "<p>Top corners. </p>", 
        "kind": "enum", 
        "name": "GCornersTop", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GDrawCommand": {
        "description": "<p>Draw commands are the basic building block of the draw command system, encoding the type of command to draw, the stroke width and color, fill color, and points that define the path (or center of a circle. </p>", 
        "kind": "typedef", 
        "name": "GDrawCommand", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GDrawCommand", 
        "warning": null
    }, 
    "GDrawCommandFrame": {
        "description": "<p>Draw command frames contain a list of commands to draw for that frame and a duration, indicating the length of time for which the frame should be drawn in an animation sequence. Frames form the building blocks of a GDrawCommandSequence, which consists of multiple frames. </p>", 
        "kind": "typedef", 
        "name": "GDrawCommandFrame", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GDrawCommandFrame", 
        "warning": null
    }, 
    "GDrawCommandImage": {
        "description": "<p>Draw command images contain a list of commands that can be drawn. An image can be loaded from PDC file data. </p>", 
        "kind": "typedef", 
        "name": "GDrawCommandImage", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GDrawCommandImage", 
        "warning": null
    }, 
    "GDrawCommandList": {
        "description": "<p>Draw command lists contain a list of commands that can be iterated over and drawn all at once. </p>", 
        "kind": "typedef", 
        "name": "GDrawCommandList", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GDrawCommandList", 
        "warning": null
    }, 
    "GDrawCommandListIteratorCb": {
        "description": "<p>Callback for iterating over draw command list. </p>", 
        "kind": "typedef", 
        "name": "GDrawCommandListIteratorCb", 
        "params": [], 
        "return_desc": "<p>true if the iteration should continue after this command is processed </p>", 
        "returns": "bool(*", 
        "warning": null
    }, 
    "GDrawCommandSequence": {
        "description": "<p>Draw command sequences allow the animation of frames over time. Each sequence has a list of frames that can be accessed by the elapsed duration of the animation (not maintained internally) or by index. Sequences can be loaded from PDC file data. </p>", 
        "kind": "typedef", 
        "name": "GDrawCommandSequence", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GDrawCommandSequence", 
        "warning": null
    }, 
    "GDrawCommandTypeCircle": {
        "description": "<p>Circle draw command type. </p>", 
        "kind": "enum", 
        "name": "GDrawCommandTypeCircle", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GDrawCommandTypeInvalid": {
        "description": "<p>Invalid draw command type. </p>", 
        "kind": "enum", 
        "name": "GDrawCommandTypeInvalid", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GDrawCommandTypePath": {
        "description": "<p>Arbitrary path draw command type. </p>", 
        "kind": "enum", 
        "name": "GDrawCommandTypePath", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GDrawCommandTypePrecisePath": {
        "description": "<p>Arbitrary path drawn with sub-pixel precision (1/8th precision) </p>", 
        "kind": "enum", 
        "name": "GDrawCommandTypePrecisePath", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GEdgeInsets": {
        "description": "<p><ul><li><p>just one value GEdgeInsets(v1) to configure all edges with v1 (GEdgeInsets){.top = v1, .right = v1, .bottom = v1, .left = v1}</p></li><li><p>two values v1, v2 to configure a vertical and horizontal inset as (GEdgeInsets){.top = v1, .right = v2, .bottom = v1, .left = v2}</p></li><li><p>three values v1, v2, v3 to configure it with (GEdgeInsets){.top = v1, .right = v2, .bottom = v3, .left = v2}</p></li><li><p>four values v1, v2, v3, v4 to configure it with (GEdgeInsets){.top = v1, .right = v2, .bottom = v3, .left = v4} \n</p></li></ul>\n</p>", 
        "kind": "def", 
        "name": "GEdgeInsets", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GEdgeInsets1": {
        "description": "<p>helper for GEdgeInsets macro </p>", 
        "kind": "def", 
        "name": "GEdgeInsets1", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GEdgeInsets2": {
        "description": "<p>helper for GEdgeInsets macro </p>", 
        "kind": "def", 
        "name": "GEdgeInsets2", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GEdgeInsets3": {
        "description": "<p>helper for GEdgeInsets macro </p>", 
        "kind": "def", 
        "name": "GEdgeInsets3", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GEdgeInsets4": {
        "description": "<p>helper for GEdgeInsets macro </p>", 
        "kind": "def", 
        "name": "GEdgeInsets4", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GEdgeInsetsN": {
        "description": "<p>helper for GEdgeInsets macro </p>", 
        "kind": "def", 
        "name": "GEdgeInsetsN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GFont": {
        "description": "<p>Pointer to opaque font data structure. </p>", 
        "kind": "typedef", 
        "name": "GFont", 
        "params": [], 
        "return_desc": null, 
        "returns": "FontInfo *", 
        "warning": null
    }, 
    "GOvalScaleModeFillCircle": {
        "description": "<p>Places the smallest possible circle in the center of a rectangle so that the rectangle is fully inside the circle. </p>", 
        "kind": "enum", 
        "name": "GOvalScaleModeFillCircle", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GOvalScaleModeFitCircle": {
        "description": "<p>Places the largest possible fully visible circle in the center of a rectangle. </p>", 
        "kind": "enum", 
        "name": "GOvalScaleModeFitCircle", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GPoint": {
        "description": "<p>Convenience macro to make a GPoint. </p>", 
        "kind": "def", 
        "name": "GPoint", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GPointGetter": {
        "description": "<p>Function signature of a getter function to get the current property of type GPoint of the subject. </p>", 
        "kind": "typedef", 
        "name": "GPointGetter", 
        "params": [], 
        "return_desc": null, 
        "returns": "GPointReturn(*", 
        "warning": null
    }, 
    "GPointReturn": {
        "description": "<p>Work-around for function pointer return type GPoint to avoid tripping the pre-processor to use the equally named GPoint define. </p>", 
        "kind": "typedef", 
        "name": "GPointReturn", 
        "params": [], 
        "return_desc": null, 
        "returns": "GPoint", 
        "warning": null
    }, 
    "GPointSetter": {
        "description": "<p>Function signature of a setter function to set a property of type GPoint onto the subject. </p>", 
        "kind": "typedef", 
        "name": "GPointSetter", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "GPointZero": {
        "description": "<p>Convenience macro to make a GPoint at (0, 0). </p>", 
        "kind": "def", 
        "name": "GPointZero", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GRect": {
        "description": "<p>Convenience macro to make a GRect. </p>", 
        "kind": "def", 
        "name": "GRect", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GRectGetter": {
        "description": "<p>Function signature of a getter function to get the current property of type GRect of the subject. </p>", 
        "kind": "typedef", 
        "name": "GRectGetter", 
        "params": [], 
        "return_desc": null, 
        "returns": "GRectReturn(*", 
        "warning": null
    }, 
    "GRectReturn": {
        "description": "<p>Work-around for function pointer return type GRect to avoid tripping the pre-processor to use the equally named GRect define. </p>", 
        "kind": "typedef", 
        "name": "GRectReturn", 
        "params": [], 
        "return_desc": null, 
        "returns": "GRect", 
        "warning": null
    }, 
    "GRectSetter": {
        "description": "<p>Function signature of a setter function to set a property of type GRect onto the subject. </p>", 
        "kind": "typedef", 
        "name": "GRectSetter", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "GRectZero": {
        "description": "<p>Convenience macro to make a GRect of ((0, 0), (0, 0)). </p>", 
        "kind": "def", 
        "name": "GRectZero", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GSize": {
        "description": "<p>Convenience macro to make a GSize. </p>", 
        "kind": "def", 
        "name": "GSize", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GSizeZero": {
        "description": "<p>Convenience macro to make a GSize of (0, 0). </p>", 
        "kind": "def", 
        "name": "GSizeZero", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GTextAlignmentCenter": {
        "description": "<p>Aligns the text centered inside the drawing box. </p>", 
        "kind": "enum", 
        "name": "GTextAlignmentCenter", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GTextAlignmentLeft": {
        "description": "<p>Aligns the text to the left of the drawing box. </p>", 
        "kind": "enum", 
        "name": "GTextAlignmentLeft", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GTextAlignmentRight": {
        "description": "<p>Aligns the text to the right of the drawing box. </p>", 
        "kind": "enum", 
        "name": "GTextAlignmentRight", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GTextAttributes": {
        "description": "", 
        "kind": "typedef", 
        "name": "GTextAttributes", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct GTextAttributes", 
        "warning": null
    }, 
    "GTextOverflowModeFill": {
        "description": "<p>Acts like GTextOverflowModeTrailingEllipsis, plus trims leading and trailing newlines, while treating all other newlines as spaces. </p>", 
        "kind": "enum", 
        "name": "GTextOverflowModeFill", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GTextOverflowModeTrailingEllipsis": {
        "description": "<p>On overflow, wrap words to a new line below the current one. Once vertical space is consumed, truncate as needed to fit a trailing ellipsis (...). Clipping may occur if the vertical space cannot accomodate the first line of text. </p>", 
        "kind": "enum", 
        "name": "GTextOverflowModeTrailingEllipsis", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "GTextOverflowModeWordWrap": {
        "description": "<p>On overflow, wrap words to a new line below the current one. Once vertical space is consumed, the last line may be clipped. </p>", 
        "kind": "enum", 
        "name": "GTextOverflowModeWordWrap", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HOURS_PER_DAY": {
        "description": "", 
        "kind": "def", 
        "name": "HOURS_PER_DAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HOUR_UNIT": {
        "description": "<p>Flag to represent the \"hours\" time unit. </p>", 
        "kind": "enum", 
        "name": "HOUR_UNIT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthActivityIteratorCB": {
        "description": "<p>Callback used by <code>health_service_activities_iterate()</code>. </p>", 
        "kind": "typedef", 
        "name": "HealthActivityIteratorCB", 
        "params": [], 
        "return_desc": "<p>true if you are interested in more activities, or false to stop iterating. </p>", 
        "returns": "bool(*", 
        "warning": null
    }, 
    "HealthActivityMask": {
        "description": "<p>Expresses a set of HealthActivity values as a bitmask. </p>", 
        "kind": "typedef", 
        "name": "HealthActivityMask", 
        "params": [], 
        "return_desc": null, 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "HealthActivityMaskAll": {
        "description": "<p>A mask value representing all available activities. </p>", 
        "kind": "def", 
        "name": "HealthActivityMaskAll", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthActivityNone": {
        "description": "<p>No special activity. </p>", 
        "kind": "enum", 
        "name": "HealthActivityNone", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthActivityRestfulSleep": {
        "description": "<p>The 'restful sleeping' activity. </p>", 
        "kind": "enum", 
        "name": "HealthActivityRestfulSleep", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthActivityRun": {
        "description": "<p>The 'run' activity. </p>", 
        "kind": "enum", 
        "name": "HealthActivityRun", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthActivitySleep": {
        "description": "<p>The 'sleeping' activity. </p>", 
        "kind": "enum", 
        "name": "HealthActivitySleep", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthActivityWalk": {
        "description": "<p>The 'walk' activity. </p>", 
        "kind": "enum", 
        "name": "HealthActivityWalk", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthAggregationAvg": {
        "description": "<p>Use the average of the metric. This is only applicable for metrics that measure instantaneous values, like HealthMetricHeartRateBPM. </p>", 
        "kind": "enum", 
        "name": "HealthAggregationAvg", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthAggregationMax": {
        "description": "<p>Use the maximum value of the metric. This is only applicable for metrics that measure instantaneous values, like HealthMetricHeartRateBPM. </p>", 
        "kind": "enum", 
        "name": "HealthAggregationMax", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthAggregationMin": {
        "description": "<p>Use the minimum value of the metric. This is only applicable for metrics that measure instantaneous values, like HealthMetricHeartRateBPM. </p>", 
        "kind": "enum", 
        "name": "HealthAggregationMin", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthAggregationSum": {
        "description": "<p>Sum the metric. The result is the same as calling <code>health_service_sum_averaged()</code>. This operation is only applicable for metrics that accumulate, like HealthMetricStepCount, HealthMetricActiveSeconds, etc. </p>", 
        "kind": "enum", 
        "name": "HealthAggregationSum", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthEventHandler": {
        "description": "<p>Developer-supplied event handler, called when a health-related event occurs after subscribing via <code>health_service_events_subscribe()</code>;. </p>", 
        "kind": "typedef", 
        "name": "HealthEventHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "HealthEventHeartRateUpdate": {
        "description": "<p>Value of HealthMetricHeartRateBPM has changed. </p>", 
        "kind": "enum", 
        "name": "HealthEventHeartRateUpdate", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthEventMetricAlert": {
        "description": "<p>A metric has crossed the threshold set by <code>health_service_register_metric_alert</code>. </p>", 
        "kind": "enum", 
        "name": "HealthEventMetricAlert", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthEventMovementUpdate": {
        "description": "<p>Recent values around HealthMetricStepCount, HealthMetricActiveSeconds, or HealthMetricWalkedDistanceMeters have changed. </p>", 
        "kind": "enum", 
        "name": "HealthEventMovementUpdate", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthEventSignificantUpdate": {
        "description": "<p>All data is considered as outdated and apps should re-read all health data. This happens after an app is subscribed via <code>health_service_events_subscribe()</code>, on a change of the day, or in other cases that significantly change the underlying data. </p>", 
        "kind": "enum", 
        "name": "HealthEventSignificantUpdate", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthEventSleepUpdate": {
        "description": "<p>Recent values around HealthMetricSleepSeconds, HealthMetricSleepRestfulSeconds, HealthActivitySleep, and HealthActivityRestfulSleep changed. </p>", 
        "kind": "enum", 
        "name": "HealthEventSleepUpdate", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthIterationDirectionFuture": {
        "description": "<p>Iterate into the future. </p>", 
        "kind": "enum", 
        "name": "HealthIterationDirectionFuture", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthIterationDirectionPast": {
        "description": "<p>Iterate into the past. </p>", 
        "kind": "enum", 
        "name": "HealthIterationDirectionPast", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricActiveKCalories": {
        "description": "<p>The number of kcal (Calories) burned while active. </p>", 
        "kind": "enum", 
        "name": "HealthMetricActiveKCalories", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricActiveSeconds": {
        "description": "<p>The number of seconds spent active (i.e. not resting). </p>", 
        "kind": "enum", 
        "name": "HealthMetricActiveSeconds", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricAlert": {
        "description": "<p>Type used as a handle to a registered metric alert (returned by <code>health_service_register_metric_alert</code>) </p>", 
        "kind": "typedef", 
        "name": "HealthMetricAlert", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct HealthMetricAlert", 
        "warning": null
    }, 
    "HealthMetricHeartRateBPM": {
        "description": "<p>The heart rate, in beats per minute. </p>", 
        "kind": "enum", 
        "name": "HealthMetricHeartRateBPM", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricRestingKCalories": {
        "description": "<p>The number of kcal (Calories) burned while resting due to resting metabolism. </p>", 
        "kind": "enum", 
        "name": "HealthMetricRestingKCalories", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricSleepRestfulSeconds": {
        "description": "<p>The number of sleep seconds in the 'restful' or deep sleep state. </p>", 
        "kind": "enum", 
        "name": "HealthMetricSleepRestfulSeconds", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricSleepSeconds": {
        "description": "<p>The number of seconds spent sleeping. </p>", 
        "kind": "enum", 
        "name": "HealthMetricSleepSeconds", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricStepCount": {
        "description": "<p>The number of steps counted. </p>", 
        "kind": "enum", 
        "name": "HealthMetricStepCount", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthMetricWalkedDistanceMeters": {
        "description": "<p>The distance walked, in meters. </p>", 
        "kind": "enum", 
        "name": "HealthMetricWalkedDistanceMeters", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceAccessibilityMaskAvailable": {
        "description": "<p>Return values are available and represent the collected health information. </p>", 
        "kind": "enum", 
        "name": "HealthServiceAccessibilityMaskAvailable", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceAccessibilityMaskNoPermission": {
        "description": "<p>The user hasn't granted permission. </p>", 
        "kind": "enum", 
        "name": "HealthServiceAccessibilityMaskNoPermission", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceAccessibilityMaskNotAvailable": {
        "description": "<p>No samples were recorded for the given time span. </p>", 
        "kind": "enum", 
        "name": "HealthServiceAccessibilityMaskNotAvailable", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceAccessibilityMaskNotSupported": {
        "description": "<p>The queried combination of time span and HealthMetric or HealthActivityMask is currently unsupported. </p>", 
        "kind": "enum", 
        "name": "HealthServiceAccessibilityMaskNotSupported", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceTimeScopeDaily": {
        "description": "<p>Compute average across all days of the week. </p>", 
        "kind": "enum", 
        "name": "HealthServiceTimeScopeDaily", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceTimeScopeDailyWeekdayOrWeekend": {
        "description": "<p>Compute average using either weekdays (Monday to Friday) or weekends (Saturday and Sunday), depending on which day the passed in time range falls. </p>", 
        "kind": "enum", 
        "name": "HealthServiceTimeScopeDailyWeekdayOrWeekend", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceTimeScopeOnce": {
        "description": "<p>No average computed. The result is the same as calling <code>health_service_sum()</code>. </p>", 
        "kind": "enum", 
        "name": "HealthServiceTimeScopeOnce", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthServiceTimeScopeWeekly": {
        "description": "<p>Compute average using the same day from each week. For example, every Monday if the passed in time range falls on a Monday. </p>", 
        "kind": "enum", 
        "name": "HealthServiceTimeScopeWeekly", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "HealthValue": {
        "description": "<p>Type used to represent HealthMetric values. </p>", 
        "kind": "typedef", 
        "name": "HealthValue", 
        "params": [], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "IS_SIGNED": {
        "description": "<p>Determine whether a variable is signed or not. </p>", 
        "kind": "def", 
        "name": "IS_SIGNED", 
        "params": [], 
        "return_desc": "<p>true if the variable is signed. </p>", 
        "returns": "", 
        "warning": null
    }, 
    "Int16Getter": {
        "description": "<p>Function signature of a getter function to get the current property of type <code>int16_t</code> of the subject. </p>", 
        "kind": "typedef", 
        "name": "Int16Getter", 
        "params": [], 
        "return_desc": null, 
        "returns": "int16_t(*", 
        "warning": null
    }, 
    "Int16Setter": {
        "description": "<p>Function signature of a setter function to set a property of type <code>int16_t</code> onto the subject. </p>", 
        "kind": "typedef", 
        "name": "Int16Setter", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "Layer": {
        "description": "", 
        "kind": "typedef", 
        "name": "Layer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct Layer", 
        "warning": null
    }, 
    "LayerUpdateProc": {
        "description": "<p>Function signature for a Layer's render callback (the name of the type is derived from the words 'update procedure'). The system will call the .<code>update_proc</code> callback whenever the Layer needs to be rendered. </p>", 
        "kind": "typedef", 
        "name": "LayerUpdateProc", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "MENU_CELL_BASIC_HEADER_HEIGHT": {
        "description": "<p>Default section header height in pixels. </p>", 
        "kind": "def", 
        "name": "MENU_CELL_BASIC_HEADER_HEIGHT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MENU_CELL_ROUND_FOCUSED_SHORT_CELL_HEIGHT": {
        "description": "<p>Constant value representing MenuLayer short cell height when this item is the selected item on a round display. </p>", 
        "kind": "def", 
        "name": "MENU_CELL_ROUND_FOCUSED_SHORT_CELL_HEIGHT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MENU_CELL_ROUND_FOCUSED_TALL_CELL_HEIGHT": {
        "description": "<p>Constant value representing MenuLayer tall cell height when this item is the selected item on a round display. </p>", 
        "kind": "def", 
        "name": "MENU_CELL_ROUND_FOCUSED_TALL_CELL_HEIGHT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MENU_CELL_ROUND_UNFOCUSED_SHORT_CELL_HEIGHT": {
        "description": "<p>Constant value representing MenuLayer short cell height when this item is not the selected item on a round display. </p>", 
        "kind": "def", 
        "name": "MENU_CELL_ROUND_UNFOCUSED_SHORT_CELL_HEIGHT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MENU_CELL_ROUND_UNFOCUSED_TALL_CELL_HEIGHT": {
        "description": "<p>Constant value representing MenuLayer tall cell height when this item is not the selected item on a round display. </p>", 
        "kind": "def", 
        "name": "MENU_CELL_ROUND_UNFOCUSED_TALL_CELL_HEIGHT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MENU_INDEX_NOT_FOUND": {
        "description": "", 
        "kind": "def", 
        "name": "MENU_INDEX_NOT_FOUND", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MINUTES_PER_DAY": {
        "description": "", 
        "kind": "def", 
        "name": "MINUTES_PER_DAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MINUTES_PER_HOUR": {
        "description": "", 
        "kind": "def", 
        "name": "MINUTES_PER_HOUR", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MINUTE_UNIT": {
        "description": "<p>Flag to represent the \"minutes\" time unit. </p>", 
        "kind": "enum", 
        "name": "MINUTE_UNIT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MONDAY": {
        "description": "<p>Monday. </p>", 
        "kind": "enum", 
        "name": "MONDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MONTH_UNIT": {
        "description": "<p>Flag to represent the \"months\" time unit. </p>", 
        "kind": "enum", 
        "name": "MONTH_UNIT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MeasurementSystemImperial": {
        "description": "<p>The imperial measurement system. </p>", 
        "kind": "enum", 
        "name": "MeasurementSystemImperial", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MeasurementSystemMetric": {
        "description": "<p>The metric measurement system. </p>", 
        "kind": "enum", 
        "name": "MeasurementSystemMetric", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MeasurementSystemUnknown": {
        "description": "<p>The measurement system is unknown, or does not apply to the chosen metric. </p>", 
        "kind": "enum", 
        "name": "MeasurementSystemUnknown", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MenuIndex": {
        "description": "<p>Macro to create a MenuIndex. </p>", 
        "kind": "def", 
        "name": "MenuIndex", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MenuLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "MenuLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct MenuLayer", 
        "warning": null
    }, 
    "MenuLayerDrawBackgroundCallback": {
        "description": "<p>Function signature for the callback which draws the menu's background. The background is underneath the cells of the menu, and is visible in the padding below the bottom cell, or if a cell's background color is set to GColorClear. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerDrawBackgroundCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "MenuLayerDrawHeaderCallback": {
        "description": "<p>Function signature for the callback to render the section header at a given section index. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerDrawHeaderCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>The <code>cell_layer</code> argument is provided to make it easy to re-use an .<code>update_proc</code> implementation in this callback. Only the bounds and frame of the <code>cell_layer</code> are actually valid and other properties should be ignored. </p>"
    }, 
    "MenuLayerDrawRowCallback": {
        "description": "<p>Function signature for the callback to render the menu cell at a given MenuIndex. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerDrawRowCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>The <code>cell_layer</code> argument is provided to make it easy to re-use an .<code>update_proc</code> implementation in this callback. Only the bounds and frame of the <code>cell_layer</code> are actually valid and other properties should be ignored. </p>"
    }, 
    "MenuLayerDrawSeparatorCallback": {
        "description": "<p>Function signature for the callback to render the separator at a given MenuIndex. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerDrawSeparatorCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>The <code>cell_layer</code> argument is provided to make it easy to re-use an .<code>update_proc</code> implementation in this callback. Only the bounds and frame of the <code>cell_layer</code> are actually valid and other properties should be ignored. </p>"
    }, 
    "MenuLayerGetCellHeightCallback": {
        "description": "<p>Function signature for the callback to get the height of the menu cell at a given index. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerGetCellHeightCallback", 
        "params": [], 
        "return_desc": "<p>The height of the cell at the given MenuIndex </p>", 
        "returns": "int16_t(*", 
        "warning": null
    }, 
    "MenuLayerGetHeaderHeightCallback": {
        "description": "<p>Function signature for the callback to get the height of the section header at a given section index. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerGetHeaderHeightCallback", 
        "params": [], 
        "return_desc": "<p>The height of the section header at the given section index </p>", 
        "returns": "int16_t(*", 
        "warning": null
    }, 
    "MenuLayerGetNumberOfRowsInSectionsCallback": {
        "description": "<p>Function signature for the callback to get the number of rows in a given section in a menu. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerGetNumberOfRowsInSectionsCallback", 
        "params": [], 
        "return_desc": "<p>The number of rows in the given section in the menu </p>", 
        "returns": "uint16_t(*", 
        "warning": null
    }, 
    "MenuLayerGetNumberOfSectionsCallback": {
        "description": "<p>Function signature for the callback to get the number of sections in a menu. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerGetNumberOfSectionsCallback", 
        "params": [], 
        "return_desc": "<p>The number of sections in the menu </p>", 
        "returns": "uint16_t(*", 
        "warning": null
    }, 
    "MenuLayerGetSeparatorHeightCallback": {
        "description": "<p>Function signature for the callback to get the height of the separator at a given index. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerGetSeparatorHeightCallback", 
        "params": [], 
        "return_desc": "<p>The height of the separator at the given MenuIndex </p>", 
        "returns": "int16_t(*", 
        "warning": null
    }, 
    "MenuLayerSelectCallback": {
        "description": "<p>Function signature for the callback to handle the event that a user hits the SELECT button. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerSelectCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "MenuLayerSelectionChangedCallback": {
        "description": "<p>Function signature for the callback to handle a change in the current selected item in the menu. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerSelectionChangedCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "MenuLayerSelectionWillChangeCallback": {
        "description": "<p>Function signature for the callback which allows or changes selection behavior of the menu. In order to change the cell that should be selected, modify the passed in <code>new_index</code>. Preventing the selection from changing, <code>new_index</code> can be assigned the value of <code>old_index</code>. </p>", 
        "kind": "typedef", 
        "name": "MenuLayerSelectionWillChangeCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p><code>menu_layer_set_selected_index</code> will not trigger this callback when the selection changes, but <code>menu_layer_set_selected_next</code> will. </p>"
    }, 
    "MenuRowAlignBottom": {
        "description": "<p>Scroll the contents of the MenuLayer in such way that the selected row is at the bottom of the visible area. </p>", 
        "kind": "enum", 
        "name": "MenuRowAlignBottom", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MenuRowAlignCenter": {
        "description": "<p>Scroll the contents of the MenuLayer in such way that the selected row is centered relative to the visible area. </p>", 
        "kind": "enum", 
        "name": "MenuRowAlignCenter", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MenuRowAlignNone": {
        "description": "<p>Don't align or update the scroll offset of the MenuLayer. </p>", 
        "kind": "enum", 
        "name": "MenuRowAlignNone", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "MenuRowAlignTop": {
        "description": "<p>Scroll the contents of the MenuLayer in such way that the selected row is at the top of the visible area. </p>", 
        "kind": "enum", 
        "name": "MenuRowAlignTop", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "NUM_ACTION_BAR_ITEMS": {
        "description": "<p>The maximum number of action bar items. </p>", 
        "kind": "def", 
        "name": "NUM_ACTION_BAR_ITEMS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "NUM_BUTTONS": {
        "description": "<p>Total number of buttons. </p>", 
        "kind": "enum", 
        "name": "NUM_BUTTONS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "NUM_EXIT_REASONS": {
        "description": "<p>Number of AppExitReason options. </p>", 
        "kind": "enum", 
        "name": "NUM_EXIT_REASONS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "NumContentIndicatorDirections": {
        "description": "<p>The number of supported directions. </p>", 
        "kind": "enum", 
        "name": "NumContentIndicatorDirections", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "NumberWindow": {
        "description": "", 
        "kind": "typedef", 
        "name": "NumberWindow", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct NumberWindow", 
        "warning": null
    }, 
    "NumberWindowCallback": {
        "description": "<p>Function signature for NumberWindow callbacks. </p>", 
        "kind": "typedef", 
        "name": "NumberWindowCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "PBL_APP_INFO": {
        "description": "", 
        "kind": "def", 
        "name": "PBL_APP_INFO", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_APP_INFO_SIMPLE": {
        "description": "", 
        "kind": "def", 
        "name": "PBL_APP_INFO_SIMPLE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_BW_ELSE": {
        "description": "<p>Convenience macro to switch between two expression depending on the screen of the platform. On black& white platforms, the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_BW_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_COLOR_ELSE": {
        "description": "<p>Convenience macro to switch between two expression depending on the screen of the platform. On color platforms, the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_COLOR_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_HEALTH_ELSE": {
        "description": "<p>Convenience macro to switch between two expressions depending on health support. On platforms with health support the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_HEALTH_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_MICROPHONE_ELSE": {
        "description": "<p>Convenience macro to switch between two expressions depending on mic support. On platforms with a mic the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_MICROPHONE_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_RECT_ELSE": {
        "description": "<p>Convenience macro to switch between two expression depending on the screen of the platform. On platforms with rectangular screen, the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_RECT_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_ROUND_ELSE": {
        "description": "<p>Convenience macro to switch between two expression depending on the screen of the platform. On platforms with round screen, the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_ROUND_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PBL_IF_SMARTSTRAP_ELSE": {
        "description": "<p>Convenience macro to switch between two expressions depending on smartstrap support. On platforms with a smartstrap the first expression will be chosen, the second otherwise. </p>", 
        "kind": "def", 
        "name": "PBL_IF_SMARTSTRAP_ELSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PERSIST_DATA_MAX_LENGTH": {
        "description": "<p>The maximum size of a persist value in bytes. </p>", 
        "kind": "def", 
        "name": "PERSIST_DATA_MAX_LENGTH", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PERSIST_STRING_MAX_LENGTH": {
        "description": "<p>The maximum size of a persist string in bytes including the NULL terminator. </p>", 
        "kind": "def", 
        "name": "PERSIST_STRING_MAX_LENGTH", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PLAY_COUNT_INFINITE": {
        "description": "<p>Repeat Sequence or animation indefinitely. </p>", 
        "kind": "def", 
        "name": "PLAY_COUNT_INFINITE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PLAY_DURATION_INFINITE": {
        "description": "<p>Duration of Sequence or animation is infinite. </p>", 
        "kind": "def", 
        "name": "PLAY_DURATION_INFINITE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "PropertyAnimation": {
        "description": "", 
        "kind": "typedef", 
        "name": "PropertyAnimation", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct PropertyAnimation", 
        "warning": null
    }, 
    "PublishedId": {
        "description": "<p>The ID of a published app resource defined within the publishedMedia section of package.json. </p>", 
        "kind": "typedef", 
        "name": "PublishedId", 
        "params": [], 
        "return_desc": null, 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "RESOURCE_ID_FONT_FALLBACK": {
        "description": "", 
        "kind": "def", 
        "name": "RESOURCE_ID_FONT_FALLBACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ResHandle": {
        "description": "<p>Opaque reference to a resource. </p>", 
        "kind": "typedef", 
        "name": "ResHandle", 
        "params": [], 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null
    }, 
    "RotBitmapLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "RotBitmapLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct RotBitmapLayer", 
        "warning": null
    }, 
    "SATURDAY": {
        "description": "<p>Saturday. </p>", 
        "kind": "enum", 
        "name": "SATURDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SECONDS_PER_DAY": {
        "description": "", 
        "kind": "def", 
        "name": "SECONDS_PER_DAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SECONDS_PER_HOUR": {
        "description": "", 
        "kind": "def", 
        "name": "SECONDS_PER_HOUR", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SECONDS_PER_MINUTE": {
        "description": "", 
        "kind": "def", 
        "name": "SECONDS_PER_MINUTE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SECOND_UNIT": {
        "description": "<p>Flag to represent the \"seconds\" time unit. </p>", 
        "kind": "enum", 
        "name": "SECOND_UNIT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SMARTSTRAP_RAW_DATA_ATTRIBUTE_ID": {
        "description": "<p>The <code>attribute_id</code> to specify in order to read/write raw data to the smartstrap. </p>", 
        "kind": "def", 
        "name": "SMARTSTRAP_RAW_DATA_ATTRIBUTE_ID", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SMARTSTRAP_RAW_DATA_SERVICE_ID": {
        "description": "<p>The <code>service_id</code> to specify in order to read/write raw data to the smartstrap. </p>", 
        "kind": "def", 
        "name": "SMARTSTRAP_RAW_DATA_SERVICE_ID", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SMARTSTRAP_TIMEOUT_DEFAULT": {
        "description": "<p>The default request timeout in milliseconds (see <code>smartstrap_set_timeout</code>). </p>", 
        "kind": "def", 
        "name": "SMARTSTRAP_TIMEOUT_DEFAULT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SNIFF_INTERVAL_NORMAL": {
        "description": "<p>Set the sniff interval to normal (power-saving) mode. </p>", 
        "kind": "enum", 
        "name": "SNIFF_INTERVAL_NORMAL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SNIFF_INTERVAL_REDUCED": {
        "description": "<p>Reduce the sniff interval to increase the responsiveness of the radio at the expense of increasing Bluetooth energy consumption by a multiple of 2-5 (very significant) </p>", 
        "kind": "enum", 
        "name": "SNIFF_INTERVAL_REDUCED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "STATUS_BAR_LAYER_HEIGHT": {
        "description": "<p>The fixed height of the status bar, including separator height. </p>", 
        "kind": "def", 
        "name": "STATUS_BAR_LAYER_HEIGHT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SUNDAY": {
        "description": "<p>Sunday. </p>", 
        "kind": "enum", 
        "name": "SUNDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "S_FALSE": {
        "description": "<p>Equivalent of boolean false. </p>", 
        "kind": "enum", 
        "name": "S_FALSE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "S_NO_ACTION_REQUIRED": {
        "description": "<p>No action was taken as none was required. </p>", 
        "kind": "enum", 
        "name": "S_NO_ACTION_REQUIRED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "S_NO_MORE_ITEMS": {
        "description": "<p>For list-style requests. At end of list. </p>", 
        "kind": "enum", 
        "name": "S_NO_MORE_ITEMS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "S_SUCCESS": {
        "description": "<p>Operation completed successfully. </p>", 
        "kind": "enum", 
        "name": "S_SUCCESS", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "S_TRUE": {
        "description": "<p>Equivalent of boolean true. </p>", 
        "kind": "enum", 
        "name": "S_TRUE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "ScrollLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "ScrollLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct ScrollLayer", 
        "warning": null
    }, 
    "ScrollLayerCallback": {
        "description": "<p>Function signature for the .<code>content_offset_changed_handler</code> callback. </p>", 
        "kind": "typedef", 
        "name": "ScrollLayerCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "SimpleMenuLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "SimpleMenuLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct SimpleMenuLayer", 
        "warning": null
    }, 
    "SimpleMenuLayerSelectCallback": {
        "description": "<p>Function signature for the callback to handle the event that a user hits the SELECT button. </p>", 
        "kind": "typedef", 
        "name": "SimpleMenuLayerSelectCallback", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "SmartstrapAttribute": {
        "description": "<p>A type representing an attribute of a service provided by a smartstrap. This type is used when issuing requests to the smartstrap. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapAttribute", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct SmartstrapAttribute", 
        "warning": null
    }, 
    "SmartstrapAttributeId": {
        "description": "<p>A type representing a smartstrap AttributeId. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapAttributeId", 
        "params": [], 
        "return_desc": null, 
        "returns": "uint16_t", 
        "warning": null
    }, 
    "SmartstrapNotifyHandler": {
        "description": "<p>The type of function which can be called when the smartstrap sends a notification to the watch. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapNotifyHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "SmartstrapReadHandler": {
        "description": "<p>The type of function which can be called when a read request is completed. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapReadHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>Any write request made to the same attribute within this function will fail with SmartstrapResultBusy. </p>"
    }, 
    "SmartstrapResultAttributeUnsupported": {
        "description": "<p>The smartstrap reported that it does not support the requested attribute. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultAttributeUnsupported", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapResultBusy": {
        "description": "<p>A request is already pending on the specified attribute. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultBusy", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapResultInvalidArgs": {
        "description": "<p>Invalid function arguments were supplied. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultInvalidArgs", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapResultNotPresent": {
        "description": "<p>The smartstrap port is not present on this watch. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultNotPresent", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapResultOk": {
        "description": "<p>No error occured. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultOk", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapResultServiceUnavailable": {
        "description": "<p>Either a smartstrap is not connected or the connected smartstrap does not support the specified service. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultServiceUnavailable", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapResultTimeOut": {
        "description": "<p>A time-out occured during the request. </p>", 
        "kind": "enum", 
        "name": "SmartstrapResultTimeOut", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "SmartstrapServiceAvailabilityHandler": {
        "description": "<p>The type of function which is called after the smartstrap connection status changes. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapServiceAvailabilityHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "SmartstrapServiceId": {
        "description": "<p>A type representing a smartstrap ServiceId. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapServiceId", 
        "params": [], 
        "return_desc": null, 
        "returns": "uint16_t", 
        "warning": null
    }, 
    "SmartstrapWriteHandler": {
        "description": "<p>The type of function which can be called when a write request is completed. </p>", 
        "kind": "typedef", 
        "name": "SmartstrapWriteHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "StatusBarLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "StatusBarLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct StatusBarLayer", 
        "warning": null
    }, 
    "StatusBarLayerSeparatorModeDotted": {
        "description": "<p>A dotted separator at the bottom of the status bar. </p>", 
        "kind": "enum", 
        "name": "StatusBarLayerSeparatorModeDotted", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "StatusBarLayerSeparatorModeNone": {
        "description": "<p>The default mode. No separator will be shown. </p>", 
        "kind": "enum", 
        "name": "StatusBarLayerSeparatorModeNone", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "THURSDAY": {
        "description": "<p>Thursday. </p>", 
        "kind": "enum", 
        "name": "THURSDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TIMEZONE_NAME_LENGTH": {
        "description": "<p>The maximum length for a timezone full name (e.g. America/Chicago) </p>", 
        "kind": "def", 
        "name": "TIMEZONE_NAME_LENGTH", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TODAY": {
        "description": "<p>Today. </p>", 
        "kind": "enum", 
        "name": "TODAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TRIGANGLE_TO_DEG": {
        "description": "<p>Converts from a fixed point value representation to the equivalent value in degrees. </p>", 
        "kind": "def", 
        "name": "TRIGANGLE_TO_DEG", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TRIG_MAX_ANGLE": {
        "description": "<p>Angle value that corresponds to 360 degrees or 2 PI radians. </p>", 
        "kind": "def", 
        "name": "TRIG_MAX_ANGLE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TRIG_MAX_RATIO": {
        "description": "<p>The largest value that can result from a call to <code>sin_lookup</code> or <code>cos_lookup</code>. For a code example, see the detailed description at the top of this chapter: Math. </p>", 
        "kind": "def", 
        "name": "TRIG_MAX_RATIO", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TUESDAY": {
        "description": "<p>Tuesday. </p>", 
        "kind": "enum", 
        "name": "TUESDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TUPLE_BYTE_ARRAY": {
        "description": "<p>The value is an array of bytes. </p>", 
        "kind": "enum", 
        "name": "TUPLE_BYTE_ARRAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TUPLE_CSTRING": {
        "description": "<p>The value is a zero-terminated, UTF-8 C-string. </p>", 
        "kind": "enum", 
        "name": "TUPLE_CSTRING", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TUPLE_INT": {
        "description": "<p>The value is a signed integer. The tuple's .length field is used to determine the size of the integer (1, 2, or 4 bytes). </p>", 
        "kind": "enum", 
        "name": "TUPLE_INT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TUPLE_UINT": {
        "description": "<p>The value is an unsigned integer. The tuple's .length field is used to determine the size of the integer (1, 2, or 4 bytes). </p>", 
        "kind": "enum", 
        "name": "TUPLE_UINT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TZ_LEN": {
        "description": "", 
        "kind": "def", 
        "name": "TZ_LEN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TextLayer": {
        "description": "", 
        "kind": "typedef", 
        "name": "TextLayer", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct TextLayer", 
        "warning": null
    }, 
    "TickHandler": {
        "description": "<p>Callback type for tick timer events. </p>", 
        "kind": "typedef", 
        "name": "TickHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "TupletBytes": {
        "description": "<p>Macro to create a Tuplet with a byte array value. </p>", 
        "kind": "def", 
        "name": "TupletBytes", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TupletCString": {
        "description": "<p>Macro to create a Tuplet with a c-string value. </p>", 
        "kind": "def", 
        "name": "TupletCString", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "TupletInteger": {
        "description": "<p>Macro to create a Tuplet with an integer value. </p>", 
        "kind": "def", 
        "name": "TupletInteger", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "UInt32Getter": {
        "description": "<p>Function signature of a getter function to get the current property of type <code>uint32_t</code> of the subject. </p>", 
        "kind": "typedef", 
        "name": "UInt32Getter", 
        "params": [], 
        "return_desc": null, 
        "returns": "uint32_t(*", 
        "warning": null
    }, 
    "UInt32Setter": {
        "description": "<p>Function signature of a setter function to set a property of type <code>uint32_t</code> onto the subject. </p>", 
        "kind": "typedef", 
        "name": "UInt32Setter", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "UUID_SIZE": {
        "description": "", 
        "kind": "def", 
        "name": "UUID_SIZE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "UUID_STRING_BUFFER_LENGTH": {
        "description": "<p>The minimum required length of a string used to hold a uuid (including null). </p>", 
        "kind": "def", 
        "name": "UUID_STRING_BUFFER_LENGTH", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "UnobstructedAreaChangeHandler": {
        "description": "<p>Handler that will be called every time the unobstructed area changes. </p>", 
        "kind": "typedef", 
        "name": "UnobstructedAreaChangeHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "UnobstructedAreaDidChangeHandler": {
        "description": "<p>Handler that will be called after the unobstructed area has finished changing. </p>", 
        "kind": "typedef", 
        "name": "UnobstructedAreaDidChangeHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "UnobstructedAreaWillChangeHandler": {
        "description": "<p>Handler that will be called just before the unobstructed area will begin changing. </p>", 
        "kind": "typedef", 
        "name": "UnobstructedAreaWillChangeHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "UuidMake": {
        "description": "<p>Make a Uuid object from sixteen bytes. </p>", 
        "kind": "def", 
        "name": "UuidMake", 
        "params": [], 
        "return_desc": "<p>A Uuid structure representing the bytes p0 to p15. </p>", 
        "returns": "", 
        "warning": null
    }, 
    "UuidMakeFromBEBytes": {
        "description": "<p>Creates a Uuid from an array of bytes with 16 bytes in Big Endian order. </p>", 
        "kind": "def", 
        "name": "UuidMakeFromBEBytes", 
        "params": [], 
        "return_desc": "<p>The created Uuid </p>", 
        "returns": "", 
        "warning": null
    }, 
    "UuidMakeFromLEBytes": {
        "description": "<p>Creates a Uuid from an array of bytes with 16 bytes in Little Endian order. </p>", 
        "kind": "def", 
        "name": "UuidMakeFromLEBytes", 
        "params": [], 
        "return_desc": "<p>The created Uuid </p>", 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_BLACK": {
        "description": "<p>Black. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_BLACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_BLUE": {
        "description": "<p>Blue. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_BLUE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_GRAY": {
        "description": "<p>Gray. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_GRAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_GREEN": {
        "description": "<p>Green. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_GREEN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_MATTE_BLACK": {
        "description": "<p>Matte Black. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_MATTE_BLACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_ORANGE": {
        "description": "<p>Orange. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_ORANGE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_PINK": {
        "description": "<p>Pink. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_PINK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_RED": {
        "description": "<p>Red. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_RED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_STAINLESS_STEEL": {
        "description": "<p>Stainless Steel. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_STAINLESS_STEEL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_BLACK": {
        "description": "<p>Time Black. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_BLACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_RED": {
        "description": "<p>Time Red. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_RED", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_ROUND_BLACK_14": {
        "description": "<p>Time Round 14mm lug size, Black. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_ROUND_BLACK_14", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_ROUND_BLACK_20": {
        "description": "<p>Time Round 20mm lug size, Black. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_ROUND_BLACK_20", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_ROUND_ROSE_GOLD_14": {
        "description": "<p>Time Round 14mm lug size, Rose Gold. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_ROUND_ROSE_GOLD_14", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_ROUND_SILVER_14": {
        "description": "<p>Time Round 14mm lug size, Silver. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_ROUND_SILVER_14", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_ROUND_SILVER_20": {
        "description": "<p>Time Round 20mm lug size, Silver. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_ROUND_SILVER_20", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_STEEL_BLACK": {
        "description": "<p>Time Steel Black. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_STEEL_BLACK", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_STEEL_GOLD": {
        "description": "<p>Time Steel Gold. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_STEEL_GOLD", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_STEEL_SILVER": {
        "description": "<p>Time Steel Silver. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_STEEL_SILVER", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_TIME_WHITE": {
        "description": "<p>Time White. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_TIME_WHITE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_UNKNOWN": {
        "description": "<p>Unknown color. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_UNKNOWN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR_WHITE": {
        "description": "<p>White. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR_WHITE", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_COLOR__MAX": {
        "description": "", 
        "kind": "enum", 
        "name": "WATCH_INFO_COLOR__MAX", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_PEBBLE_ORIGINAL": {
        "description": "<p>Original Pebble. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_PEBBLE_ORIGINAL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_PEBBLE_STEEL": {
        "description": "<p>Pebble Steel. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_PEBBLE_STEEL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_PEBBLE_TIME": {
        "description": "<p>Pebble Time. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_PEBBLE_TIME", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_PEBBLE_TIME_ROUND_14": {
        "description": "<p>Pebble Time Round, 14mm lug size. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_PEBBLE_TIME_ROUND_14", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_PEBBLE_TIME_ROUND_20": {
        "description": "<p>Pebble Time Round, 20mm lug size. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_PEBBLE_TIME_ROUND_20", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_PEBBLE_TIME_STEEL": {
        "description": "<p>Pebble Time Steel. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_PEBBLE_TIME_STEEL", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL_UNKNOWN": {
        "description": "<p>Unknown model. </p>", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL_UNKNOWN", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WATCH_INFO_MODEL__MAX": {
        "description": "", 
        "kind": "enum", 
        "name": "WATCH_INFO_MODEL__MAX", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WEDNESDAY": {
        "description": "<p>Wednesday. </p>", 
        "kind": "enum", 
        "name": "WEDNESDAY", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "WakeupHandler": {
        "description": "<p>The type of function which can be called when a wakeup event occurs. The arguments will be the id of the wakeup event that occurred, as well as the scheduled cookie provided to <code>wakeup_schedule</code>. </p>", 
        "kind": "typedef", 
        "name": "WakeupHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "WakeupId": {
        "description": "<p>WakeupId is an identifier for a wakeup event. </p>", 
        "kind": "typedef", 
        "name": "WakeupId", 
        "params": [], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "Window": {
        "description": "", 
        "kind": "typedef", 
        "name": "Window", 
        "params": [], 
        "return_desc": null, 
        "returns": "struct Window", 
        "warning": null
    }, 
    "WindowHandler": {
        "description": "<p>Function signature for a handler that deals with transition events of a window. </p>", 
        "kind": "typedef", 
        "name": "WindowHandler", 
        "params": [], 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null
    }, 
    "YEAR_UNIT": {
        "description": "<p>Flag to represent the \"years\" time unit. </p>", 
        "kind": "enum", 
        "name": "YEAR_UNIT", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "__FILE_NAME__": {
        "description": "", 
        "kind": "def", 
        "name": "__FILE_NAME__", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "accel_data_service_subscribe": {
        "description": "<p>Subscribe to the accelerometer data event service. Once subscribed, the handler gets called every time there are new accelerometer samples available. </p>", 
        "kind": "fn", 
        "name": "accel_data_service_subscribe", 
        "params": [
            {
                "description": "<p>the number of samples to buffer, between 0 and 25. </p>", 
                "name": "samples_per_update", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>A callback to be executed on accelerometer data events </p>", 
                "name": "handler", 
                "type": "AccelDataHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Cannot use <code>accel_service_peek()</code> when subscribed to accelerometer data events. </p>"
    }, 
    "accel_data_service_unsubscribe": {
        "description": "<p>Unsubscribe from the accelerometer data event service. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "accel_data_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "accel_raw_data_service_subscribe": {
        "description": "<p>Subscribe to the accelerometer raw data event service. Once subscribed, the handler gets called every time there are new accelerometer samples available. </p>", 
        "kind": "fn", 
        "name": "accel_raw_data_service_subscribe", 
        "params": [
            {
                "description": "<p>the number of samples to buffer, between 0 and 25. </p>", 
                "name": "samples_per_update", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>A callback to be executed on accelerometer data events </p>", 
                "name": "handler", 
                "type": "AccelRawDataHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Cannot use <code>accel_service_peek()</code> when subscribed to accelerometer data events. </p>"
    }, 
    "accel_service_peek": {
        "description": "<p><p>-2 if subscribed to accelerometer events. </p>\n</p>", 
        "kind": "fn", 
        "name": "accel_service_peek", 
        "params": [
            {
                "description": "<p>a pointer to a pre-allocated AccelData item </p>", 
                "name": "data", 
                "type": "AccelData *"
            }
        ], 
        "return_desc": "<p>-1 if the accel is not running </p>", 
        "returns": "int", 
        "warning": "<p>Cannot be used when subscribed to accelerometer data events. </p>"
    }, 
    "accel_service_set_samples_per_update": {
        "description": "<p>Change the number of samples buffered between each accelerometer data event. </p>", 
        "kind": "fn", 
        "name": "accel_service_set_samples_per_update", 
        "params": [
            {
                "description": "<p>the number of samples to buffer, between 0 and 25. </p>", 
                "name": "num_samples", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "int", 
        "warning": null
    }, 
    "accel_service_set_sampling_rate": {
        "description": "<p>Change the accelerometer sampling rate. </p>", 
        "kind": "fn", 
        "name": "accel_service_set_sampling_rate", 
        "params": [
            {
                "description": "<p>The sampling rate in Hz (10Hz, 25Hz, 50Hz, and 100Hz possible) </p>", 
                "name": "rate", 
                "type": "AccelSamplingRate"
            }
        ], 
        "return_desc": null, 
        "returns": "int", 
        "warning": null
    }, 
    "accel_tap_service_subscribe": {
        "description": "<p>Subscribe to the accelerometer tap event service. Once subscribed, the handler gets called on every tap event emitted by the accelerometer. </p>", 
        "kind": "fn", 
        "name": "accel_tap_service_subscribe", 
        "params": [
            {
                "description": "<p>A callback to be executed on tap event </p>", 
                "name": "handler", 
                "type": "AccelTapHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "accel_tap_service_unsubscribe": {
        "description": "<p>Unsubscribe from the accelerometer tap event service. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "accel_tap_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_add_to_window": {
        "description": "<p>Adds the action bar's layer on top of the window's root layer. It also adjusts the layout of the action bar to match the geometry of the window it gets added to. Lastly, it calls <code>window_set_click_config_provider_with_context()</code> on the window to set it up to work with the internal callback and raw click handlers of the action bar, to enable the highlighting of the section of the action bar when the user presses a button. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_add_to_window", 
        "params": [
            {
                "description": "<p>The action bar to associate with the window </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The window with which the action bar is to be associated </p>", 
                "name": "window", 
                "type": "struct Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>After this call, do not use <code>window_set_click_config_provider_with_context()</code> with the window that the action bar has been added to (this would de-associate the action bar's click config provider and context). Instead use <code>action_bar_layer_set_click_config_provider()</code> and <code>action_bar_layer_set_context()</code> to register the click configuration provider to configure the buttons actions. </p>"
    }, 
    "action_bar_layer_clear_icon": {
        "description": "<p>Convenience function to clear out an existing icon. All it does is call <code>action_bar_layer_set_icon</code>(<code>action_bar</code>, <code>button_id</code>, NULL) </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_clear_icon", 
        "params": [
            {
                "description": "<p>The action bar for which to clear an icon </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The identifier of the button for which to clear the icon </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_create": {
        "description": "<p><ul><li><p>Background color: GColorBlack</p></li><li><p>No click configuration provider (NULL)</p></li><li><p>No icons</p></li><li><p>Not added to / associated with any window, thus not catching any button input yet. </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "action_bar_layer_create", 
        "params": [], 
        "return_desc": "<p>A pointer to the ActionBarLayer. NULL if the ActionBarLayer could not be created </p>", 
        "returns": "ActionBarLayer *", 
        "warning": null
    }, 
    "action_bar_layer_destroy": {
        "description": "<p>Destroys a ActionBarLayer previously created by <code>action_bar_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "action_bar_layer", 
                "type": "ActionBarLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the action bar layer, which is the parent for the sub- layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the ActionBarLayer for which to get the \"root\" Layer </p>", 
                "name": "action_bar_layer", 
                "type": "ActionBarLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the action bar layer. </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "action_bar_layer_remove_from_window": {
        "description": "<p>Removes the action bar from the window and unconfigures the window's click configuration provider. NULL is set as the window's new click config provider and also as its callback context. If it has not been added to a window before, this function is a no-op. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_remove_from_window", 
        "params": [
            {
                "description": "<p>The action bar to de-associate from its current window </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_set_background_color": {
        "description": "<p>Sets the background color of the action bar. Defaults to GColorBlack. The action bar's layer is automatically marked dirty. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_set_background_color", 
        "params": [
            {
                "description": "<p>The action bar of which to set the background color </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The new background color </p>", 
                "name": "background_color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_set_click_config_provider": {
        "description": "<p>Sets the click configuration provider callback of the action bar. In this callback your application can associate handlers to the different types of click events for each of the buttons, see Clicks. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_set_click_config_provider", 
        "params": [
            {
                "description": "<p>The action bar for which to assign a new click configuration provider </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The new click configuration provider </p>", 
                "name": "click_config_provider", 
                "type": "ClickConfigProvider"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the action bar had already been added to a window and the window is currently on-screen, the click configuration provider will be called before this function returns. Otherwise, it will be called by the system when the window becomes on-screen. </p>"
    }, 
    "action_bar_layer_set_context": {
        "description": "<p>Sets the context parameter, which will be passed in to ClickHandler callbacks and the ClickConfigProvider callback of the action bar. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_set_context", 
        "params": [
            {
                "description": "<p>The action bar for which to assign the new context </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The new context </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>By default, a pointer to the action bar itself is passed in, if the context has not been set or if it has been set to NULL. </p>"
    }, 
    "action_bar_layer_set_icon": {
        "description": "<p>Sets an action bar icon onto one of the 3 slots as identified by <code>button_id</code>. Only <code>BUTTON_ID_UP</code>, <code>BUTTON_ID_SELECT</code> and <code>BUTTON_ID_DOWN</code> can be used. The transition will not be animated. Whenever an icon is set, the click configuration provider will be called, to give the application the opportunity to reconfigure the button interaction. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_set_icon", 
        "params": [
            {
                "description": "<p>The action bar for which to set the new icon </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The identifier of the button for which to set the icon </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>Pointer to the GBitmap icon </p>", 
                "name": "icon", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_set_icon_animated": {
        "description": "<p>Sets an action bar icon onto one of the 3 slots as identified by <code>button_id</code>. Only <code>BUTTON_ID_UP</code>, <code>BUTTON_ID_SELECT</code> and <code>BUTTON_ID_DOWN</code> can be used. Optionally, if animated is true, the transition will be animated. Whenever an icon is set, the click configuration provider will be called, to give the application the opportunity to reconfigure the button interaction. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_set_icon_animated", 
        "params": [
            {
                "description": "<p>The action bar for which to set the new icon </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The identifier of the button for which to set the icon </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>Pointer to the GBitmap icon </p>", 
                "name": "icon", 
                "type": "const GBitmap *"
            }, 
            {
                "description": "<p>True = animate the transition, False = do not animate the transition </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_bar_layer_set_icon_press_animation": {
        "description": "<p>Sets the animation to use while a button is pressed on an ActionBarLayer. By default we use ActionBarLayerIconPressAnimationMoveLeft. </p>", 
        "kind": "fn", 
        "name": "action_bar_layer_set_icon_press_animation", 
        "params": [
            {
                "description": "<p>The action bar for which to set the press animation </p>", 
                "name": "action_bar", 
                "type": "ActionBarLayer *"
            }, 
            {
                "description": "<p>The button for which to set the press animation </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>The animation to use. </p>", 
                "name": "animation", 
                "type": "ActionBarLayerIconPressAnimation"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_menu_close": {
        "description": "<p>Close the ActionMenu, whether it is frozen or not. </p>", 
        "kind": "fn", 
        "name": "action_menu_close", 
        "params": [
            {
                "description": "<p>the ActionMenu to close </p>", 
                "name": "action_menu", 
                "type": "ActionMenu *"
            }, 
            {
                "description": "<p>whether or not show a close animation </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>this API can be used on a frozen ActionMenu once the data required to build the result window has been received and the result window has been set </p>"
    }, 
    "action_menu_freeze": {
        "description": "<p>Freeze the ActionMenu. The ActionMenu will no longer respond to user input. </p>", 
        "kind": "fn", 
        "name": "action_menu_freeze", 
        "params": [
            {
                "description": "<p>the ActionMenu </p>", 
                "name": "action_menu", 
                "type": "ActionMenu *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>this API should be used when waiting for asynchronous operation. </p>"
    }, 
    "action_menu_get_context": {
        "description": "<p>Get the context pointer this ActionMenu was created with. </p>", 
        "kind": "fn", 
        "name": "action_menu_get_context", 
        "params": [
            {
                "description": "<p>A pointer to an ActionMenu </p>", 
                "name": "action_menu", 
                "type": "ActionMenu *"
            }
        ], 
        "return_desc": "<p>the context pointer initially provided in the ActionMenuConfig. NULL if none exists. </p>", 
        "returns": "void *", 
        "warning": null
    }, 
    "action_menu_get_root_level": {
        "description": "<p>Get the root level of an ActionMenu. </p>", 
        "kind": "fn", 
        "name": "action_menu_get_root_level", 
        "params": [
            {
                "description": "<p>the ActionMenu you want to know about </p>", 
                "name": "action_menu", 
                "type": "ActionMenu *"
            }
        ], 
        "return_desc": "<p>a pointer to the root ActionMenuLevel for the given ActionMenu, NULL if invalid </p>", 
        "returns": "ActionMenuLevel *", 
        "warning": null
    }, 
    "action_menu_hierarchy_destroy": {
        "description": "<p><p>Hierarchy is traversed in post-order. In other words, all children items are freed before their parent is freed. </p>\n</p>", 
        "kind": "fn", 
        "name": "action_menu_hierarchy_destroy", 
        "params": [
            {
                "description": "<p>the root level in the hierarchy </p>", 
                "name": "root", 
                "type": "const ActionMenuLevel *"
            }, 
            {
                "description": "<p>a callback to call on every ActionMenuItem in every level </p>", 
                "name": "each_cb", 
                "type": "ActionMenuEachItemCb"
            }, 
            {
                "description": "<p>a context pointer to pass to <code>each_cb</code> on invocation </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Typical implementations will cleanup memory allocated for the item label/data associated with each item in the callback </p>"
    }, 
    "action_menu_item_get_action_data": {
        "description": "<p>Getter for the <code>action_data</code> pointer of a given ActionMenuitem. </p>", 
        "kind": "fn", 
        "name": "action_menu_item_get_action_data", 
        "params": [
            {
                "description": "<p>the ActionMenuItem of interest </p>", 
                "name": "item", 
                "type": "const ActionMenuItem *"
            }
        ], 
        "return_desc": "<p>a pointer to the data. NULL if invalid. </p>", 
        "returns": "void *", 
        "warning": null
    }, 
    "action_menu_item_get_label": {
        "description": "<p>Getter for the label of a given ActionMenuItem. </p>", 
        "kind": "fn", 
        "name": "action_menu_item_get_label", 
        "params": [
            {
                "description": "<p>the ActionMenuItem of interest </p>", 
                "name": "item", 
                "type": "const ActionMenuItem *"
            }
        ], 
        "return_desc": "<p>a pointer to the string label. NULL if invalid. </p>", 
        "returns": "char *", 
        "warning": null
    }, 
    "action_menu_level_add_action": {
        "description": "<p>Add an action to an ActionLevel. </p>", 
        "kind": "fn", 
        "name": "action_menu_level_add_action", 
        "params": [
            {
                "description": "<p>the level to add the action to </p>", 
                "name": "level", 
                "type": "ActionMenuLevel *"
            }, 
            {
                "description": "<p>the text to display for the action in the menu </p>", 
                "name": "label", 
                "type": "const char *"
            }, 
            {
                "description": "<p>the callback that will be triggered when this action is actuated </p>", 
                "name": "cb", 
                "type": "ActionMenuPerformActionCb"
            }, 
            {
                "description": "<p>data to pass to the callback for this action </p>", 
                "name": "action_data", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>a reference to the new ActionMenuItem on success, NULL if the level is full </p>", 
        "returns": "ActionMenuItem *", 
        "warning": null
    }, 
    "action_menu_level_add_child": {
        "description": "<p>Add a child to this ActionMenuLevel. </p>", 
        "kind": "fn", 
        "name": "action_menu_level_add_child", 
        "params": [
            {
                "description": "<p>the parent level </p>", 
                "name": "level", 
                "type": "ActionMenuLevel *"
            }, 
            {
                "description": "<p>the child level </p>", 
                "name": "child", 
                "type": "ActionMenuLevel *"
            }, 
            {
                "description": "<p>the text to display in the action menu for this level </p>", 
                "name": "label", 
                "type": "const char *"
            }
        ], 
        "return_desc": "<p>a reference to the new ActionMenuItem on success, NULL if the level is full </p>", 
        "returns": "ActionMenuItem *", 
        "warning": null
    }, 
    "action_menu_level_create": {
        "description": "<p><p>by default, levels are using ActionMenuLevelDisplayModeWide. Use <code>action_menu_level_set_display_mode</code> to change it. </p>\n\n</p>", 
        "kind": "fn", 
        "name": "action_menu_level_create", 
        "params": [
            {
                "description": "<p>the max number of items that will be displayed at that level </p>", 
                "name": "max_items", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "ActionMenuLevel *", 
        "warning": "<p>levels are freed alongside the whole hierarchy so no destroy API is provided. </p>"
    }, 
    "action_menu_level_set_display_mode": {
        "description": "<p>Set the action menu display mode. </p>", 
        "kind": "fn", 
        "name": "action_menu_level_set_display_mode", 
        "params": [
            {
                "description": "<p>The ActionMenuLevel whose display mode you want to change </p>", 
                "name": "level", 
                "type": "ActionMenuLevel *"
            }, 
            {
                "description": "<p>The display mode for the action menu (3 vs. 1 item per row) </p>", 
                "name": "display_mode", 
                "type": "ActionMenuLevelDisplayMode"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "action_menu_open": {
        "description": "<p>Open a new ActionMenu. The ActionMenu acts much like a window. It fills the whole screen and handles clicks. </p>", 
        "kind": "fn", 
        "name": "action_menu_open", 
        "params": [
            {
                "description": "<p>the configuration info for this new ActionMenu </p>", 
                "name": "config", 
                "type": "ActionMenuConfig *"
            }
        ], 
        "return_desc": "<p>the new ActionMenu </p>", 
        "returns": "ActionMenu *", 
        "warning": null
    }, 
    "action_menu_set_result_window": {
        "description": "<p>Set the result window for an ActionMenu. The result window will be shown when the ActionMenu closes. </p>", 
        "kind": "fn", 
        "name": "action_menu_set_result_window", 
        "params": [
            {
                "description": "<p>the ActionMenu </p>", 
                "name": "action_menu", 
                "type": "ActionMenu *"
            }, 
            {
                "description": "<p>the window to insert, pass NULL to remove the current result window </p>", 
                "name": "result_window", 
                "type": "Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>repeated call will result in only the last call to be applied, i.e. only one result window is ever set </p>"
    }, 
    "action_menu_unfreeze": {
        "description": "<p>Unfreeze the ActionMenu previously frozen with <code>action_menu_freeze</code>. </p>", 
        "kind": "fn", 
        "name": "action_menu_unfreeze", 
        "params": [
            {
                "description": "<p>the ActionMenu to unfreeze </p>", 
                "name": "action_menu", 
                "type": "ActionMenu *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "animation_clone": {
        "description": "", 
        "kind": "fn", 
        "name": "animation_clone", 
        "params": [
            {
                "description": null, 
                "name": "from", 
                "type": "Animation *"
            }
        ], 
        "return_desc": null, 
        "returns": "Animation *", 
        "warning": null
    }, 
    "animation_create": {
        "description": "<p><ul><li><p>Duration: 250ms,</p></li><li><p>Curve: AnimationCurveEaseInOut (ease-in-out),</p></li><li><p>Delay: 0ms,</p></li><li><p>Handlers: {NULL, NULL} (none),</p></li><li><p>Context: NULL (none),</p></li><li><p>Implementation: NULL (no implementation),</p></li><li><p>Scheduled: no </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "animation_create", 
        "params": [], 
        "return_desc": "<p>A pointer to the animation. NULL if the animation could not be created </p>", 
        "returns": "Animation *", 
        "warning": null
    }, 
    "animation_destroy": {
        "description": "<p>Destroys an Animation previously created by <code>animation_create</code>. </p>", 
        "kind": "fn", 
        "name": "animation_destroy", 
        "params": [
            {
                "description": null, 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "animation_get_context": {
        "description": "<p>Gets the application-specific callback context of the animation. This void pointer is passed as an argument when the animation system calls AnimationHandlers callbacks. The context pointer can be set to point to any application specific data using <code>animation_set_handlers()</code>. </p>", 
        "kind": "fn", 
        "name": "animation_get_context", 
        "params": [
            {
                "description": "<p>The animation. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null
    }, 
    "animation_get_curve": {
        "description": "<p>Gets the animation curve for the animation. </p>", 
        "kind": "fn", 
        "name": "animation_get_curve", 
        "params": [
            {
                "description": "<p>The animation for which to get the curve. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>The type of curve. </p>", 
        "returns": "AnimationCurve", 
        "warning": null
    }, 
    "animation_get_custom_curve": {
        "description": "<p>Gets the custom animation curve function for the animation. </p>", 
        "kind": "fn", 
        "name": "animation_get_custom_curve", 
        "params": [
            {
                "description": "<p>The animation for which to get the curve. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>The custom animation curve function for the given animation. NULL if not set. </p>", 
        "returns": "AnimationCurveFunction", 
        "warning": null
    }, 
    "animation_get_delay": {
        "description": "<p>Get the delay of an animation in milliseconds. </p>", 
        "kind": "fn", 
        "name": "animation_get_delay", 
        "params": [
            {
                "description": "<p>The animation for which to get the setting </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>the delay in milliseconds </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "animation_get_duration": {
        "description": "<p>Get the static duration of an animation from start to end (ignoring how much has already played, if any). </p>", 
        "kind": "fn", 
        "name": "animation_get_duration", 
        "params": [
            {
                "description": "<p>The animation for which to get the duration </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>if true, include the delay time </p>", 
                "name": "include_delay", 
                "type": "bool"
            }, 
            {
                "description": "<p>if true, incorporate the <code>play_count</code> </p>", 
                "name": "include_play_count", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>the duration, in milliseconds. This includes any optional delay a set using <code>animation_set_delay</code>. </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "animation_get_elapsed": {
        "description": "<p>Get the current location in the animation. </p>", 
        "kind": "fn", 
        "name": "animation_get_elapsed", 
        "params": [
            {
                "description": "<p>The animation for which to fetch the elapsed. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>pointer to variable that will contain the elapsed time in milliseconds </p>", 
                "name": "elapsed_ms", 
                "type": "int32_t *"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>The animation must be scheduled to get the elapsed time. If it is not schedule, this method will return false. </p>"
    }, 
    "animation_get_implementation": {
        "description": "<p>Gets the implementation of the custom animation. </p>", 
        "kind": "fn", 
        "name": "animation_get_implementation", 
        "params": [
            {
                "description": "<p>The animation for which to get the implementation. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>NULL if animation implementation has not been setup. </p>", 
        "returns": "const AnimationImplementation *", 
        "warning": null
    }, 
    "animation_get_play_count": {
        "description": "<p>Get the play count of an animation. </p>", 
        "kind": "fn", 
        "name": "animation_get_play_count", 
        "params": [
            {
                "description": "<p>The animation for which to get the setting </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>the play count </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "animation_get_reverse": {
        "description": "<p>Get the reverse setting of an animation. </p>", 
        "kind": "fn", 
        "name": "animation_get_reverse", 
        "params": [
            {
                "description": "<p>The animation for which to get the setting </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>the reverse setting </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "animation_is_scheduled": {
        "description": "<p>\n\n</p>", 
        "kind": "fn", 
        "name": "animation_is_scheduled", 
        "params": [
            {
                "description": "<p>The animation for which to get its scheduled state. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>True if the animation was scheduled, or false if it was not. </p>", 
        "returns": "bool", 
        "warning": "<p>An animation will be scheduled when it is running and not finished yet. An animation that has finished is automatically unscheduled. For convenience, passing in a NULL animation argument will simply return false </p>"
    }, 
    "animation_schedule": {
        "description": "<p>If the animation's implementation has a .setup callback it will get called before this function returns.</p><p>", 
        "kind": "fn", 
        "name": "animation_schedule", 
        "params": [
            {
                "description": "<p>The animation to schedule. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>If the animation was already scheduled, it will first unschedule it and then re-schedule it again. Note that in that case, the animation's .stopped handler, the implementation's .teardown and .setup will get called, due to the unscheduling and scheduling. </p>"
    }, 
    "animation_sequence_create": {
        "description": "<p>Create a new sequence animation from a list of 2 or more other animations. The returned animation owns the animations that were provided as arguments and no further write operations on those handles are allowed. The variable length argument list must be terminated with a NULL ptr. </p>", 
        "kind": "fn", 
        "name": "animation_sequence_create", 
        "params": [
            {
                "description": "<p>the first required component animation </p>", 
                "name": "animation_a", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>the second required component animation </p>", 
                "name": "animation_b", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>either the third component, or NULL if only adding 2 components </p>", 
                "name": "animation_c", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>The newly created sequence animation </p>", 
        "returns": "Animation *", 
        "warning": "<p>the maximum number of animations that can be supplied to this method is 20 </p>"
    }, 
    "animation_sequence_create_from_array": {
        "description": "<p>An alternate form of <code>animation_sequence_create()</code> that accepts an array of other animations. </p>", 
        "kind": "fn", 
        "name": "animation_sequence_create_from_array", 
        "params": [
            {
                "description": "<p>an array of component animations to include </p>", 
                "name": "animation_array", 
                "type": "Animation **"
            }, 
            {
                "description": "<p>the number of elements in the <code>animation_array</code> </p>", 
                "name": "array_len", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>The newly created sequence animation </p>", 
        "returns": "Animation *", 
        "warning": "<p>the maximum number of elements allowed in <code>animation_array</code> is 256 </p>"
    }, 
    "animation_set_curve": {
        "description": "<p>Sets the animation curve for the animation. </p>", 
        "kind": "fn", 
        "name": "animation_set_curve", 
        "params": [
            {
                "description": "<p>The animation for which to set the curve. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>The type of curve. </p>", 
                "name": "curve", 
                "type": "AnimationCurve"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_custom_curve": {
        "description": "<p>Sets a custom animation curve function. </p>", 
        "kind": "fn", 
        "name": "animation_set_custom_curve", 
        "params": [
            {
                "description": "<p>The animation for which to set the curve. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>The custom animation curve function. </p>", 
                "name": "curve_function", 
                "type": "AnimationCurveFunction"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_delay": {
        "description": "<p>Sets an optional delay for the animation. </p>", 
        "kind": "fn", 
        "name": "animation_set_delay", 
        "params": [
            {
                "description": "<p>The animation for which to set the delay. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>The delay in milliseconds that the animation system should wait from the moment the animation is scheduled to starting the animation. </p>", 
                "name": "delay_ms", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_duration": {
        "description": "<p>Sets the time in milliseconds that an animation takes from start to finish. </p>", 
        "kind": "fn", 
        "name": "animation_set_duration", 
        "params": [
            {
                "description": "<p>The animation for which to set the duration. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>The duration in milliseconds of the animation. This excludes any optional delay as set using <code>animation_set_delay()</code>. </p>", 
                "name": "duration_ms", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_elapsed": {
        "description": "<p>Seek to a specific location in the animation. Only forward seeking is allowed. Returns true if successful, false if the passed in seek location is invalid. </p>", 
        "kind": "fn", 
        "name": "animation_set_elapsed", 
        "params": [
            {
                "description": "<p>the animation for which to set the elapsed. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>the new elapsed time in milliseconds </p>", 
                "name": "elapsed_ms", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>true if successful, false if the requested elapsed is invalid. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "animation_set_handlers": {
        "description": "<p>Sets the callbacks for the animation. Often an application needs to run code at the start or at the end of an animation. Using this function is possible to register callback functions with an animation, that will get called at the start and end of the animation. </p>", 
        "kind": "fn", 
        "name": "animation_set_handlers", 
        "params": [
            {
                "description": "<p>The animation for which to set up the callbacks. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>The callbacks. </p>", 
                "name": "callbacks", 
                "type": "AnimationHandlers"
            }, 
            {
                "description": "<p>A pointer to application specific data, that will be passed as an argument by the animation subsystem when a callback is called. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_implementation": {
        "description": "<p>Sets the implementation of the custom animation. When implementing custom animations, use this function to specify what functions need to be called to for the setup, frame update and teardown of the animation. </p>", 
        "kind": "fn", 
        "name": "animation_set_implementation", 
        "params": [
            {
                "description": "<p>The animation for which to set the implementation. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>The structure with function pointers to the implementation of the setup, update and teardown functions. </p>", 
                "name": "implementation", 
                "type": "const AnimationImplementation *"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_play_count": {
        "description": "<p>Set an animation to play N times. The default is 1. </p>", 
        "kind": "fn", 
        "name": "animation_set_play_count", 
        "params": [
            {
                "description": "<p>the animation to set the play count of </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>number of times to play this animation. Set to <code>ANIMATION_PLAY_COUNT_INFINITE</code> to make an animation repeat indefinitely. </p>", 
                "name": "play_count", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_set_reverse": {
        "description": "<p>Set an animation to run in reverse (or forward) </p>", 
        "kind": "fn", 
        "name": "animation_set_reverse", 
        "params": [
            {
                "description": "<p>the animation to operate on </p>", 
                "name": "animation", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>set to true to run in reverse, false to run forward </p>", 
                "name": "reverse", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>Trying to set an attribute when an animation is immutable will return false (failure). An animation is immutable once it has been added to a sequence or spawn animation or has been scheduled. </p>"
    }, 
    "animation_spawn_create": {
        "description": "<p>Create a new spawn animation from a list of 2 or more other animations. The returned animation owns the animations that were provided as arguments and no further write operations on those handles are allowed. The variable length argument list must be terminated with a NULL ptr. </p>", 
        "kind": "fn", 
        "name": "animation_spawn_create", 
        "params": [
            {
                "description": "<p>the first required component animation </p>", 
                "name": "animation_a", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>the second required component animation </p>", 
                "name": "animation_b", 
                "type": "Animation *"
            }, 
            {
                "description": "<p>either the third component, or NULL if only adding 2 components </p>", 
                "name": "animation_c", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>The newly created spawn animation or NULL on failure </p>", 
        "returns": "Animation *", 
        "warning": "<p>the maximum number of animations that can be supplied to this method is 20 </p>"
    }, 
    "animation_spawn_create_from_array": {
        "description": "<p>An alternate form of <code>animation_spawn_create()</code> that accepts an array of other animations. </p>", 
        "kind": "fn", 
        "name": "animation_spawn_create_from_array", 
        "params": [
            {
                "description": "<p>an array of component animations to include </p>", 
                "name": "animation_array", 
                "type": "Animation **"
            }, 
            {
                "description": "<p>the number of elements in the <code>animation_array</code> </p>", 
                "name": "array_len", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>The newly created spawn animation or NULL on failure </p>", 
        "returns": "Animation *", 
        "warning": "<p>the maximum number of elements allowed in <code>animation_array</code> is 256 </p>"
    }, 
    "animation_unschedule": {
        "description": "<p><p>If the animation is not scheduled or NULL, calling this routine is effectively a no-op </p>", 
        "kind": "fn", 
        "name": "animation_unschedule", 
        "params": [
            {
                "description": "<p>The animation to unschedule. </p>", 
                "name": "animation", 
                "type": "Animation *"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure </p>", 
        "returns": "bool", 
        "warning": "<p>If the animation was not yet finished, unscheduling it will cause its .stopped handler to get called, with the \"finished\" argument set to false. </p>"
    }, 
    "animation_unschedule_all": {
        "description": "<p>Unschedules all animations of the application. </p>", 
        "kind": "fn", 
        "name": "animation_unschedule_all", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_comm_get_sniff_interval": {
        "description": "<p>Get the Bluetooth module's sniff interval. </p>", 
        "kind": "fn", 
        "name": "app_comm_get_sniff_interval", 
        "params": [], 
        "return_desc": "<p>The SniffInterval value corresponding to the current interval </p>", 
        "returns": "SniffInterval", 
        "warning": null
    }, 
    "app_comm_set_sniff_interval": {
        "description": "<p>Set the Bluetooth module's sniff interval. The sniff interval will be restored to normal by the OS after the app's de-init handler is called. Set the sniff interval to normal whenever possible. </p>", 
        "kind": "fn", 
        "name": "app_comm_set_sniff_interval", 
        "params": [
            {
                "description": null, 
                "name": "interval", 
                "type": "const SniffInterval"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_event_loop": {
        "description": "<p>The event loop for C apps, to be used in app's main(). Will block until the app is ready to exit. </p>", 
        "kind": "fn", 
        "name": "app_event_loop", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_focus_service_subscribe": {
        "description": "<p><p>Out focus events are triggered when a modal window is about to open and cover the app. </p>\n<p>In focus events are triggered when a modal window which is covering the app is about to close. </p>", 
        "kind": "fn", 
        "name": "app_focus_service_subscribe", 
        "params": [
            {
                "description": "<p>A callback to be called on will-focus events. </p>", 
                "name": "handler", 
                "type": "AppFocusHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Calling this function is equivalent to <code>app_focus_service_subscribe_handlers</code>((AppFocusHandlers){\n.<code>will_focus</code>=handler,\n});\n </p>"
    }, 
    "app_focus_service_subscribe_handlers": {
        "description": "<p>Subscribe to the focus event service. Once subscribed, the handlers get called every time the app gains or loses focus. </p>", 
        "kind": "fn", 
        "name": "app_focus_service_subscribe_handlers", 
        "params": [
            {
                "description": null, 
                "name": "handlers", 
                "type": "AppFocusHandlers"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_focus_service_unsubscribe": {
        "description": "<p>Unsubscribe from the focus event service. Once unsubscribed, the previously registered handlers will no longer be called. </p>", 
        "kind": "fn", 
        "name": "app_focus_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_glance_add_slice": {
        "description": "<p>Add a slice to the app's glance. This function will only succeed if called with a valid AppGlanceReloadSession that is provided in an AppGlanceReloadCallback. </p>", 
        "kind": "fn", 
        "name": "app_glance_add_slice", 
        "params": [
            {
                "description": "<p>The session variable provided in an AppGlanceReloadCallback </p>", 
                "name": "session", 
                "type": "AppGlanceReloadSession *"
            }, 
            {
                "description": "<p>The slice to add to the app's glance </p>", 
                "name": "slice", 
                "type": "AppGlanceSlice"
            }
        ], 
        "return_desc": "<p>The result of trying to add the slice to the app's glance </p>", 
        "returns": "AppGlanceResult", 
        "warning": null
    }, 
    "app_glance_reload": {
        "description": "<p>Clear any existing slices in the app's glance and trigger a reload via the provided callback. </p>", 
        "kind": "fn", 
        "name": "app_glance_reload", 
        "params": [
            {
                "description": "<p>A function that will be called to add new slices to the app's glance; even if the provided callback is NULL, any existing slices will still be cleared from the app's glance </p>", 
                "name": "callback", 
                "type": "AppGlanceReloadCallback"
            }, 
            {
                "description": "<p>User-provided context that will be passed to the callback </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_log": {
        "description": "<p>Log an app message. </p>", 
        "kind": "fn", 
        "name": "app_log", 
        "params": [
            {
                "description": "<p></p>", 
                "name": "log_level", 
                "type": "uint8_t"
            }, 
            {
                "description": "<p>The source file where the log originates from </p>", 
                "name": "src_filename", 
                "type": "const char *"
            }, 
            {
                "description": "<p>The line number in the source file where the log originates from </p>", 
                "name": "src_line_number", 
                "type": "int"
            }, 
            {
                "description": "<p>A C formatting string </p>", 
                "name": "fmt", 
                "type": "const char *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_message_deregister_callbacks": {
        "description": "<p>Deregisters all callbacks and their context. </p>", 
        "kind": "fn", 
        "name": "app_message_deregister_callbacks", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_message_get_context": {
        "description": "<p>Gets the context that will be passed to all AppMessage callbacks. </p>", 
        "kind": "fn", 
        "name": "app_message_get_context", 
        "params": [], 
        "return_desc": "<p>The current context on record. </p>", 
        "returns": "void *", 
        "warning": null
    }, 
    "app_message_inbox_size_maximum": {
        "description": "<p>Programatically determine the inbox size maximum in the current configuration. </p>", 
        "kind": "fn", 
        "name": "app_message_inbox_size_maximum", 
        "params": [], 
        "return_desc": "<p>The inbox size maximum on this firmware.</p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "app_message_open": {
        "description": "<p>Use <code>dict_calc_buffer_size_from_tuplets()</code> or <code>dict_calc_buffer_size()</code> to estimate the size you need.</p><p>", 
        "kind": "fn", 
        "name": "app_message_open", 
        "params": [
            {
                "description": "<p>The required size for the Inbox buffer </p>", 
                "name": "size_inbound", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The required size for the Outbox buffer</p>", 
                "name": "size_outbound", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>A result code such as <code>APP_MSG_OK</code> or <code>APP_MSG_OUT_OF_MEMORY</code>.</p>", 
        "returns": "AppMessageResult", 
        "warning": "<p>It is recommended that if the Inbox will be used, that at least the Inbox callbacks should be registered before this call. Otherwise it is possible for an Inbox message to be NACK'ed without being seen by the application. </p>"
    }, 
    "app_message_outbox_begin": {
        "description": "<p>Begin writing to the Outbox's Dictionary buffer. </p>", 
        "kind": "fn", 
        "name": "app_message_outbox_begin", 
        "params": [
            {
                "description": "<p>Location to write the DictionaryIterator pointer. This will be NULL on failure.</p>", 
                "name": "iterator", 
                "type": "DictionaryIterator **"
            }
        ], 
        "return_desc": "<p>A result code, including but not limited to <code>APP_MSG_OK</code>, <code>APP_MSG_INVALID_ARGS</code> or <code>APP_MSG_BUSY</code>.</p>", 
        "returns": "AppMessageResult", 
        "warning": "<p>After a successful call, one can add values to the dictionary using functions like <code>dict_write_data()</code> and friends.</p>"
    }, 
    "app_message_outbox_send": {
        "description": "<p>Sends the outbound dictionary. </p>", 
        "kind": "fn", 
        "name": "app_message_outbox_send", 
        "params": [], 
        "return_desc": "<p>A result code, including but not limited to <code>APP_MSG_OK</code> or <code>APP_MSG_BUSY</code>. The <code>APP_MSG_OK</code> code does not mean that the message was sent successfully, but only that the start of processing was successful. Since this call is asynchronous, callbacks provide the final result instead.</p>", 
        "returns": "AppMessageResult", 
        "warning": null
    }, 
    "app_message_outbox_size_maximum": {
        "description": "<p>Programatically determine the outbox size maximum in the current configuration. </p>", 
        "kind": "fn", 
        "name": "app_message_outbox_size_maximum", 
        "params": [], 
        "return_desc": "<p>The outbox size maximum on this firmware.</p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "app_message_register_inbox_dropped": {
        "description": "<p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>", 
        "kind": "fn", 
        "name": "app_message_register_inbox_dropped", 
        "params": [
            {
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>", 
                "name": "dropped_callback", 
                "type": "AppMessageInboxDropped"
            }
        ], 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageInboxDropped", 
        "warning": null
    }, 
    "app_message_register_inbox_received": {
        "description": "<p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>", 
        "kind": "fn", 
        "name": "app_message_register_inbox_received", 
        "params": [
            {
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>", 
                "name": "received_callback", 
                "type": "AppMessageInboxReceived"
            }
        ], 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageInboxReceived", 
        "warning": null
    }, 
    "app_message_register_outbox_failed": {
        "description": "<p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>", 
        "kind": "fn", 
        "name": "app_message_register_outbox_failed", 
        "params": [
            {
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>", 
                "name": "failed_callback", 
                "type": "AppMessageOutboxFailed"
            }
        ], 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageOutboxFailed", 
        "warning": null
    }, 
    "app_message_register_outbox_sent": {
        "description": "<p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>", 
        "kind": "fn", 
        "name": "app_message_register_outbox_sent", 
        "params": [
            {
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>", 
                "name": "sent_callback", 
                "type": "AppMessageOutboxSent"
            }
        ], 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageOutboxSent", 
        "warning": null
    }, 
    "app_message_set_context": {
        "description": "<p>Sets the context that will be passed to all AppMessage callbacks. </p>", 
        "kind": "fn", 
        "name": "app_message_set_context", 
        "params": [
            {
                "description": "<p>The context that will be passed to all AppMessage callbacks.</p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>The previous context that was on record. </p>", 
        "returns": "void *", 
        "warning": null
    }, 
    "app_sync_deinit": {
        "description": "<p>Cleans up an AppSync system. It frees the buffer allocated by an <code>app_sync_init()</code> call and deregisters itself from the AppMessage subsystem. </p>", 
        "kind": "fn", 
        "name": "app_sync_deinit", 
        "params": [
            {
                "description": "<p>The AppSync context to deinit. </p>", 
                "name": "s", 
                "type": "struct AppSync *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_sync_get": {
        "description": "<p>Finds and gets a tuple in the \"current\" dictionary. </p>", 
        "kind": "fn", 
        "name": "app_sync_get", 
        "params": [
            {
                "description": "<p>The AppSync context </p>", 
                "name": "s", 
                "type": "const struct AppSync *"
            }, 
            {
                "description": "<p>The key for which to find a Tuple </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>Pointer to a found Tuple, or NULL if there was no Tuple with the specified key. </p>", 
        "returns": "const Tuple *", 
        "warning": null
    }, 
    "app_sync_init": {
        "description": "<p>Initialized an AppSync system with specific buffer size and initial keys and values. The callback.<code>value_changed</code> callback will be called asynchronously with the initial keys and values, as to avoid duplicating code to update your app's UI. </p>", 
        "kind": "fn", 
        "name": "app_sync_init", 
        "params": [
            {
                "description": "<p>The AppSync context to initialize </p>", 
                "name": "s", 
                "type": "struct AppSync *"
            }, 
            {
                "description": "<p>The buffer that AppSync should use </p>", 
                "name": "buffer", 
                "type": "uint8_t *"
            }, 
            {
                "description": "<p>The size of the backing storage of the \"current\" dictionary. Use <code>dict_calc_buffer_size_from_tuplets()</code> to estimate the size you need. </p>", 
                "name": "buffer_size", 
                "type": "const uint16_t"
            }, 
            {
                "description": "<p>An array of Tuplets with the initial keys and values. </p>", 
                "name": "keys_and_initial_values", 
                "type": "const Tuplet *const"
            }, 
            {
                "description": "<p>The number of Tuplets in the <code>keys_and_initial_values</code> array. </p>", 
                "name": "count", 
                "type": "const uint8_t"
            }, 
            {
                "description": "<p>The callback that will handle changed key/value pairs </p>", 
                "name": "tuple_changed_callback", 
                "type": "AppSyncTupleChangedCallback"
            }, 
            {
                "description": "<p>The callback that will handle errors </p>", 
                "name": "error_callback", 
                "type": "AppSyncErrorCallback"
            }, 
            {
                "description": "<p>Pointer to app specific data that will get passed into calls to the callbacks </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Only updates for the keys specified in this initial array will be accepted by AppSync, updates for other keys that might come in will just be ignored. </p>"
    }, 
    "app_sync_set": {
        "description": "<p>Updates key/value pairs using an array of Tuplets. </p>", 
        "kind": "fn", 
        "name": "app_sync_set", 
        "params": [
            {
                "description": "<p>The AppSync context </p>", 
                "name": "s", 
                "type": "struct AppSync *"
            }, 
            {
                "description": "<p>An array of Tuplets with the keys and values to update. The data in the Tuplets are copied during the call, so the array can be stack-allocated. </p>", 
                "name": "keys_and_values_to_update", 
                "type": "const Tuplet *const"
            }, 
            {
                "description": "<p>The number of Tuplets in the <code>keys_and_values_to_update</code> array. </p>", 
                "name": "count", 
                "type": "const uint8_t"
            }
        ], 
        "return_desc": "<p>The result code from the AppMessage subsystem. Can be <code>APP_MSG_OK</code>, <code>APP_MSG_BUSY</code> or <code>APP_MSG_INVALID_ARGS</code> </p>", 
        "returns": "AppMessageResult", 
        "warning": "<p>The call will attempt to send the updated keys and values to the application on the other end. Only after the other end has acknowledged the update, the .<code>value_changed</code> callback will be called to confirm the update has completed and your application code can update its user interface. </p>"
    }, 
    "app_timer_cancel": {
        "description": "<p>Cancels an already registered timer. Once cancelled the handle may no longer be used for any purpose. </p>", 
        "kind": "fn", 
        "name": "app_timer_cancel", 
        "params": [
            {
                "description": null, 
                "name": "timer_handle", 
                "type": "AppTimer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "app_timer_register": {
        "description": "<p>Registers a timer that ends up in callback being called some specified time in the future. </p>", 
        "kind": "fn", 
        "name": "app_timer_register", 
        "params": [
            {
                "description": "<p>The expiry time in milliseconds from the current time </p>", 
                "name": "timeout_ms", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>The callback that gets called at expiry time </p>", 
                "name": "callback", 
                "type": "AppTimerCallback"
            }, 
            {
                "description": "<p>The data that will be passed to callback </p>", 
                "name": "callback_data", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>A pointer to an AppTimer that can be used to later reschedule or cancel this timer </p>", 
        "returns": "AppTimer *", 
        "warning": null
    }, 
    "app_timer_reschedule": {
        "description": "<p>Reschedules an already running timer for some point in the future. </p>", 
        "kind": "fn", 
        "name": "app_timer_reschedule", 
        "params": [
            {
                "description": "<p>The timer to reschedule </p>", 
                "name": "timer_handle", 
                "type": "AppTimer *"
            }, 
            {
                "description": "<p>The new expiry time in milliseconds from the current time </p>", 
                "name": "new_timeout_ms", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>true if the timer was rescheduled, false if the timer has already elapsed </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "app_worker_is_running": {
        "description": "<p>Determine if the worker for the current app is running. </p>", 
        "kind": "fn", 
        "name": "app_worker_is_running", 
        "params": [], 
        "return_desc": "<p>true if running </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "app_worker_kill": {
        "description": "<p>Kill the worker for the current app. Note that this is an asynchronous operation, a result code of <code>APP_WORKER_RESULT_SUCCESS</code> merely means that the request was successfully queued up. </p>", 
        "kind": "fn", 
        "name": "app_worker_kill", 
        "params": [], 
        "return_desc": "<p>result code </p>", 
        "returns": "AppWorkerResult", 
        "warning": null
    }, 
    "app_worker_launch": {
        "description": "<p>Launch the worker for the current app. Note that this is an asynchronous operation, a result code of <code>APP_WORKER_RESULT_SUCCESS</code> merely means that the request was successfully queued up. </p>", 
        "kind": "fn", 
        "name": "app_worker_launch", 
        "params": [], 
        "return_desc": "<p>result code </p>", 
        "returns": "AppWorkerResult", 
        "warning": null
    }, 
    "app_worker_message_subscribe": {
        "description": "<p>Subscribe to worker messages. Once subscribed, the handler gets called on every message emitted by the other task (either worker or app). </p>", 
        "kind": "fn", 
        "name": "app_worker_message_subscribe", 
        "params": [
            {
                "description": "<p>A callback to be executed when the event is received </p>", 
                "name": "handler", 
                "type": "AppWorkerMessageHandler"
            }
        ], 
        "return_desc": "<p>true on success </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "app_worker_message_unsubscribe": {
        "description": "<p>Unsubscribe from worker messages. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "app_worker_message_unsubscribe", 
        "params": [], 
        "return_desc": "<p>true on success </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "app_worker_send_message": {
        "description": "<p>Send a message to the other task (either worker or app). </p>", 
        "kind": "fn", 
        "name": "app_worker_send_message", 
        "params": [
            {
                "description": "<p>An application defined message type </p>", 
                "name": "type", 
                "type": "uint8_t"
            }, 
            {
                "description": "<p>the message data structure </p>", 
                "name": "data", 
                "type": "AppWorkerMessage *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "atan2_lookup": {
        "description": "<p>Look-up the arctangent of a given x, y pair The angle value is scaled linearly, such that a value of 0x10000 corresponds to 360 degrees or 2 PI radians. </p>", 
        "kind": "fn", 
        "name": "atan2_lookup", 
        "params": [
            {
                "description": null, 
                "name": "y", 
                "type": "int16_t"
            }, 
            {
                "description": null, 
                "name": "x", 
                "type": "int16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "battery_state_service_peek": {
        "description": "<p>Peek at the last known battery state. </p>", 
        "kind": "fn", 
        "name": "battery_state_service_peek", 
        "params": [], 
        "return_desc": "<p>a BatteryChargeState containing the last known data </p>", 
        "returns": "BatteryChargeState", 
        "warning": null
    }, 
    "battery_state_service_subscribe": {
        "description": "<p>Subscribe to the battery state event service. Once subscribed, the handler gets called on every battery state change. </p>", 
        "kind": "fn", 
        "name": "battery_state_service_subscribe", 
        "params": [
            {
                "description": "<p>A callback to be executed on battery state change event </p>", 
                "name": "handler", 
                "type": "BatteryStateHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "battery_state_service_unsubscribe": {
        "description": "<p>Unsubscribe from the battery state event service. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "battery_state_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bitmap_layer_create": {
        "description": "<p><ul><li><p>Bitmap: NULL (none)</p></li><li><p>Background color: GColorClear</p></li><li><p>Compositing mode: GCompOpAssign</p></li><li><p>Clips: true </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "bitmap_layer_create", 
        "params": [
            {
                "description": null, 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>A pointer to the BitmapLayer. NULL if the BitmapLayer could not be created </p>", 
        "returns": "BitmapLayer *", 
        "warning": null
    }, 
    "bitmap_layer_destroy": {
        "description": "<p>Destroys a window previously created by <code>bitmap_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "bitmap_layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "bitmap_layer", 
                "type": "BitmapLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bitmap_layer_get_bitmap": {
        "description": "<p>Gets the pointer to the bitmap image that the BitmapLayer is using. </p>", 
        "kind": "fn", 
        "name": "bitmap_layer_get_bitmap", 
        "params": [
            {
                "description": "<p>The BitmapLayer for which to get the bitmap image </p>", 
                "name": "bitmap_layer", 
                "type": "BitmapLayer *"
            }
        ], 
        "return_desc": "<p>A pointer to the bitmap image that the BitmapLayer is using </p>", 
        "returns": "const GBitmap *", 
        "warning": null
    }, 
    "bitmap_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the bitmap layer, which is the parent for the sub- layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "bitmap_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the BitmapLayer for which to get the \"root\" Layer </p>", 
                "name": "bitmap_layer", 
                "type": "const BitmapLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the bitmap layer. </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "bitmap_layer_set_alignment": {
        "description": "<p>Sets the alignment of the image to draw with in frame of the BitmapLayer. The aligment parameter specifies which edges of the bitmap should overlap with the frame of the BitmapLayer. If the bitmap is smaller than the frame of the BitmapLayer, the background is filled with the background color. </p>", 
        "kind": "fn", 
        "name": "bitmap_layer_set_alignment", 
        "params": [
            {
                "description": "<p>The BitmapLayer for which to set the aligment </p>", 
                "name": "bitmap_layer", 
                "type": "BitmapLayer *"
            }, 
            {
                "description": "<p>The new alignment for the image inside the BitmapLayer </p>", 
                "name": "alignment", 
                "type": "GAlign"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bitmap_layer_set_background_color": {
        "description": "<p>Sets the background color of bounding box that will be drawn behind the image of the BitmapLayer. </p>", 
        "kind": "fn", 
        "name": "bitmap_layer_set_background_color", 
        "params": [
            {
                "description": "<p>The BitmapLayer for which to set the background color </p>", 
                "name": "bitmap_layer", 
                "type": "BitmapLayer *"
            }, 
            {
                "description": "<p>The new GColor to set the background to </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bitmap_layer_set_bitmap": {
        "description": "<p>Sets the bitmap onto the BitmapLayer. The bitmap is set by reference (no deep copy), thus the caller of this function has to make sure the bitmap is kept in memory. </p>", 
        "kind": "fn", 
        "name": "bitmap_layer_set_bitmap", 
        "params": [
            {
                "description": "<p>The BitmapLayer for which to set the bitmap image </p>", 
                "name": "bitmap_layer", 
                "type": "BitmapLayer *"
            }, 
            {
                "description": "<p>The new GBitmap to set onto the BitmapLayer </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bitmap_layer_set_compositing_mode": {
        "description": "<p>The compositing mode only affects the drawing of the bitmap and not the drawing of the background color.</p><p>For Aplite, there is no notion of \"transparency\" in the graphics system. However, the effect of transparency can be created by masking and using compositing modes.</p><p>For Basalt, when drawing GBitmap images, GCompOpSet will be required to apply any transparency.</p><p>The bitmap layer is automatically marked dirty after this operation. \n</p>", 
        "kind": "fn", 
        "name": "bitmap_layer_set_compositing_mode", 
        "params": [
            {
                "description": "<p>The BitmapLayer for which to set the compositing mode </p>", 
                "name": "bitmap_layer", 
                "type": "BitmapLayer *"
            }, 
            {
                "description": "<p>The compositing mode to set </p>", 
                "name": "mode", 
                "type": "GCompOp"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bluetooth_connection_service_peek": {
        "description": "<p>Deprecated<p>Backward compatibility function for <code>connection_service_peek_pebble_app_connection</code>. New code should use <code>connection_service_peek_pebble_app_connection</code> directly. This will be removed in a future version of the Pebble SDK </p></p>", 
        "kind": "fn", 
        "name": "bluetooth_connection_service_peek", 
        "params": [], 
        "return_desc": null, 
        "returns": "bool", 
        "warning": null
    }, 
    "bluetooth_connection_service_subscribe": {
        "description": "<p>Deprecated<p>Backward compatibility function for <code>connection_service_subscribe</code>. New code should use <code>connection_service_subscribe</code> directly. This will be removed in a future version of the Pebble SDK </p></p>", 
        "kind": "fn", 
        "name": "bluetooth_connection_service_subscribe", 
        "params": [
            {
                "description": null, 
                "name": "handler", 
                "type": "ConnectionHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "bluetooth_connection_service_unsubscribe": {
        "description": "<p>Deprecated<p>Backward compatibility function for <code>connection_service_unsubscribe</code>. New code should use <code>connection_service_unsubscribe</code> directly. This will be removed in a future version of the Pebble SDK </p></p>", 
        "kind": "fn", 
        "name": "bluetooth_connection_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "click_number_of_clicks_counted": {
        "description": "<p>Gets the click count. You can use this inside a click handler implementation to get the click count for <code>multi_click</code> and (repeated) click events. </p>", 
        "kind": "fn", 
        "name": "click_number_of_clicks_counted", 
        "params": [
            {
                "description": "<p>The click recognizer for which to get the click count </p>", 
                "name": "recognizer", 
                "type": "ClickRecognizerRef"
            }
        ], 
        "return_desc": "<p>The number of consecutive clicks, and for auto-repeating the number of repetitions. </p>", 
        "returns": "uint8_t", 
        "warning": null
    }, 
    "click_recognizer_get_button_id": {
        "description": "<p>Gets the button identifier. You can use this inside a click handler implementation to get the button id for the click event. </p>", 
        "kind": "fn", 
        "name": "click_recognizer_get_button_id", 
        "params": [
            {
                "description": "<p>The click recognizer for which to get the button id that caused the click event </p>", 
                "name": "recognizer", 
                "type": "ClickRecognizerRef"
            }
        ], 
        "return_desc": "<p>the ButtonId of the click recognizer </p>", 
        "returns": "ButtonId", 
        "warning": null
    }, 
    "click_recognizer_is_repeating": {
        "description": "<p>Is this a repeating click. You can use this inside a click handler implementation to find out whether this is a repeating click or not. </p>", 
        "kind": "fn", 
        "name": "click_recognizer_is_repeating", 
        "params": [
            {
                "description": "<p>The click recognizer for which to find out whether this is a repeating click. </p>", 
                "name": "recognizer", 
                "type": "ClickRecognizerRef"
            }
        ], 
        "return_desc": "<p>true if this is a repeating click. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "clock_copy_time_string": {
        "description": "<p>Copies a time string into the buffer, formatted according to the user's time display preferences (such as 12h/24h time). Example results: \"7:30\" or \"15:00\". </p>", 
        "kind": "fn", 
        "name": "clock_copy_time_string", 
        "params": [
            {
                "description": "<p>A pointer to the buffer to copy the time string into </p>", 
                "name": "buffer", 
                "type": "char *"
            }, 
            {
                "description": "<p>The maximum size of buffer </p>", 
                "name": "size", 
                "type": "uint8_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>AM/PM are also outputted with the time if the user's preference is 12h time. </p>"
    }, 
    "clock_get_timezone": {
        "description": "<p>If timezone is set, copies the current timezone long name (e.g. America/Chicago) to user-provided buffer. </p>", 
        "kind": "fn", 
        "name": "clock_get_timezone", 
        "params": [
            {
                "description": "<p>A pointer to the buffer to copy the timezone long name into </p>", 
                "name": "timezone", 
                "type": "char *"
            }, 
            {
                "description": "<p>Size of the allocated buffer to copy the timezone long name into </p>", 
                "name": "buffer_size", 
                "type": "const size_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>timezone buffer should be at least <code>TIMEZONE_NAME_LENGTH</code> bytes </p>"
    }, 
    "clock_is_24h_style": {
        "description": "<p>Gets the user's 12/24h clock style preference. </p>", 
        "kind": "fn", 
        "name": "clock_is_24h_style", 
        "params": [], 
        "return_desc": "<p>true if the user prefers 24h-style time display or false if the user prefers 12h-style time display. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "clock_is_timezone_set": {
        "description": "<p>Checks if timezone is currently set, otherwise gmtime == localtime. </p>", 
        "kind": "fn", 
        "name": "clock_is_timezone_set", 
        "params": [], 
        "return_desc": "<p>true if timezone has been set, false otherwise </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "clock_to_timestamp": {
        "description": "<p>Converts a (day, hour, minute) specification to a UTC timestamp occurring in the future Always returns a timestamp for the next occurring instance, example: specifying TODAY@14:30 when it is 14:40 will return a timestamp for 7 days from now at 14:30. </p>", 
        "kind": "fn", 
        "name": "clock_to_timestamp", 
        "params": [
            {
                "description": "<p>WeekDay day of week including support for specifying TODAY </p>", 
                "name": "day", 
                "type": "WeekDay"
            }, 
            {
                "description": "<p>hour specified in 24-hour format [0-23] </p>", 
                "name": "hour", 
                "type": "int"
            }, 
            {
                "description": "<p>minute [0-59] </p>", 
                "name": "minute", 
                "type": "int"
            }
        ], 
        "return_desc": null, 
        "returns": "time_t", 
        "warning": "<p>This function does not support Daylight Saving Time (DST) changes, events scheduled during a DST change will be off by an hour. </p>"
    }, 
    "compass_service_peek": {
        "description": "<p>Peek at the last recorded reading. </p>", 
        "kind": "fn", 
        "name": "compass_service_peek", 
        "params": [
            {
                "description": "<p>a pointer to a pre-allocated CompassHeadingData </p>", 
                "name": "data", 
                "type": "CompassHeadingData *"
            }
        ], 
        "return_desc": "<p>Always returns 0 to indicate success. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "compass_service_set_heading_filter": {
        "description": "<p>Set the minimum angular change required to generate new compass heading events. The angular distance is measured relative to the last delivered heading event. Use 0 to be notified of all movements. Negative values and values > <code>TRIG_MAX_ANGLE</code> / 2 are not valid. The default value of this property is <code>TRIG_MAX_ANGLE</code> / 360. </p>", 
        "kind": "fn", 
        "name": "compass_service_set_heading_filter", 
        "params": [
            {
                "description": null, 
                "name": "filter", 
                "type": "CompassHeading"
            }
        ], 
        "return_desc": "<p>0, success. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "compass_service_subscribe": {
        "description": "<p>Subscribe to the compass heading event service. Once subscribed, the handler gets called every time the angular distance relative to the previous value exceeds the configured filter. </p>", 
        "kind": "fn", 
        "name": "compass_service_subscribe", 
        "params": [
            {
                "description": "<p>A callback to be executed on heading events </p>", 
                "name": "handler", 
                "type": "CompassHeadingHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "compass_service_unsubscribe": {
        "description": "<p>Unsubscribe from the compass heading event service. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "compass_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "connection_service_peek_pebble_app_connection": {
        "description": "<p>Query the bluetooth connection service for the current Pebble app connection status. </p>", 
        "kind": "fn", 
        "name": "connection_service_peek_pebble_app_connection", 
        "params": [], 
        "return_desc": "<p>true if the Pebble app is connected, false otherwise </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "connection_service_peek_pebblekit_connection": {
        "description": "<p>Query the bluetooth connection service for the current PebbleKit connection status. </p>", 
        "kind": "fn", 
        "name": "connection_service_peek_pebblekit_connection", 
        "params": [], 
        "return_desc": "<p>true if a PebbleKit companion app is connected, false otherwise </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "connection_service_subscribe": {
        "description": "<p>Subscribe to the connection event service. Once subscribed, the appropriate handler gets called based on the type of connection event and user provided handlers. </p>", 
        "kind": "fn", 
        "name": "connection_service_subscribe", 
        "params": [
            {
                "description": null, 
                "name": "conn_handlers", 
                "type": "ConnectionHandlers"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "connection_service_unsubscribe": {
        "description": "<p>Unsubscribe from the bluetooth event service. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "connection_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "content_indicator_configure_direction": {
        "description": "<p>Configures a ContentIndicator for the given direction. </p>", 
        "kind": "fn", 
        "name": "content_indicator_configure_direction", 
        "params": [
            {
                "description": "<p>The ContentIndicator to configure. </p>", 
                "name": "content_indicator", 
                "type": "ContentIndicator *"
            }, 
            {
                "description": "<p>The direction for which to configure the ContentIndicator. </p>", 
                "name": "direction", 
                "type": "ContentIndicatorDirection"
            }, 
            {
                "description": "<p>The configuration to use to configure the ContentIndicator. If NULL, the data for the specified direction will be reset. </p>", 
                "name": "config", 
                "type": "const ContentIndicatorConfig *"
            }
        ], 
        "return_desc": "<p>True if the ContentIndicator was successfully configured for the given direction, false otherwise. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "content_indicator_create": {
        "description": "<p>Creates a ContentIndicator on the heap. </p>", 
        "kind": "fn", 
        "name": "content_indicator_create", 
        "params": [], 
        "return_desc": "<p>A pointer to the ContentIndicator. NULL if the ContentIndicator could not be created. </p>", 
        "returns": "ContentIndicator *", 
        "warning": null
    }, 
    "content_indicator_destroy": {
        "description": "<p>Destroys a ContentIndicator previously created using <code>content_indicator_create()</code>. </p>", 
        "kind": "fn", 
        "name": "content_indicator_destroy", 
        "params": [
            {
                "description": "<p>The ContentIndicator to destroy. </p>", 
                "name": "content_indicator", 
                "type": "ContentIndicator *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "content_indicator_get_content_available": {
        "description": "<p>Retrieves the availability status of content in the given direction. </p>", 
        "kind": "fn", 
        "name": "content_indicator_get_content_available", 
        "params": [
            {
                "description": "<p>The ContentIndicator for which to get the content availability. </p>", 
                "name": "content_indicator", 
                "type": "ContentIndicator *"
            }, 
            {
                "description": "<p>The direction for which to get the content availability. </p>", 
                "name": "direction", 
                "type": "ContentIndicatorDirection"
            }
        ], 
        "return_desc": "<p>True if content is available in the given direction, false otherwise. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "content_indicator_set_content_available": {
        "description": "<p>Sets the availability status of content in the given direction. </p>", 
        "kind": "fn", 
        "name": "content_indicator_set_content_available", 
        "params": [
            {
                "description": "<p>The ContentIndicator for which to set the content availability. </p>", 
                "name": "content_indicator", 
                "type": "ContentIndicator *"
            }, 
            {
                "description": "<p>The direction for which to set the content availability. </p>", 
                "name": "direction", 
                "type": "ContentIndicatorDirection"
            }, 
            {
                "description": "<p>Whether or not content is available. </p>", 
                "name": "available", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If <code>times_out</code> is enabled, calling this function resets any previously scheduled timeout timer for the ContentIndicator. </p>"
    }, 
    "cos_lookup": {
        "description": "<p>Look-up the cosine of the given angle from a pre-computed table. This is equivalent to calling <code>sin_lookup</code>(angle + <code>TRIG_MAX_ANGLE</code> / 4). </p>", 
        "kind": "fn", 
        "name": "cos_lookup", 
        "params": [
            {
                "description": "<p>The angle for which to compute the cosine. The angle value is scaled linearly, such that a value of 0x10000 corresponds to 360 degrees or 2 PI radians. </p>", 
                "name": "angle", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "data_logging_create": {
        "description": "<p>Create a new data logging session. </p>", 
        "kind": "fn", 
        "name": "data_logging_create", 
        "params": [
            {
                "description": "<p>A tag associated with the logging session. </p>", 
                "name": "tag", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>The type of data stored in this logging session </p>", 
                "name": "item_type", 
                "type": "DataLoggingItemType"
            }, 
            {
                "description": "<p>The size of a single data item in bytes </p>", 
                "name": "item_length", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>True if we want to look for a logging session of the same tag and resume logging to it. If this is false and a session with the specified tag exists, that session will be closed and a new session will be opened. </p>", 
                "name": "resume", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>An opaque reference to the data logging session </p>", 
        "returns": "DataLoggingSessionRef", 
        "warning": null
    }, 
    "data_logging_finish": {
        "description": "<p>Finish up a data <code>logging_session</code>. Logging data is kept until it has successfully been transferred over to the phone, but no data may be added to the session after this function is called. </p>", 
        "kind": "fn", 
        "name": "data_logging_finish", 
        "params": [
            {
                "description": "<p>a reference to the data logging session previously allocated using <code>data_logging_create</code> </p>", 
                "name": "logging_session", 
                "type": "DataLoggingSessionRef"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "data_logging_log": {
        "description": "<p><p><code>DATA_LOGGING_NOT_FOUND</code> if the logging session is invalid</p>\n<p><code>DATA_LOGGING_CLOSED</code> if the sesion is not active</p>\n<p><code>DATA_LOGGING_BUSY</code> if the sesion is not available for writing</p>\n<p><code>DATA_LOGGING_INVALID_PARAMS</code> if <code>num_items</code> is 0 or data is NULL </p>\n</p>", 
        "kind": "fn", 
        "name": "data_logging_log", 
        "params": [
            {
                "description": "<p>a reference to the data logging session you want to add the data to </p>", 
                "name": "logging_session", 
                "type": "DataLoggingSessionRef"
            }, 
            {
                "description": "<p>a pointer to the data buffer that contains multiple items </p>", 
                "name": "data", 
                "type": "const void *"
            }, 
            {
                "description": "<p>the number of items to log. This means data must be at least (<code>num_items</code> * <code>item_length</code>) long in bytes </p>", 
                "name": "num_items", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p><code>DATA_LOGGING_SUCCESS</code> on success</p>", 
        "returns": "DataLoggingResult", 
        "warning": null
    }, 
    "dict_calc_buffer_size": {
        "description": "<p>Calculates the number of bytes that a dictionary will occupy, given one or more value lengths that need to be stored in the dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_calc_buffer_size", 
        "params": [
            {
                "description": "<p>The total number of key/value pairs in the dictionary. </p>", 
                "name": "tuple_count", 
                "type": "const uint8_t"
            }
        ], 
        "return_desc": "<p>The total number of bytes of storage needed. </p>", 
        "returns": "uint32_t", 
        "warning": "<p>The formula to calculate the size of a Dictionary in bytes is: 1 + (n * 7) + D1 + ... + Dn Where n is the number of Tuples in the Dictionary and Dx are the sizes of the values in the Tuples. The size of the Dictionary header is 1 byte. The size of the header for each Tuple is 7 bytes. </p>"
    }, 
    "dict_calc_buffer_size_from_tuplets": {
        "description": "<p>Calculates the number of bytes that a dictionary will occupy, given one or more Tuplets that need to be stored in the dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_calc_buffer_size_from_tuplets", 
        "params": [
            {
                "description": "<p>An array of Tuplets that need to be stored in the dictionary. </p>", 
                "name": "tuplets", 
                "type": "const Tuplet *const"
            }, 
            {
                "description": "<p>The total number of Tuplets that follow. </p>", 
                "name": "tuplets_count", 
                "type": "const uint8_t"
            }
        ], 
        "return_desc": "<p>The total number of bytes of storage needed. </p>", 
        "returns": "uint32_t", 
        "warning": "<p>See <code>dict_calc_buffer_size()</code> for the formula for the calculation. </p>"
    }, 
    "dict_find": {
        "description": "<p>Tries to find a Tuple with specified key in a dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_find", 
        "params": [
            {
                "description": "<p>Iterator to the dictionary to search in. </p>", 
                "name": "iter", 
                "type": "const DictionaryIterator *"
            }, 
            {
                "description": "<p>The key for which to find a Tuple </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>Pointer to a found Tuple, or NULL if there was no Tuple with the specified key. </p>", 
        "returns": "Tuple *", 
        "warning": null
    }, 
    "dict_merge": {
        "description": "<p>Merges entries from another \"source\" dictionary into a \"destination\" dictionary. All Tuples from the source are written into the destination dictionary, while updating the exsting Tuples with matching keys. </p>", 
        "kind": "fn", 
        "name": "dict_merge", 
        "params": [
            {
                "description": "<p>The destination dictionary to update </p>", 
                "name": "dest", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>In: the maximum size of buffer backing dest. Out: the final size of the updated dictionary. </p>", 
                "name": "dest_max_size_in_out", 
                "type": "uint32_t *"
            }, 
            {
                "description": "<p>The source dictionary of which its Tuples will be used to update dest. </p>", 
                "name": "source", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>Specify True if only the existing keys in dest should be updated. </p>", 
                "name": "update_existing_keys_only", 
                "type": "const bool"
            }, 
            {
                "description": "<p>The callback that will be called for each Tuple in the merged destination dictionary. </p>", 
                "name": "key_callback", 
                "type": "const DictionaryKeyUpdatedCallback"
            }, 
            {
                "description": "<p>Pointer to app specific data that will get passed in when <code>update_key_callback</code> is called. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_INVALID_ARGS</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_read_begin_from_buffer": {
        "description": "<p>Initializes the dictionary iterator with a given buffer and size, in preparation of reading key/value tuples. </p>", 
        "kind": "fn", 
        "name": "dict_read_begin_from_buffer", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The storage of the dictionary </p>", 
                "name": "buffer", 
                "type": "const uint8_t *const"
            }, 
            {
                "description": "<p>The storage size of the dictionary </p>", 
                "name": "size", 
                "type": "const uint16_t"
            }
        ], 
        "return_desc": "<p>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </p>", 
        "returns": "Tuple *", 
        "warning": null
    }, 
    "dict_read_first": {
        "description": "<p>Resets the iterator back to the same state as a call to <code>dict_read_begin_from_buffer()</code> would do. </p>", 
        "kind": "fn", 
        "name": "dict_read_first", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }
        ], 
        "return_desc": "<p>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </p>", 
        "returns": "Tuple *", 
        "warning": null
    }, 
    "dict_read_next": {
        "description": "<p>Progresses the iterator to the next key/value pair. </p>", 
        "kind": "fn", 
        "name": "dict_read_next", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }
        ], 
        "return_desc": "<p>The next tuple in the dictionary, or NULL in case the end has been reached or if there was a parsing error. </p>", 
        "returns": "Tuple *", 
        "warning": null
    }, 
    "dict_serialize_tuplets": {
        "description": "<p>Utility function that takes a list of Tuplets from which a dictionary will be serialized, ready to transmit or store. </p>", 
        "kind": "fn", 
        "name": "dict_serialize_tuplets", 
        "params": [
            {
                "description": "<p>The callback that will be called with the serialized data of the generated dictionary. </p>", 
                "name": "callback", 
                "type": "DictionarySerializeCallback"
            }, 
            {
                "description": "<p>Pointer to any application specific data that gets passed into the callback. </p>", 
                "name": "context", 
                "type": "void *"
            }, 
            {
                "description": "<p>An array of Tuplets that need to be serialized into the dictionary. </p>", 
                "name": "tuplets", 
                "type": "const Tuplet *const"
            }, 
            {
                "description": "<p>The number of tuplets that follow. </p>", 
                "name": "tuplets_count", 
                "type": "const uint8_t"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>The callback will be called before the function returns, so the data that that context points to, can be stack allocated. </p>"
    }, 
    "dict_serialize_tuplets_to_buffer": {
        "description": "<p>Utility function that takes an array of Tuplets and serializes them into a dictionary with a given buffer and size. </p>", 
        "kind": "fn", 
        "name": "dict_serialize_tuplets_to_buffer", 
        "params": [
            {
                "description": "<p>The array of tuplets </p>", 
                "name": "tuplets", 
                "type": "const Tuplet *const"
            }, 
            {
                "description": "<p>The number of tuplets in the array </p>", 
                "name": "tuplets_count", 
                "type": "const uint8_t"
            }, 
            {
                "description": "<p>The buffer in which to write the serialized dictionary </p>", 
                "name": "buffer", 
                "type": "uint8_t *"
            }, 
            {
                "description": "<p>The number of bytes written </p>", 
                "name": "size_in_out", 
                "type": "uint32_t *"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_serialize_tuplets_to_buffer_with_iter": {
        "description": "<p>Serializes an array of Tuplets into a dictionary with a given buffer and size. </p>", 
        "kind": "fn", 
        "name": "dict_serialize_tuplets_to_buffer_with_iter", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The array of tuplets </p>", 
                "name": "tuplets", 
                "type": "const Tuplet *const"
            }, 
            {
                "description": "<p>The number of tuplets in the array </p>", 
                "name": "tuplets_count", 
                "type": "const uint8_t"
            }, 
            {
                "description": "<p>The buffer in which to write the serialized dictionary </p>", 
                "name": "buffer", 
                "type": "uint8_t *"
            }, 
            {
                "description": "<p>The number of bytes written </p>", 
                "name": "size_in_out", 
                "type": "uint32_t *"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_size": {
        "description": "<p>Calculates the size of data that has been written to the dictionary. AKA, the \"dictionary size\". Note that this is most likely different than the size of the backing storage/backing buffer. </p>", 
        "kind": "fn", 
        "name": "dict_size", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }
        ], 
        "return_desc": "<p>The total number of bytes which have been written to the dictionary. </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "dict_write_begin": {
        "description": "<p>Initializes the dictionary iterator with a given buffer and size, resets and empties it, in preparation of writing key/value tuples. </p>", 
        "kind": "fn", 
        "name": "dict_write_begin", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The storage of the dictionary </p>", 
                "name": "buffer", 
                "type": "uint8_t *const"
            }, 
            {
                "description": "<p>The storage size of the dictionary </p>", 
                "name": "size", 
                "type": "const uint16_t"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_cstring": {
        "description": "<p>Adds a key with a C string value pair to the dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_write_cstring", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The key </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>Pointer to the zero-terminated C string </p>", 
                "name": "cstring", 
                "type": "const char *const"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>The string will be copied into the backing storage of the dictionary. </p>"
    }, 
    "dict_write_data": {
        "description": "<p>Adds a key with a byte array value pair to the dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_write_data", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The key </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>Pointer to the byte array </p>", 
                "name": "data", 
                "type": "const uint8_t *const"
            }, 
            {
                "description": "<p>Length of the byte array </p>", 
                "name": "size", 
                "type": "const uint16_t"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>The data will be copied into the backing storage of the dictionary. </p>"
    }, 
    "dict_write_end": {
        "description": "<p>End a series of writing operations to a dictionary. This must be called before reading back from the dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_write_end", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }
        ], 
        "return_desc": "<p>The size in bytes of the finalized dictionary, or 0 if the parameters were invalid. </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "dict_write_int": {
        "description": "<p>Adds a key with an integer value pair to the dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_write_int", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The key </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>Pointer to the integer value </p>", 
                "name": "integer", 
                "type": "const void *"
            }, 
            {
                "description": "<p>The width of the integer value </p>", 
                "name": "width_bytes", 
                "type": "const uint8_t"
            }, 
            {
                "description": "<p>Whether the integer's type is signed or not </p>", 
                "name": "is_signed", 
                "type": "const bool"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>There is no checking for duplicate keys. <code>dict_write_int()</code> is only for serializing a single integer. <code>width_bytes</code> can only be 1, 2, or 4. </p>"
    }, 
    "dict_write_int16": {
        "description": "", 
        "kind": "fn", 
        "name": "dict_write_int16", 
        "params": [
            {
                "description": null, 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": null, 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": null, 
                "name": "value", 
                "type": "const int16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_int32": {
        "description": "", 
        "kind": "fn", 
        "name": "dict_write_int32", 
        "params": [
            {
                "description": null, 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": null, 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": null, 
                "name": "value", 
                "type": "const int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_int8": {
        "description": "", 
        "kind": "fn", 
        "name": "dict_write_int8", 
        "params": [
            {
                "description": null, 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": null, 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": null, 
                "name": "value", 
                "type": "const int8_t"
            }
        ], 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_tuplet": {
        "description": "<p>Serializes a Tuplet and writes the resulting Tuple into a dictionary. </p>", 
        "kind": "fn", 
        "name": "dict_write_tuplet", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The Tuplet describing the key/value pair to write </p>", 
                "name": "tuplet", 
                "type": "const Tuplet *const"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_uint16": {
        "description": "", 
        "kind": "fn", 
        "name": "dict_write_uint16", 
        "params": [
            {
                "description": null, 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": null, 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": null, 
                "name": "value", 
                "type": "const uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_uint32": {
        "description": "", 
        "kind": "fn", 
        "name": "dict_write_uint32", 
        "params": [
            {
                "description": null, 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": null, 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": null, 
                "name": "value", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null
    }, 
    "dict_write_uint8": {
        "description": "<p><p>There are counterpart functions for different signedness and widths, <code>dict_write_uint16()</code>, <code>dict_write_uint32()</code>, <code>dict_write_int8()</code>, <code>dict_write_int16()</code> and <code>dict_write_int32()</code>. The documentation is not repeated for brevity's sake. </p>\n</p>", 
        "kind": "fn", 
        "name": "dict_write_uint8", 
        "params": [
            {
                "description": "<p>The dictionary iterator </p>", 
                "name": "iter", 
                "type": "DictionaryIterator *"
            }, 
            {
                "description": "<p>The key </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The unsigned, 8-bit integer value </p>", 
                "name": "value", 
                "type": "const uint8_t"
            }
        ], 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>There is no checking for duplicate keys. </p>"
    }, 
    "dictation_session_create": {
        "description": "<p>Create a dictation session. The session object can be used more than once to get a transcription. When a transcription is received a buffer will be allocated to store the text in with a maximum size specified by <code>buffer_size</code>. When a transcription and accepted by the user or a failure of some sort occurs, the callback specified will be called with the status and the transcription if one was accepted. </p>", 
        "kind": "fn", 
        "name": "dictation_session_create", 
        "params": [
            {
                "description": "<p>size of buffer to allocate for the transcription text; text will be truncated if it is longer than the maximum size specified; a size of 0 will allow the session to allocate as much as it needs and text will not be truncated </p>", 
                "name": "buffer_size", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>dictation session status handler (must be valid) </p>", 
                "name": "callback", 
                "type": "DictationSessionStatusCallback"
            }, 
            {
                "description": "<p>context pointer for status handler </p>", 
                "name": "callback_context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>handle to the dictation session or NULL if the phone app is not connected or does not support voice dictation, if this is called on a platform that doesn't support voice dictation, or if an internal error occurs. </p>", 
        "returns": "DictationSession *", 
        "warning": null
    }, 
    "dictation_session_destroy": {
        "description": "<p>Destroy the dictation session and free its memory. Will terminate a session in progress. </p>", 
        "kind": "fn", 
        "name": "dictation_session_destroy", 
        "params": [
            {
                "description": "<p>dictation session to be destroyed </p>", 
                "name": "session", 
                "type": "DictationSession *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "dictation_session_enable_confirmation": {
        "description": "<p>Enable or disable user confirmation of transcribed text, which allows the user to accept or reject (and restart) the transcription. Must be called before the session is started. </p>", 
        "kind": "fn", 
        "name": "dictation_session_enable_confirmation", 
        "params": [
            {
                "description": "<p>dictation session to modify </p>", 
                "name": "session", 
                "type": "DictationSession *"
            }, 
            {
                "description": "<p>set to true to enable user confirmation of transcriptions (default), false to disable </p>", 
                "name": "is_enabled", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "dictation_session_enable_error_dialogs": {
        "description": "<p>Enable or disable error dialogs when transcription fails. Must be called before the session is started. Disabling error dialogs will also disable automatic retries if transcription fails. </p>", 
        "kind": "fn", 
        "name": "dictation_session_enable_error_dialogs", 
        "params": [
            {
                "description": "<p>dictation session to modify </p>", 
                "name": "session", 
                "type": "DictationSession *"
            }, 
            {
                "description": "<p>set to true to enable error dialogs (default), false to disable </p>", 
                "name": "is_enabled", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "dictation_session_start": {
        "description": "<p>Start the dictation session. The dictation UI will be shown. When the user accepts a transcription or exits the UI, or, when the confirmation dialog is disabled and a status is received, the status callback will be called. Can only be called when no session is in progress. The session can be restarted multiple times after the UI is exited or the session is stopped. </p>", 
        "kind": "fn", 
        "name": "dictation_session_start", 
        "params": [
            {
                "description": "<p>dictation session to start or restart </p>", 
                "name": "session", 
                "type": "DictationSession *"
            }
        ], 
        "return_desc": "<p>true if session was started, false if session is already in progress or is invalid. </p>", 
        "returns": "DictationSessionStatus", 
        "warning": null
    }, 
    "dictation_session_stop": {
        "description": "<p>Stop the current dictation session. The UI will be hidden and no status callbacks will be received after the session is stopped. </p>", 
        "kind": "fn", 
        "name": "dictation_session_stop", 
        "params": [
            {
                "description": "<p>dictation session to stop </p>", 
                "name": "session", 
                "type": "DictationSession *"
            }
        ], 
        "return_desc": "<p>true if session was stopped, false if session was not started or is invalid </p>", 
        "returns": "DictationSessionStatus", 
        "warning": null
    }, 
    "difftime": {
        "description": "<p>Obtain the number of seconds elapsed between beginning and end represented as a double. </p>", 
        "kind": "fn", 
        "name": "difftime", 
        "params": [
            {
                "description": "<p>A <code>time_t</code> variable representing some number of seconds since epoch, January 1st 1970 </p>", 
                "name": "end", 
                "type": "time_t"
            }, 
            {
                "description": "<p>A <code>time_t</code> variable representing some number of seconds since epoch, January 1st 1970. Note that end should be greater than beginning, but this is not enforced. </p>", 
                "name": "beginning", 
                "type": "time_t"
            }
        ], 
        "return_desc": "<p>The number of seconds elapsed between beginning and end. </p>", 
        "returns": "double", 
        "warning": "<p>Pebble uses software floating point emulation. Including this function which returns a double will significantly increase the size of your binary. We recommend directly subtracting both timestamps to calculate a time difference. intdifference=ts1-ts2;\n </p>"
    }, 
    "exit_reason_set": {
        "description": "<p>Set the app exit reason to a new reason. </p>", 
        "kind": "fn", 
        "name": "exit_reason_set", 
        "params": [
            {
                "description": null, 
                "name": "exit_reason", 
                "type": "AppExitReason"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "fonts_get_system_font": {
        "description": "<p>Loads a system font corresponding to the specified font key. </p>", 
        "kind": "fn", 
        "name": "fonts_get_system_font", 
        "params": [
            {
                "description": "<p>The string key of the font to load. See <code>pebble_fonts</code>.h for a list of system fonts. </p>", 
                "name": "font_key", 
                "type": "const char *"
            }
        ], 
        "return_desc": "<p>An opaque pointer to the loaded font, or, a pointer to the default (fallback) font if the specified font cannot be loaded. </p>", 
        "returns": "GFont", 
        "warning": "<p>This may load a font from the flash peripheral into RAM. </p>"
    }, 
    "fonts_load_custom_font": {
        "description": "<p>Loads a custom font. </p>", 
        "kind": "fn", 
        "name": "fonts_load_custom_font", 
        "params": [
            {
                "description": "<p>The resource handle of the font to load. See <code>resource_ids</code>.auto.h for a list of resource IDs, and use <code>resource_get_handle()</code> to obtain the resource handle. </p>", 
                "name": "handle", 
                "type": "ResHandle"
            }
        ], 
        "return_desc": "<p>An opaque pointer to the loaded font, or a pointer to the default (fallback) font if the specified font cannot be loaded. </p>", 
        "returns": "GFont", 
        "warning": "<p>this may load a font from the flash peripheral into RAM. </p>"
    }, 
    "fonts_unload_custom_font": {
        "description": "<p>Unloads the specified custom font and frees the memory that is occupied by it. </p>", 
        "kind": "fn", 
        "name": "fonts_unload_custom_font", 
        "params": [
            {
                "description": "<p>The font to unload. </p>", 
                "name": "font", 
                "type": "GFont"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>When an application exits, the system automatically unloads all fonts that have been loaded. </p>"
    }, 
    "gbitmap_create_as_sub_bitmap": {
        "description": "<p>Create a new GBitmap on the heap as a sub-bitmap of a 'base' GBitmap, using a GRect to indicate what portion of the base to use. The sub-bitmap will just reference the image data and palette of the base bitmap. No deep-copying occurs as a result of calling this function, thus the caller is responsible for making sure the base bitmap and palette will remain available when using the sub-bitmap. Note that you should not destroy the parent bitmap until the <code>sub_bitmap</code> has been destroyed. The resulting GBitmap must be destroyed using <code>gbitmap_destroy()</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_create_as_sub_bitmap", 
        "params": [
            {
                "description": "<p>The bitmap that the sub-bitmap of which the image data will be used by the sub-bitmap </p>", 
                "name": "base_bitmap", 
                "type": "const GBitmap *"
            }, 
            {
                "description": "<p>The rectangle within the image data of the base bitmap. The bounds of the base bitmap will be used to clip <code>sub_rect</code>. </p>", 
                "name": "sub_rect", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": null
    }, 
    "gbitmap_create_blank": {
        "description": "<p>Creates a new blank GBitmap on the heap initialized to zeroes. In the case that the format indicates a palettized bitmap, a palette of appropriate size will also be allocated on the heap. The resulting GBitmap must be destroyed using <code>gbitmap_destroy()</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_create_blank", 
        "params": [
            {
                "description": "<p>The Pebble image dimensions as a GSize. </p>", 
                "name": "size", 
                "type": "GSize"
            }, 
            {
                "description": "<p>The GBitmapFormat the created image should be in. </p>", 
                "name": "format", 
                "type": "GBitmapFormat"
            }
        ], 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": null
    }, 
    "gbitmap_create_blank_with_palette": {
        "description": "<p>Creates a new blank GBitmap on the heap, initialized to zeroes, and assigns it the given palette. No deep-copying of the palette occurs, so the caller is responsible for making sure the palette remains available when using the resulting bitmap. Management of that memory can be handed off to the system with the <code>free_on_destroy</code> argument. </p>", 
        "kind": "fn", 
        "name": "gbitmap_create_blank_with_palette", 
        "params": [
            {
                "description": "<p>The Pebble image dimensions as a GSize. </p>", 
                "name": "size", 
                "type": "GSize"
            }, 
            {
                "description": "<p>the GBitmapFormat the created image and palette should be in. </p>", 
                "name": "format", 
                "type": "GBitmapFormat"
            }, 
            {
                "description": "<p>a pointer to a palette that is to be used for this GBitmap. The palette should be large enough to hold enough colors for the specified format. For example, GBitmapFormat2BitPalette should have 4 colors, since 2^2 = 4. </p>", 
                "name": "palette", 
                "type": "GColor *"
            }, 
            {
                "description": "<p>Set whether the palette data should be freed along with the bitmap data when the GBitmap is destroyed. </p>", 
                "name": "free_on_destroy", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>A Pointer to the GBitmap. NULL if the GBitmap could not be created. </p>", 
        "returns": "GBitmap *", 
        "warning": null
    }, 
    "gbitmap_create_from_png_data": {
        "description": "<p>Create a GBitmap based on raw PNG data. The resulting GBitmap must be destroyed using <code>gbitmap_destroy()</code>. The developer is responsible for freeing <code>png_data</code> following this call. </p>", 
        "kind": "fn", 
        "name": "gbitmap_create_from_png_data", 
        "params": [
            {
                "description": "<p>PNG image data. </p>", 
                "name": "png_data", 
                "type": "const uint8_t *"
            }, 
            {
                "description": "<p>PNG image size in bytes. </p>", 
                "name": "png_data_size", 
                "type": "size_t"
            }
        ], 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": "<p>PNG decoding currently supports 1,2,4 and 8 bit palettized and grayscale images. </p>"
    }, 
    "gbitmap_create_palettized_from_1bit": {
        "description": "<p>Given a 1-bit GBitmap, create a new bitmap of format GBitmapFormat1BitPalette. The new data buffer is allocated on the heap, and a 2-color palette is allocated as well. </p>", 
        "kind": "fn", 
        "name": "gbitmap_create_palettized_from_1bit", 
        "params": [
            {
                "description": "<p>A GBitmap of format GBitmapFormat1Bit which is to be copied into a newly created GBitmap of format GBitmapFormat1BitPalettized. </p>", 
                "name": "src_bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": "<p>The newly created 1-bit palettized GBitmap, or NULL if there is not sufficient space. </p>", 
        "returns": "GBitmap *", 
        "warning": "<p>The new bitmap does not depend on any data from <code>src_bitmap</code>, so <code>src_bitmap</code> can be freed without worry. </p>"
    }, 
    "gbitmap_create_with_data": {
        "description": "<p>The resulting GBitmap must be destroyed using <code>gbitmap_destroy()</code> but the image data will not be freed automatically. The developer is responsible for keeping the image data in memory as long as the bitmap is used and releasing it after the bitmap is destroyed.", 
        "kind": "fn", 
        "name": "gbitmap_create_with_data", 
        "params": [
            {
                "description": "<p>The Pebble image data. Must not be NULL. The function assumes the data to be correct; there are no sanity checks performed on the data. The data will not be copied and the pointer must remain valid for the lifetime of this GBitmap. </p>", 
                "name": "data", 
                "type": "const uint8_t *"
            }
        ], 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": "<p>One way to generate Pebble image data is to use bitmapgen.py in the Pebble SDK to generate a .pbi file. </p>"
    }, 
    "gbitmap_create_with_resource": {
        "description": "<p>Creates a new GBitmap on the heap using a Pebble image file stored as a resource. The resulting GBitmap must be destroyed using <code>gbitmap_destroy()</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_create_with_resource", 
        "params": [
            {
                "description": "<p>The ID of the bitmap resource to load </p>", 
                "name": "resource_id", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": null
    }, 
    "gbitmap_destroy": {
        "description": "<p>This function will also free the memory of the bitmap data (bitmap->addr) if the bitmap was created with <code>gbitmap_create_blank()</code> or <code>gbitmap_create_with_resource()</code>.</p><p>If the GBitmap was created with <code>gbitmap_create_with_data()</code>, you must release the memory after calling <code>gbitmap_destroy()</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_destroy", 
        "params": [
            {
                "description": null, 
                "name": "bitmap", 
                "type": "GBitmap *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gbitmap_get_bounds": {
        "description": "<p>Gets the bounds of the content for the GBitmap. This is set when loading the image or if changed by <code>gbitmap_set_bounds</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_get_bounds", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to get the bounding box from. </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": "<p>The bounding box for the GBitmap. </p>", 
        "returns": "GRect", 
        "warning": null
    }, 
    "gbitmap_get_bytes_per_row": {
        "description": "<p>Get the number of bytes per row in the bitmap data for the given GBitmap. On rectangular displays, this can be used as a safe way of iterating over the rows in the bitmap, since bytes per row should be set according to format. On circular displays with pixel format of GBitmapFormat8BitCircular this will return 0, and should not be used for iteration over frame buffer pixels. Instead, use GBitmapDataRowInfo, which provides safe minimum and maximum x values for a given row's y value. </p>", 
        "kind": "fn", 
        "name": "gbitmap_get_bytes_per_row", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to get the bytes per row </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": "<p>The number of bytes per row of the GBitmap </p>", 
        "returns": "uint16_t", 
        "warning": null
    }, 
    "gbitmap_get_data": {
        "description": "<p>Get a pointer to the raw image data section of the given GBitmap as specified by the format of the bitmap. </p>", 
        "kind": "fn", 
        "name": "gbitmap_get_data", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to get the data </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": "<p>pointer to the raw image data for the GBitmap </p>", 
        "returns": "uint8_t *", 
        "warning": null
    }, 
    "gbitmap_get_data_row_info": {
        "description": "<p>Provides information about a pixel data row. </p>", 
        "kind": "fn", 
        "name": "gbitmap_get_data_row_info", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to get row info </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }, 
            {
                "description": "<p>Absolute row number in the pixel data, independent from the bitmap's bounds </p>", 
                "name": "y", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": "<p>Description of the row </p>", 
        "returns": "GBitmapDataRowInfo", 
        "warning": "<p>This function does not respect the bitmap's bounds but purely operates on the pixel data. This function works with every bitmap format including GBitmapFormat1Bit. The result of the function for invalid rows is undefined. </p>"
    }, 
    "gbitmap_get_format": {
        "description": "<p>Get the GBitmapFormat for the GBitmap. </p>", 
        "kind": "fn", 
        "name": "gbitmap_get_format", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to get the format </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": "<p>The format of the given GBitmap. </p>", 
        "returns": "GBitmapFormat", 
        "warning": null
    }, 
    "gbitmap_get_palette": {
        "description": "<p>Get the palette for the given GBitmap. </p>", 
        "kind": "fn", 
        "name": "gbitmap_get_palette", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to get the palette from. </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }
        ], 
        "return_desc": "<p>Pointer to a GColor array containing the palette colors. </p>", 
        "returns": "GColor *", 
        "warning": null
    }, 
    "gbitmap_sequence_create_with_resource": {
        "description": "<p>Creates a GBitmapSequence from the specified resource (APNG/PNG files) </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_create_with_resource", 
        "params": [
            {
                "description": "<p>Resource to load and create GBitmapSequence from. </p>", 
                "name": "resource_id", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>GBitmapSequence pointer if the resource was loaded, NULL otherwise </p>", 
        "returns": "GBitmapSequence *", 
        "warning": null
    }, 
    "gbitmap_sequence_destroy": {
        "description": "<p>Deletes the GBitmapSequence structure and frees any allocated memory/<code>decoder_data</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_destroy", 
        "params": [
            {
                "description": "<p>Pointer to the bitmap sequence to free (delete) </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gbitmap_sequence_get_bitmap_size": {
        "description": "<p>This function gets the minimum required size (dimensions) necessary to render the bitmap sequence to a GBitmap using the /ref <code>gbitmap_sequence_update_bitmap_next_frame</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_get_bitmap_size", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }
        ], 
        "return_desc": "<p>Dimensions required to render the bitmap sequence to a GBitmap </p>", 
        "returns": "GSize", 
        "warning": null
    }, 
    "gbitmap_sequence_get_current_frame_idx": {
        "description": "<p>This function gets the current frame number for the bitmap sequence. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_get_current_frame_idx", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }
        ], 
        "return_desc": "<p>index of current frame in the current loop of the bitmap sequence </p>", 
        "returns": "int32_t", 
        "warning": null
    }, 
    "gbitmap_sequence_get_play_count": {
        "description": "<p>This function gets the play count (number of times to repeat) the bitmap sequence. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_get_play_count", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }
        ], 
        "return_desc": "<p>Play count of bitmap sequence, <code>PLAY_COUNT_INFINITE</code> for infinite looping </p>", 
        "returns": "uint32_t", 
        "warning": "<p>This value is initialized by the bitmap sequence data, and is modified by <code>gbitmap_sequence_set_play_count</code> </p>"
    }, 
    "gbitmap_sequence_get_total_num_frames": {
        "description": "<p>This function sets the total number of frames for the bitmap sequence. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_get_total_num_frames", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }
        ], 
        "return_desc": "<p>number of frames contained in a single loop of the bitmap sequence </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "gbitmap_sequence_restart": {
        "description": "<p>Restarts the GBitmapSequence to the first frame <code>gbitmap_sequence_update_bitmap_next_frame</code>. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_restart", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }
        ], 
        "return_desc": "<p>True if sequence was restarted, false otherwise </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "gbitmap_sequence_set_play_count": {
        "description": "<p>This function sets the play count (number of times to repeat) the bitmap sequence. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_set_play_count", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }, 
            {
                "description": "<p>Number of times to repeat the bitmap sequence with 0 disabling <code>update_by_elapsed</code> and <code>update_next_frame</code>, and <code>PLAY_COUNT_INFINITE</code> for infinite looping of the animation </p>", 
                "name": "play_count", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gbitmap_sequence_update_bitmap_by_elapsed": {
        "description": "<p>Updates the contents of the bitmap sequence to the frame at elapsed in the sequence. For looping animations this accounts for the loop, for example an animation of 1 second that is configured to loop 2 times updated to 1500 ms elapsed time will display the sequence frame at 500 ms. Elapsed time is the time from the start of the animation, and will be ignored if it is for a time earlier than the last rendered frame. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_update_bitmap_by_elapsed", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }, 
            {
                "description": "<p>Pointer to the initialized GBitmap in which to render the bitmap sequence </p>", 
                "name": "bitmap", 
                "type": "GBitmap *"
            }, 
            {
                "description": "<p>Elapsed time in milliseconds in the sequence relative to start </p>", 
                "name": "elapsed_ms", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>True if a frame was rendered. False if all frames (and loops) have already been rendered for the sequence. Will also return false if frame could not be rendered (includes out of memory errors). </p>", 
        "returns": "bool", 
        "warning": "<p>GBitmap must be large enough to accommodate the <code>bitmap_sequence</code> image <code>gbitmap_sequence_get_bitmap_size</code> </p>"
    }, 
    "gbitmap_sequence_update_bitmap_next_frame": {
        "description": "<p>Updates the contents of the bitmap sequence to the next frame and optionally returns the delay in milliseconds until the next frame. </p>", 
        "kind": "fn", 
        "name": "gbitmap_sequence_update_bitmap_next_frame", 
        "params": [
            {
                "description": "<p>Pointer to loaded bitmap sequence </p>", 
                "name": "bitmap_sequence", 
                "type": "GBitmapSequence *"
            }, 
            {
                "description": "<p>Pointer to the initialized GBitmap in which to render the bitmap sequence </p>", 
                "name": "bitmap", 
                "type": "GBitmap *"
            }, 
            {
                "description": "<p>If not NULL, returns the delay in milliseconds until the next frame. </p>", 
                "name": "delay_ms", 
                "type": "uint32_t *"
            }
        ], 
        "return_desc": "<p>True if frame was rendered. False if all frames (and loops) have been rendered for the sequence. Will also return false if frame could not be rendered (includes out of memory errors). </p>", 
        "returns": "bool", 
        "warning": "<p>GBitmap must be large enough to accommodate the <code>bitmap_sequence</code> image <code>gbitmap_sequence_get_bitmap_size</code> </p>"
    }, 
    "gbitmap_set_bounds": {
        "description": "<p>Set the bounds of the given GBitmap. </p>", 
        "kind": "fn", 
        "name": "gbitmap_set_bounds", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to set the bounding box. </p>", 
                "name": "bitmap", 
                "type": "GBitmap *"
            }, 
            {
                "description": "<p>The bounding box to set. </p>", 
                "name": "bounds", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gbitmap_set_data": {
        "description": "<p>Set the bitmap data for the given GBitmap. </p>", 
        "kind": "fn", 
        "name": "gbitmap_set_data", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to set data to </p>", 
                "name": "bitmap", 
                "type": "GBitmap *"
            }, 
            {
                "description": "<p>A pointer to the bitmap data </p>", 
                "name": "data", 
                "type": "uint8_t *"
            }, 
            {
                "description": "<p>the format of the bitmap data. If this is a palettized format, make sure that there is an accompanying call to <code>gbitmap_set_palette</code>. </p>", 
                "name": "format", 
                "type": "GBitmapFormat"
            }, 
            {
                "description": "<p>How many bytes a single row takes. For example, bitmap data of format GBitmapFormat1Bit must have a row size as a multiple of 4 bytes. </p>", 
                "name": "row_size_bytes", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>Set whether the data should be freed when the GBitmap is destroyed. </p>", 
                "name": "free_on_destroy", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gbitmap_set_palette": {
        "description": "<p>Set the palette for the given GBitmap. </p>", 
        "kind": "fn", 
        "name": "gbitmap_set_palette", 
        "params": [
            {
                "description": "<p>A pointer to the GBitmap to set the palette to </p>", 
                "name": "bitmap", 
                "type": "GBitmap *"
            }, 
            {
                "description": "<p>The palette to be used. Make sure that the palette is large enough for the bitmap's format. </p>", 
                "name": "palette", 
                "type": "GColor *"
            }, 
            {
                "description": "<p>Set whether the palette data should be freed when the GBitmap is destroyed or when another palette is set. </p>", 
                "name": "free_on_destroy", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gcolor_equal": {
        "description": "<p>True if both colors are identical or both are invisible (i.e. both have alpha values of .a=0). </p>", 
        "kind": "fn", 
        "name": "gcolor_equal", 
        "params": [
            {
                "description": null, 
                "name": "x", 
                "type": "GColor8"
            }, 
            {
                "description": null, 
                "name": "y", 
                "type": "GColor8"
            }
        ], 
        "return_desc": null, 
        "returns": "bool", 
        "warning": null
    }, 
    "gcolor_legible_over": {
        "description": "<p>This method assists in improving the legibility of text on various background colors. It takes the background color for the region in question and computes a color for maximum legibility. </p>", 
        "kind": "fn", 
        "name": "gcolor_legible_over", 
        "params": [
            {
                "description": "<p>Background color for the region in question </p>", 
                "name": "background_color", 
                "type": "GColor8"
            }
        ], 
        "return_desc": "<p>A legible color for the given background color </p>", 
        "returns": "GColor8", 
        "warning": null
    }, 
    "gdraw_command_draw": {
        "description": "<p>Draw a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>GDrawCommand to draw </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_frame_draw": {
        "description": "<p>Draw a frame. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_frame_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The sequence from which the frame comes from (this is required) </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }, 
            {
                "description": "<p>Frame to draw </p>", 
                "name": "frame", 
                "type": "GDrawCommandFrame *"
            }, 
            {
                "description": "<p>Offset from draw context origin to draw the frame </p>", 
                "name": "offset", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_frame_get_command_list": {
        "description": "<p>Get the command list of the frame. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_frame_get_command_list", 
        "params": [
            {
                "description": "<p>GDrawCommandFrame from which to get the command list </p>", 
                "name": "frame", 
                "type": "GDrawCommandFrame *"
            }
        ], 
        "return_desc": "<p>command list </p>", 
        "returns": "GDrawCommandList *", 
        "warning": null
    }, 
    "gdraw_command_frame_get_duration": {
        "description": "<p>Get the duration of the frame. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_frame_get_duration", 
        "params": [
            {
                "description": "<p>GDrawCommandFrame from which to get the duration </p>", 
                "name": "frame", 
                "type": "GDrawCommandFrame *"
            }
        ], 
        "return_desc": "<p>duration of the frame in milliseconds </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "gdraw_command_frame_set_duration": {
        "description": "<p>Set the duration of the frame. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_frame_set_duration", 
        "params": [
            {
                "description": "<p>GDrawCommandFrame for which to set the duration </p>", 
                "name": "frame", 
                "type": "GDrawCommandFrame *"
            }, 
            {
                "description": "<p>duration of the frame in milliseconds </p>", 
                "name": "duration", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_get_fill_color": {
        "description": "<p>Get the fill color of a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_fill_color", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the fill color </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>fill color of the given GDrawCommand </p>", 
        "returns": "GColor", 
        "warning": null
    }, 
    "gdraw_command_get_hidden": {
        "description": "<p>Return whether a command is hidden. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_hidden", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the hidden status </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>true if command is hidden </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "gdraw_command_get_num_points": {
        "description": "<p>Get the number of points in a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_num_points", 
        "params": [
            {
                "description": null, 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": null, 
        "returns": "uint16_t", 
        "warning": null
    }, 
    "gdraw_command_get_path_open": {
        "description": "<p>Return whether a stroke command path is open. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_path_open", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the path open status </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>true if the path is open </p>", 
        "returns": "bool", 
        "warning": "<p>This only works for commands of type GDrawCommandPath and GDrawCommandPrecisePath </p>"
    }, 
    "gdraw_command_get_point": {
        "description": "<p>Get the value of a point in a command from the specified index. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_point", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get a point </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>The index to get the point for </p>", 
                "name": "point_idx", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": "<p>The point in the GDrawCommand specified by <code>point_idx</code> </p>", 
        "returns": "GPoint", 
        "warning": "<p>The index must be less than the number of points </p>"
    }, 
    "gdraw_command_get_radius": {
        "description": "<p>Get the radius of a circle command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_radius", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the circle radius </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>The radius in pixels if command is of type GDrawCommandCircle </p>", 
        "returns": "uint16_t", 
        "warning": "<p>this only works for commands of typeGDrawCommandCircle. </p>"
    }, 
    "gdraw_command_get_stroke_color": {
        "description": "<p>Get the stroke color of a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_stroke_color", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the stroke color </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>The stroke color of the given GDrawCommand </p>", 
        "returns": "GColor", 
        "warning": null
    }, 
    "gdraw_command_get_stroke_width": {
        "description": "<p>Get the stroke width of a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_stroke_width", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the stroke width </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>The stroke width of the given GDrawCommand </p>", 
        "returns": "uint8_t", 
        "warning": null
    }, 
    "gdraw_command_get_type": {
        "description": "<p>Get the command type. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_get_type", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to get the type </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }
        ], 
        "return_desc": "<p>The type of the given GDrawCommand </p>", 
        "returns": "GDrawCommandType", 
        "warning": null
    }, 
    "gdraw_command_image_clone": {
        "description": "<p>Creates a GDrawCommandImage as a copy from a given image. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_clone", 
        "params": [
            {
                "description": "<p>Image to copy. </p>", 
                "name": "image", 
                "type": "GDrawCommandImage *"
            }
        ], 
        "return_desc": "<p>cloned image or NULL if the operation failed </p>", 
        "returns": "GDrawCommandImage *", 
        "warning": null
    }, 
    "gdraw_command_image_create_with_resource": {
        "description": "<p>Creates a GDrawCommandImage from the specified resource (PDC file) </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_create_with_resource", 
        "params": [
            {
                "description": "<p>Resource containing data to load and create GDrawCommandImage from. </p>", 
                "name": "resource_id", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>GDrawCommandImage pointer if the resource was loaded, NULL otherwise </p>", 
        "returns": "GDrawCommandImage *", 
        "warning": null
    }, 
    "gdraw_command_image_destroy": {
        "description": "<p>Deletes the GDrawCommandImage structure and frees associated data. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_destroy", 
        "params": [
            {
                "description": "<p>Pointer to the image to free (delete) </p>", 
                "name": "image", 
                "type": "GDrawCommandImage *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_image_draw": {
        "description": "<p>Draw an image. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>Image to draw </p>", 
                "name": "image", 
                "type": "GDrawCommandImage *"
            }, 
            {
                "description": "<p>Offset from draw context origin to draw the image </p>", 
                "name": "offset", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_image_get_bounds_size": {
        "description": "<p>Get size of the bounding box surrounding all draw commands in the image. This bounding box can be used to set the graphics context or layer bounds when drawing the image. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_get_bounds_size", 
        "params": [
            {
                "description": "<p>GDrawCommandImage from which to get the bounding box size </p>", 
                "name": "image", 
                "type": "GDrawCommandImage *"
            }
        ], 
        "return_desc": "<p>bounding box size </p>", 
        "returns": "GSize", 
        "warning": null
    }, 
    "gdraw_command_image_get_command_list": {
        "description": "<p>Get the command list of the image. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_get_command_list", 
        "params": [
            {
                "description": "<p>GDrawCommandImage from which to get the command list </p>", 
                "name": "image", 
                "type": "GDrawCommandImage *"
            }
        ], 
        "return_desc": "<p>command list </p>", 
        "returns": "GDrawCommandList *", 
        "warning": null
    }, 
    "gdraw_command_image_set_bounds_size": {
        "description": "<p>Set size of the bounding box surrounding all draw commands in the image. This bounding box can be used to set the graphics context or layer bounds when drawing the image. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_image_set_bounds_size", 
        "params": [
            {
                "description": "<p>GDrawCommandImage for which to set the bounding box size </p>", 
                "name": "image", 
                "type": "GDrawCommandImage *"
            }, 
            {
                "description": "<p>bounding box size </p>", 
                "name": "size", 
                "type": "GSize"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_list_draw": {
        "description": "<p>Draw all commands in a command list. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_list_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>list of commands to draw </p>", 
                "name": "command_list", 
                "type": "GDrawCommandList *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_list_get_command": {
        "description": "<p>Get the command at the specified index. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_list_get_command", 
        "params": [
            {
                "description": "<p>GDrawCommandList from which to get a command </p>", 
                "name": "command_list", 
                "type": "GDrawCommandList *"
            }, 
            {
                "description": "<p>index of the command to get </p>", 
                "name": "command_idx", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": "<p>pointer to GDrawCommand at the specified index </p>", 
        "returns": "GDrawCommand *", 
        "warning": "<p>the specified index must be less than the number of commands in the list </p>"
    }, 
    "gdraw_command_list_get_num_commands": {
        "description": "<p>Get the number of commands in the list. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_list_get_num_commands", 
        "params": [
            {
                "description": "<p>GDrawCommandList from which to get the number of commands </p>", 
                "name": "command_list", 
                "type": "GDrawCommandList *"
            }
        ], 
        "return_desc": "<p>number of commands in command list </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "gdraw_command_list_iterate": {
        "description": "<p>Iterate over all commands in a command list. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_list_iterate", 
        "params": [
            {
                "description": "<p>GDrawCommandList over which to iterate </p>", 
                "name": "command_list", 
                "type": "GDrawCommandList *"
            }, 
            {
                "description": "<p>iterator callback </p>", 
                "name": "handle_command", 
                "type": "GDrawCommandListIteratorCb"
            }, 
            {
                "description": "<p>context pointer to be passed into the iterator callback </p>", 
                "name": "callback_context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_sequence_clone": {
        "description": "<p>Creates a GDrawCommandSequence as a copy from a given sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_clone", 
        "params": [
            {
                "description": "<p>Sequence to copy </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }
        ], 
        "return_desc": "<p>cloned sequence or NULL if the operation failed </p>", 
        "returns": "GDrawCommandSequence *", 
        "warning": null
    }, 
    "gdraw_command_sequence_create_with_resource": {
        "description": "<p>Creates a GDrawCommandSequence from the specified resource (PDC file) </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_create_with_resource", 
        "params": [
            {
                "description": "<p>Resource containing data to load and create GDrawCommandSequence from. </p>", 
                "name": "resource_id", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>GDrawCommandSequence pointer if the resource was loaded, NULL otherwise </p>", 
        "returns": "GDrawCommandSequence *", 
        "warning": null
    }, 
    "gdraw_command_sequence_destroy": {
        "description": "<p>Deletes the GDrawCommandSequence structure and frees associated data. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_destroy", 
        "params": [
            {
                "description": null, 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_sequence_get_bounds_size": {
        "description": "<p>Get the size of the bounding box surrounding all draw commands in the sequence. This bounding box can be used to set the graphics context or layer bounds when drawing the frames in the sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_get_bounds_size", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence from which to get the bounds </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }
        ], 
        "return_desc": "<p>bounding box size </p>", 
        "returns": "GSize", 
        "warning": null
    }, 
    "gdraw_command_sequence_get_frame_by_elapsed": {
        "description": "<p>Get the frame that should be shown after the specified amount of elapsed time The last frame will be returned if the elapsed time exceeds the total time. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_get_frame_by_elapsed", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence from which to get the frame </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }, 
            {
                "description": "<p>elapsed time in milliseconds </p>", 
                "name": "elapsed_ms", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>pointer to GDrawCommandFrame that should be displayed at the elapsed time </p>", 
        "returns": "GDrawCommandFrame *", 
        "warning": null
    }, 
    "gdraw_command_sequence_get_frame_by_index": {
        "description": "<p>Get the frame at the specified index. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_get_frame_by_index", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence from which to get the frame </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }, 
            {
                "description": "<p>Index of frame to get </p>", 
                "name": "index", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": "<p>pointer to GDrawCommandFrame at the specified index </p>", 
        "returns": "GDrawCommandFrame *", 
        "warning": null
    }, 
    "gdraw_command_sequence_get_num_frames": {
        "description": "<p>Get the number of frames in the sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_get_num_frames", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence from which to get the number of frames </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }
        ], 
        "return_desc": "<p>number of frames in the sequence </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "gdraw_command_sequence_get_play_count": {
        "description": "<p>Get the play count of the sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_get_play_count", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence from which to get the play count </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }
        ], 
        "return_desc": "<p>play count of sequence </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "gdraw_command_sequence_get_total_duration": {
        "description": "<p>Get the total duration of the sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_get_total_duration", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence from which to get the total duration </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }
        ], 
        "return_desc": "<p>total duration of the sequence in milliseconds </p>", 
        "returns": "uint32_t", 
        "warning": null
    }, 
    "gdraw_command_sequence_set_bounds_size": {
        "description": "<p>Set size of the bounding box surrounding all draw commands in the sequence. This bounding box can be used to set the graphics context or layer bounds when drawing the frames in the sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_set_bounds_size", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence for which to set the bounds </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }, 
            {
                "description": "<p>bounding box size </p>", 
                "name": "size", 
                "type": "GSize"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_sequence_set_play_count": {
        "description": "<p>Set the play count of the sequence. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_sequence_set_play_count", 
        "params": [
            {
                "description": "<p>GDrawCommandSequence for which to set the play count </p>", 
                "name": "sequence", 
                "type": "GDrawCommandSequence *"
            }, 
            {
                "description": "<p>play count </p>", 
                "name": "play_count", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_set_fill_color": {
        "description": "<p>Set the fill color of a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_fill_color", 
        "params": [
            {
                "description": "<p>ref DrawCommand for which to set the fill color </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>GColor to set for the fill </p>", 
                "name": "fill_color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_set_hidden": {
        "description": "<p>Set a command as hidden. This command will not be drawn when <code>gdraw_command_draw</code> is called with this command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_hidden", 
        "params": [
            {
                "description": "<p>GDrawCommand for which to set the hidden status </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>true if command should be hidden </p>", 
                "name": "hidden", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_set_path_open": {
        "description": "<p>Set the path of a stroke command to be open. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_path_open", 
        "params": [
            {
                "description": "<p>GDrawCommand for which to set the path open status </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>true if path should be hidden </p>", 
                "name": "path_open", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This only works for commands of type GDrawCommandPath and GDrawCommandPrecisePath </p>"
    }, 
    "gdraw_command_set_point": {
        "description": "<p>Set the value of the point in a command at the specified index. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_point", 
        "params": [
            {
                "description": "<p>GDrawCommand for which to set the value of a point </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>Index of the point to set the value for </p>", 
                "name": "point_idx", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>new point value to set </p>", 
                "name": "point", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_set_radius": {
        "description": "<p>Set the radius of a circle command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_radius", 
        "params": [
            {
                "description": "<p>GDrawCommand from which to set the circle radius </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>The radius to set for the circle. </p>", 
                "name": "radius", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This only works for commands of type GDrawCommandCircle </p>"
    }, 
    "gdraw_command_set_stroke_color": {
        "description": "<p>Set the stroke color of a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_stroke_color", 
        "params": [
            {
                "description": "<p>GDrawCommand for which to set the stroke color </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>GColor to set for the stroke </p>", 
                "name": "stroke_color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gdraw_command_set_stroke_width": {
        "description": "<p>Set the stroke width of a command. </p>", 
        "kind": "fn", 
        "name": "gdraw_command_set_stroke_width", 
        "params": [
            {
                "description": "<p>GDrawCommand for which to set the stroke width </p>", 
                "name": "command", 
                "type": "GDrawCommand *"
            }, 
            {
                "description": "<p>stroke width to set for the command </p>", 
                "name": "stroke_width", 
                "type": "uint8_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gmtime": {
        "description": "<p>convert the time value pointed at by clock to a struct tm which contains the time expressed in Coordinated Universal Time (UTC) </p>", 
        "kind": "fn", 
        "name": "gmtime", 
        "params": [
            {
                "description": "<p>A pointer to an object of type <code>time_t</code> that contains a time value </p>", 
                "name": "timep", 
                "type": "const time_t *"
            }
        ], 
        "return_desc": "<p>A pointer to a struct tm containing Coordinated Universal Time (UTC) </p>", 
        "returns": "struct tm *", 
        "warning": null
    }, 
    "gpath_create": {
        "description": "<p>Values after initialization:<ul><li><p><code>num_points</code> and points pointer: copied from the GPathInfo.</p></li><li><p>rotation: 0</p></li><li><p>offset: (0, 0) </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "gpath_create", 
        "params": [
            {
                "description": null, 
                "name": "init", 
                "type": "const GPathInfo *"
            }
        ], 
        "return_desc": "<p>A pointer to the GPath. NULL if the GPath could not be created </p>", 
        "returns": "GPath *", 
        "warning": null
    }, 
    "gpath_destroy": {
        "description": "<p>Free a dynamically allocated gpath created with <code>gpath_create()</code> </p>", 
        "kind": "fn", 
        "name": "gpath_destroy", 
        "params": [
            {
                "description": null, 
                "name": "gpath", 
                "type": "GPath *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gpath_draw_filled": {
        "description": "<p>Draws the fill of a path into a graphics context, using the current fill color, relative to the drawing area as set up by the layering system. </p>", 
        "kind": "fn", 
        "name": "gpath_draw_filled", 
        "params": [
            {
                "description": "<p>The graphics context to draw into </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The path to fill </p>", 
                "name": "path", 
                "type": "GPath *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gpath_draw_outline": {
        "description": "<p>Draws the outline of a path into a graphics context, using the current stroke color and width, relative to the drawing area as set up by the layering system. The first and last points in the path do have a line between them. </p>", 
        "kind": "fn", 
        "name": "gpath_draw_outline", 
        "params": [
            {
                "description": "<p>The graphics context to draw into </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The path to draw </p>", 
                "name": "path", 
                "type": "GPath *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gpath_draw_outline_open": {
        "description": "<p>Draws an open outline of a path into a graphics context, using the current stroke color and width, relative to the drawing area as set up by the layering system. The first and last points in the path do not have a line between them. </p>", 
        "kind": "fn", 
        "name": "gpath_draw_outline_open", 
        "params": [
            {
                "description": "<p>The graphics context to draw into </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The path to draw </p>", 
                "name": "path", 
                "type": "GPath *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gpath_move_to": {
        "description": "<p>Sets the absolute offset of the path. The current translation will be replaced by the specified offset. </p>", 
        "kind": "fn", 
        "name": "gpath_move_to", 
        "params": [
            {
                "description": "<p>The path onto which to set the translation </p>", 
                "name": "path", 
                "type": "GPath *"
            }, 
            {
                "description": "<p>The point which is used as the vector for the translation. </p>", 
                "name": "point", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Setting a translation does not affect the points in the path directly. The translation is applied on-the-fly during drawing, either using <code>gpath_draw_filled()</code> or <code>gpath_draw_outline()</code>. </p>"
    }, 
    "gpath_rotate_to": {
        "description": "<p>Sets the absolute rotation of the path. The current rotation will be replaced by the specified angle. </p>", 
        "kind": "fn", 
        "name": "gpath_rotate_to", 
        "params": [
            {
                "description": "<p>The path onto which to set the rotation </p>", 
                "name": "path", 
                "type": "GPath *"
            }, 
            {
                "description": "<p>The absolute angle of the rotation. The angle is represented in the same way that is used with <code>sin_lookup()</code>. See <code>TRIG_MAX_ANGLE</code> for more information. </p>", 
                "name": "angle", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Setting a rotation does not affect the points in the path directly. The rotation is applied on-the-fly during drawing, either using <code>gpath_draw_filled()</code> or <code>gpath_draw_outline()</code>. </p>"
    }, 
    "gpoint_equal": {
        "description": "<p>Tests whether 2 points are equal. </p>", 
        "kind": "fn", 
        "name": "gpoint_equal", 
        "params": [
            {
                "description": "<p>Pointer to the first point </p>", 
                "name": "point_a", 
                "type": "const GPoint *const"
            }, 
            {
                "description": "<p>Pointer to the second point </p>", 
                "name": "point_b", 
                "type": "const GPoint *const"
            }
        ], 
        "return_desc": "<p>true if both points are equal, false if not. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "gpoint_from_polar": {
        "description": "<p>Calculates a GPoint located at the angle provided on the perimeter of a circle defined by the provided GRect. </p>", 
        "kind": "fn", 
        "name": "gpoint_from_polar", 
        "params": [
            {
                "description": "<p>The reference rectangle to derive the center point and radius (see <code>scale_mode</code>). </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>Determines how rect will be used to derive the center point and radius. </p>", 
                "name": "scale_mode", 
                "type": "GOvalScaleMode"
            }, 
            {
                "description": "<p>The angle at which the point on the circle's perimeter should be calculated. Use <code>DEG_TO_TRIGANGLE</code> to easily convert degrees to the appropriate value. </p>", 
                "name": "angle", 
                "type": "int32_t"
            }
        ], 
        "return_desc": "<p>The point on the circle's perimeter. </p>", 
        "returns": "GPoint", 
        "warning": null
    }, 
    "graphics_capture_frame_buffer": {
        "description": "<p>A shortcut to capture the framebuffer in the native format of the watch. </p>", 
        "kind": "fn", 
        "name": "graphics_capture_frame_buffer", 
        "params": [
            {
                "description": null, 
                "name": "ctx", 
                "type": "GContext *"
            }
        ], 
        "return_desc": null, 
        "returns": "GBitmap *", 
        "warning": null
    }, 
    "graphics_capture_frame_buffer_format": {
        "description": "<p>Captures the frame buffer for direct access, using the given format. Graphics functions will not affect the frame buffer while it is captured. The frame buffer is released when <code>graphics_release_frame_buffer</code> is called. The frame buffer must be released before the end of a layer's .<code>update_proc</code> for the layer to be drawn properly. </p>", 
        "kind": "fn", 
        "name": "graphics_capture_frame_buffer_format", 
        "params": [
            {
                "description": "<p>The graphics context providing the frame buffer </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The format in which the framebuffer should be captured. Supported formats are GBitmapFormat1Bit and GBitmapFormat8Bit. </p>", 
                "name": "format", 
                "type": "GBitmapFormat"
            }
        ], 
        "return_desc": "<p>A pointer to the frame buffer. NULL if failed. </p>", 
        "returns": "GBitmap *", 
        "warning": "<p>When writing to the frame buffer, you should respect the visible boundaries of a window on the screen. Use <code>layer_get_frame</code>(<code>window_get_root_layer</code>(window)).origin to obtain its position relative to the frame buffer. For example, drawing to (5, 5) in the frame buffer while the window is transitioning to the left with its origin at (-20, 0) would effectively draw that point at (25, 5) relative to the window. For this reason you should consider the window's root layer frame when calculating drawing coordinates. </p>"
    }, 
    "graphics_context_set_antialiased": {
        "description": "<p>Sets whether antialiasing is applied to stroke drawing. </p>", 
        "kind": "fn", 
        "name": "graphics_context_set_antialiased", 
        "params": [
            {
                "description": "<p>The graphics context onto which to set the antialiasing </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>True = antialiasing enabled, False = antialiasing disabled </p>", 
                "name": "enable", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Default value is true. </p>"
    }, 
    "graphics_context_set_compositing_mode": {
        "description": "<p>Sets the current bitmap compositing mode of the graphics context. </p>", 
        "kind": "fn", 
        "name": "graphics_context_set_compositing_mode", 
        "params": [
            {
                "description": "<p>The graphics context onto which to set the compositing mode </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The new compositing mode </p>", 
                "name": "mode", 
                "type": "GCompOp"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>At the moment, this only affects the bitmaps drawing operations  <code>graphics_draw_bitmap_in_rect()</code>, <code>graphics_draw_rotated_bitmap</code>, and anything that uses those APIs , but it currently does not affect the filling or stroking operations. </p>"
    }, 
    "graphics_context_set_fill_color": {
        "description": "<p>Sets the current fill color of the graphics context. </p>", 
        "kind": "fn", 
        "name": "graphics_context_set_fill_color", 
        "params": [
            {
                "description": "<p>The graphics context onto which to set the fill color </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The new fill color </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_context_set_stroke_color": {
        "description": "<p>Sets the current stroke color of the graphics context. </p>", 
        "kind": "fn", 
        "name": "graphics_context_set_stroke_color", 
        "params": [
            {
                "description": "<p>The graphics context onto which to set the stroke color </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The new stroke color </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_context_set_stroke_width": {
        "description": "<p>Sets the width of the stroke for drawing routines. </p>", 
        "kind": "fn", 
        "name": "graphics_context_set_stroke_width", 
        "params": [
            {
                "description": "<p>The graphics context onto which to set the stroke width </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>Width in pixels of the stroke. </p>", 
                "name": "stroke_width", 
                "type": "uint8_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If stroke width of zero is passed, it will be ignored and will not change the value stored in GContext. Currently, only odd <code>stroke_width</code> values are supported. If an even value is passed in, the value will be stored as is, but the drawing routines will round down to the previous integral value when drawing. Default value is 1. </p>"
    }, 
    "graphics_context_set_text_color": {
        "description": "<p>Sets the current text color of the graphics context. </p>", 
        "kind": "fn", 
        "name": "graphics_context_set_text_color", 
        "params": [
            {
                "description": "<p>The graphics context onto which to set the text color </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The new text color </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_arc": {
        "description": "<p>Draws a line arc clockwise between <code>angle_start</code> and <code>angle_end</code>, where 0\u00b0 is the top of the circle. If the difference between <code>angle_start</code> and <code>angle_end</code> is greater than 360\u00b0, a full circle will be drawn. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_arc", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw using the current stroke color and antialiasing setting. </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The reference rectangle to derive the center point and radius (see <code>scale_mode</code>). </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>Determines how rect will be used to derive the center point and radius. </p>", 
                "name": "scale_mode", 
                "type": "GOvalScaleMode"
            }, 
            {
                "description": "<p>Radial starting angle. Use <code>DEG_TO_TRIGANGLE</code> to easily convert degrees to the appropriate value. </p>", 
                "name": "angle_start", 
                "type": "int32_t"
            }, 
            {
                "description": "<p>Radial finishing angle. If smaller than <code>angle_start</code>, nothing will be drawn. </p>", 
                "name": "angle_end", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_bitmap_in_rect": {
        "description": "<p>Draws a bitmap into the graphics context, inside the specified rectangle. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_bitmap_in_rect", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw the bitmap </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The bitmap to draw </p>", 
                "name": "bitmap", 
                "type": "const GBitmap *"
            }, 
            {
                "description": "<p>The rectangle in which to draw the bitmap </p>", 
                "name": "rect", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the size of rect is smaller than the size of the bitmap, the bitmap will be clipped on right and bottom edges. If the size of rect is larger than the size of the bitmap, the bitmap will be tiled automatically in both horizontal and vertical directions, effectively drawing a repeating pattern. </p>"
    }, 
    "graphics_draw_circle": {
        "description": "<p>Draws the outline of a circle in the current stroke color. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_circle", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The center point of the circle </p>", 
                "name": "p", 
                "type": "GPoint"
            }, 
            {
                "description": "<p>The radius in pixels </p>", 
                "name": "radius", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_line": {
        "description": "<p>Draws line in the current stroke color, current stroke width and AA flag. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_line", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The starting point of the line </p>", 
                "name": "p0", 
                "type": "GPoint"
            }, 
            {
                "description": "<p>The ending point of the line </p>", 
                "name": "p1", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_pixel": {
        "description": "<p>Draws a pixel at given point in the current stroke color. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_pixel", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The point at which to draw the pixel </p>", 
                "name": "point", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_rect": {
        "description": "<p>Draws a 1-pixel wide rectangle outline in the current stroke color. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_rect", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The rectangle for which to draw the outline </p>", 
                "name": "rect", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_rotated_bitmap": {
        "description": "<p>Draws a rotated bitmap with a memory-sensitive 2x anti-aliasing technique (using ray-finding instead of super-sampling), which is thresholded into a b/w bitmap for 1-bit and color blended for 8-bit. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_rotated_bitmap", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The source bitmap to draw </p>", 
                "name": "src", 
                "type": "GBitmap *"
            }, 
            {
                "description": "<p>Instance center (single point unaffected by rotation) relative to source bitmap </p>", 
                "name": "src_ic", 
                "type": "GPoint"
            }, 
            {
                "description": "<p>Angle of rotation. Rotation is an integer between 0 (no rotation) and <code>TRIG_MAX_ANGLE</code> (360 degree rotation). Use <code>DEG_TO_TRIGANGLE</code> to easily convert degrees to the appropriate value. </p>", 
                "name": "rotation", 
                "type": "int"
            }, 
            {
                "description": "<p>Where to draw the instance center of the rotated bitmap in the context. </p>", 
                "name": "dest_ic", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This API has performance limitations that can degrade user experience. Use sparingly. </p>"
    }, 
    "graphics_draw_round_rect": {
        "description": "<p>Draws the outline of a rounded rectangle in the current stroke color. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_round_rect", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The rectangle defining the dimensions of the rounded rectangle to draw </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>The corner radius in pixels </p>", 
                "name": "radius", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_draw_text": {
        "description": "<p>Draw text into the current graphics context, using the context's current text color. The text will be drawn inside a box with the specified dimensions and configuration, with clipping occuring automatically. </p>", 
        "kind": "fn", 
        "name": "graphics_draw_text", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The zero terminated UTF-8 string to draw </p>", 
                "name": "text", 
                "type": "const char *"
            }, 
            {
                "description": "<p>The font in which the text should be set </p>", 
                "name": "font", 
                "type": "GFont const"
            }, 
            {
                "description": "<p>The bounding box in which to draw the text. The first line of text will be drawn against the top of the box. </p>", 
                "name": "box", 
                "type": "const GRect"
            }, 
            {
                "description": "<p>The overflow behavior, in case the text is larger than what fits inside the box. </p>", 
                "name": "overflow_mode", 
                "type": "const GTextOverflowMode"
            }, 
            {
                "description": "<p>The horizontal alignment of the text </p>", 
                "name": "alignment", 
                "type": "const GTextAlignment"
            }, 
            {
                "description": "<p>Optional text attributes to describe the characteristics of the text </p>", 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_fill_circle": {
        "description": "<p>Fills a circle in the current fill color. </p>", 
        "kind": "fn", 
        "name": "graphics_fill_circle", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The center point of the circle </p>", 
                "name": "p", 
                "type": "GPoint"
            }, 
            {
                "description": "<p>The radius in pixels </p>", 
                "name": "radius", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_fill_radial": {
        "description": "<p>Fills a circle clockwise between <code>angle_start</code> and <code>angle_end</code>, where 0\u00b0 is the top of the circle. If the difference between <code>angle_start</code> and <code>angle_end</code> is greater than 360\u00b0, a full circle will be drawn and filled. If <code>angle_start</code> is greater than <code>angle_end</code> nothing will be drawn. </p>", 
        "kind": "fn", 
        "name": "graphics_fill_radial", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw using the current fill color and antialiasing setting. </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The reference rectangle to derive the center point and radius (see scale). </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>Determines how rect will be used to derive the center point and radius. </p>", 
                "name": "scale_mode", 
                "type": "GOvalScaleMode"
            }, 
            {
                "description": "<p>Describes how thick in pixels the radial will be drawn towards its center measured from the outside. </p>", 
                "name": "inset_thickness", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>Radial starting angle. Use <code>DEG_TO_TRIGANGLE</code> to easily convert degrees to the appropriate value. </p>", 
                "name": "angle_start", 
                "type": "int32_t"
            }, 
            {
                "description": "<p>Radial finishing angle. If smaller than <code>angle_start</code>, nothing will be drawn. </p>", 
                "name": "angle_end", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>A simple example is drawing a 'Pacman' shape, with a starting angle of -225\u00b0, and ending angle of 45\u00b0. By setting <code>inset_thickness</code> to a non-zero value (such as 30) this example will produce the letter C. </p>"
    }, 
    "graphics_fill_rect": {
        "description": "<p>Fills a rectangle with the current fill color, optionally rounding all or a selection of its corners. </p>", 
        "kind": "fn", 
        "name": "graphics_fill_rect", 
        "params": [
            {
                "description": "<p>The destination graphics context in which to draw </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The rectangle to fill </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>The rounding radius of the corners in pixels (maximum is 8 pixels) </p>", 
                "name": "corner_radius", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>Bitmask of the corners that need to be rounded. </p>", 
                "name": "corner_mask", 
                "type": "GCornerMask"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_frame_buffer_is_captured": {
        "description": "<p>Whether or not the frame buffer has been captured by <code>graphics_capture_frame_buffer</code>. Graphics functions will not affect the frame buffer until it has been released by <code>graphics_release_frame_buffer</code>. </p>", 
        "kind": "fn", 
        "name": "graphics_frame_buffer_is_captured", 
        "params": [
            {
                "description": "<p>The graphics context providing the frame buffer </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }
        ], 
        "return_desc": "<p>True if the frame buffer has been captured </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "graphics_release_frame_buffer": {
        "description": "<p>If buffer does not point to the address previously returned by <code>graphics_capture_frame_buffer</code> the frame buffer will not be released.", 
        "kind": "fn", 
        "name": "graphics_release_frame_buffer", 
        "params": [
            {
                "description": "<p>The graphics context providing the frame buffer </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The pointer to frame buffer </p>", 
                "name": "buffer", 
                "type": "GBitmap *"
            }
        ], 
        "return_desc": "<p>True if the frame buffer was released successfully </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "graphics_text_attributes_create": {
        "description": "<p>Creates an instance of GTextAttributes for advanced control when rendering text. </p>", 
        "kind": "fn", 
        "name": "graphics_text_attributes_create", 
        "params": [], 
        "return_desc": "<p>New instance of GTextAttributes </p>", 
        "returns": "GTextAttributes *", 
        "warning": null
    }, 
    "graphics_text_attributes_destroy": {
        "description": "<p>Destroys a previously created instance of GTextAttributes. </p>", 
        "kind": "fn", 
        "name": "graphics_text_attributes_destroy", 
        "params": [
            {
                "description": null, 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_text_attributes_enable_paging": {
        "description": "<p>Enables paging and locks the text flow calculation to a fixed point on the screen. </p>", 
        "kind": "fn", 
        "name": "graphics_text_attributes_enable_paging", 
        "params": [
            {
                "description": "<p>Attributes for which to enable paging and locked content origin </p>", 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }, 
            {
                "description": "<p>Absolute coordinate on the screen where the text content starts before an animation or scrolling takes place. Usually the frame's origin of a layer in screen coordinates. </p>", 
                "name": "content_origin_on_screen", 
                "type": "GPoint"
            }, 
            {
                "description": "<p>Rectangle in absolute coordinates on the screen that describes where text content pages. Usually the container's absolute frame in screen coordinates. </p>", 
                "name": "paging_on_screen", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_text_attributes_enable_screen_text_flow": {
        "description": "<p>Enables text flow that follows the boundaries of the screen. </p>", 
        "kind": "fn", 
        "name": "graphics_text_attributes_enable_screen_text_flow", 
        "params": [
            {
                "description": "<p>The attributes for which text flow should be enabled </p>", 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }, 
            {
                "description": "<p>Additional amount of pixels to inset to the inside of the screen for text flow calculation. Can be zero. </p>", 
                "name": "inset", 
                "type": "uint8_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_text_attributes_restore_default_paging": {
        "description": "<p>Restores paging and locked content origin to the defaults. </p>", 
        "kind": "fn", 
        "name": "graphics_text_attributes_restore_default_paging", 
        "params": [
            {
                "description": "<p>The attributes for which to restore paging and locked content origin </p>", 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_text_attributes_restore_default_text_flow": {
        "description": "<p>Restores text flow to the rectangular default. </p>", 
        "kind": "fn", 
        "name": "graphics_text_attributes_restore_default_text_flow", 
        "params": [
            {
                "description": "<p>The attributes for which to disable text flow </p>", 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "graphics_text_layout_get_content_size": {
        "description": "<p>Obtain the maximum size that a text with given font, overflow mode and alignment occupies within a given rectangular constraint. </p>", 
        "kind": "fn", 
        "name": "graphics_text_layout_get_content_size", 
        "params": [
            {
                "description": "<p>The zero terminated UTF-8 string for which to calculate the size </p>", 
                "name": "text", 
                "type": "const char *"
            }, 
            {
                "description": "<p>The font in which the text should be set while calculating the size </p>", 
                "name": "font", 
                "type": "GFont const"
            }, 
            {
                "description": "<p>The bounding box in which the text should be constrained </p>", 
                "name": "box", 
                "type": "const GRect"
            }, 
            {
                "description": "<p>The overflow behavior, in case the text is larger than what fits inside the box. </p>", 
                "name": "overflow_mode", 
                "type": "const GTextOverflowMode"
            }, 
            {
                "description": "<p>The horizontal alignment of the text </p>", 
                "name": "alignment", 
                "type": "const GTextAlignment"
            }
        ], 
        "return_desc": "<p>The maximum size occupied by the text </p>", 
        "returns": "GSize", 
        "warning": null
    }, 
    "graphics_text_layout_get_content_size_with_attributes": {
        "description": "<p>Obtain the maximum size that a text with given font, overflow mode and alignment occupies within a given rectangular constraint. </p>", 
        "kind": "fn", 
        "name": "graphics_text_layout_get_content_size_with_attributes", 
        "params": [
            {
                "description": "<p>The zero terminated UTF-8 string for which to calculate the size </p>", 
                "name": "text", 
                "type": "const char *"
            }, 
            {
                "description": "<p>The font in which the text should be set while calculating the size </p>", 
                "name": "font", 
                "type": "GFont const"
            }, 
            {
                "description": "<p>The bounding box in which the text should be constrained </p>", 
                "name": "box", 
                "type": "const GRect"
            }, 
            {
                "description": "<p>The overflow behavior, in case the text is larger than what fits inside the box. </p>", 
                "name": "overflow_mode", 
                "type": "const GTextOverflowMode"
            }, 
            {
                "description": "<p>The horizontal alignment of the text </p>", 
                "name": "alignment", 
                "type": "const GTextAlignment"
            }, 
            {
                "description": "<p>Optional text attributes to describe the characteristics of the text </p>", 
                "name": "text_attributes", 
                "type": "GTextAttributes *"
            }
        ], 
        "return_desc": "<p>The maximum size occupied by the text </p>", 
        "returns": "GSize", 
        "warning": null
    }, 
    "grect_align": {
        "description": "<p>Aligns one rectangle within another rectangle, using an alignment parameter. The relative coordinate systems of both rectangles are assumed to be the same. When clip is true, rect is also clipped by the constraint. </p>", 
        "kind": "fn", 
        "name": "grect_align", 
        "params": [
            {
                "description": "<p>The aligned and optionally clipped rectangle </p>", 
                "name": "rect", 
                "type": "GRect *"
            }, 
            {
                "description": "<p>The rectangle in which to align rect </p>", 
                "name": "inside_rect", 
                "type": "const GRect *"
            }, 
            {
                "description": "<p>Determines the alignment of rect within <code>inside_rect</code> by specifying what edges of should overlap. </p>", 
                "name": "alignment", 
                "type": "const GAlign"
            }, 
            {
                "description": "<p>Determines whether rect should be trimmed using the edges of <code>inside_rect</code> in case rect extends outside of the area that <code>inside_rect</code> covers after the alignment. </p>", 
                "name": "clip", 
                "type": "const bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "grect_center_point": {
        "description": "<p>Convenience function to compute the center-point of a given rectangle. This is equal to (rect->x + rect->width / 2, rect->y + rect->height / 2). </p>", 
        "kind": "fn", 
        "name": "grect_center_point", 
        "params": [
            {
                "description": "<p>The rectangle for which to calculate the center point. </p>", 
                "name": "rect", 
                "type": "const GRect *"
            }
        ], 
        "return_desc": "<p>The point at the center of rect </p>", 
        "returns": "GPoint", 
        "warning": null
    }, 
    "grect_centered_from_polar": {
        "description": "<p>Calculates a rectangle centered on the perimeter of a circle at a given angle. Use this to construct rectangles that follow the perimeter of a circle as an input for <code>graphics_fill_radial_internal</code> or <code>graphics_draw_arc_internal</code>, e.g. to draw circles every 30 degrees on a watchface. </p>", 
        "kind": "fn", 
        "name": "grect_centered_from_polar", 
        "params": [
            {
                "description": "<p>The reference rectangle to derive the circle's center point and radius (see <code>scale_mode</code>). </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>Determines how rect will be used to derive the circle's center point and radius. </p>", 
                "name": "scale_mode", 
                "type": "GOvalScaleMode"
            }, 
            {
                "description": "<p>The angle at which the point on the circle's perimeter should be calculated. Use <code>DEG_TO_TRIGANGLE</code> to easily convert degrees to the appropriate value. </p>", 
                "name": "angle", 
                "type": "int32_t"
            }, 
            {
                "description": "<p>Width and height of the desired rectangle. </p>", 
                "name": "size", 
                "type": "GSize"
            }
        ], 
        "return_desc": "<p>The rectangle centered on the circle's perimeter. </p>", 
        "returns": "GRect", 
        "warning": null
    }, 
    "grect_clip": {
        "description": "<p>Trim one rectangle using the edges of a second rectangle. </p>", 
        "kind": "fn", 
        "name": "grect_clip", 
        "params": [
            {
                "description": "<p>The clipped rectangle. </p>", 
                "name": "rect_to_clip", 
                "type": "GRect *const"
            }, 
            {
                "description": "<p>The rectangle of which the edges will serve as \"scissors\" in order to trim <code>rect_to_clip</code>. </p>", 
                "name": "rect_clipper", 
                "type": "const GRect *const"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "grect_contains_point": {
        "description": "<p>Tests whether a rectangle contains a point. </p>", 
        "kind": "fn", 
        "name": "grect_contains_point", 
        "params": [
            {
                "description": "<p>The rectangle </p>", 
                "name": "rect", 
                "type": "const GRect *"
            }, 
            {
                "description": "<p>The point </p>", 
                "name": "point", 
                "type": "const GPoint *"
            }
        ], 
        "return_desc": "<p>true if the rectangle contains the point, or false if it does not. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "grect_crop": {
        "description": "<p>Reduce the width and height of a rectangle by insetting each of the edges with a fixed inset. The returned rectangle will be centered relative to the input rectangle. </p>", 
        "kind": "fn", 
        "name": "grect_crop", 
        "params": [
            {
                "description": "<p>The rectangle that will be inset </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>The inset by which each of the rectangle will be inset. A positive inset value results in a smaller rectangle, while negative inset value results in a larger rectangle. </p>", 
                "name": "crop_size_px", 
                "type": "const int32_t"
            }
        ], 
        "return_desc": "<p>The cropped rectangle. </p>", 
        "returns": "GRect", 
        "warning": "<p>The function will trip an assertion if the crop yields a rectangle with negative width or height. </p>"
    }, 
    "grect_equal": {
        "description": "<p>Tests whether 2 rectangles are equal. </p>", 
        "kind": "fn", 
        "name": "grect_equal", 
        "params": [
            {
                "description": "<p>Pointer to the first rectangle </p>", 
                "name": "rect_a", 
                "type": "const GRect *const"
            }, 
            {
                "description": "<p>Pointer to the second rectangle </p>", 
                "name": "rect_b", 
                "type": "const GRect *const"
            }
        ], 
        "return_desc": "<p>true if both rectangles are equal, false if not. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "grect_inset": {
        "description": "<p><p>Use this function in together with the GEdgeInsets macro <code>GRectr_inset_all_sides</code>=<code>grect_inset</code>(r,GEdgeInsets(10));\n<code>GRectr_inset_vertical_horizontal</code>=<code>grect_inset</code>(r,GEdgeInsets(10,20));\n<code>GRectr_expand_top_right_shrink_bottom_left</code>=<code>grect_inset</code>(r,GEdgeInsets(-10,-10,10,10));\n </p>\n</p>", 
        "kind": "fn", 
        "name": "grect_inset", 
        "params": [
            {
                "description": "<p>The rectangle that will be inset </p>", 
                "name": "rect", 
                "type": "GRect"
            }, 
            {
                "description": "<p>The insets that will be applied </p>", 
                "name": "insets", 
                "type": "GEdgeInsets"
            }
        ], 
        "return_desc": "<p>The resulting rectangle </p>", 
        "returns": "GRect", 
        "warning": "<p>The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a GRectZero is returned. </p>"
    }, 
    "grect_is_empty": {
        "description": "<p>Tests whether the size of the rectangle is (0, 0). </p>", 
        "kind": "fn", 
        "name": "grect_is_empty", 
        "params": [
            {
                "description": "<p>Pointer to the rectangle </p>", 
                "name": "rect", 
                "type": "const GRect *const"
            }
        ], 
        "return_desc": "<p>true if the rectangle its size is (0, 0), or false if not. </p>", 
        "returns": "bool", 
        "warning": "<p>If the width and/or height of a rectangle is negative, this function will return true! </p>"
    }, 
    "grect_standardize": {
        "description": "<p>Converts a rectangle's values so that the components of its size (width and/or height) are both positive. In the width and/or height are negative, the origin will offset, so that the final rectangle overlaps with the original. For example, a GRect with size (-10, -5) and origin (20, 20), will be standardized to size (10, 5) and origin (10, 15). </p>", 
        "kind": "fn", 
        "name": "grect_standardize", 
        "params": [
            {
                "description": "<p>The standardized rectangle. </p>", 
                "name": "rect", 
                "type": "GRect *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "gsize_equal": {
        "description": "<p>Tests whether 2 sizes are equal. </p>", 
        "kind": "fn", 
        "name": "gsize_equal", 
        "params": [
            {
                "description": "<p>Pointer to the first size </p>", 
                "name": "size_a", 
                "type": "const GSize *"
            }, 
            {
                "description": "<p>Pointer to the second size </p>", 
                "name": "size_b", 
                "type": "const GSize *"
            }
        ], 
        "return_desc": "<p>true if both sizes are equal, false if not. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "health_service_activities_iterate": {
        "description": "<p>Iterates backwards or forward within a given time span to list all recorded activities. For example, this can be used to find the last recorded sleep phase or all deep sleep phases in a given time range. Any activity that overlaps with <code>time_start</code> and <code>time_end</code> will be included, even if the start time starts before <code>time_start</code> or end time ends after <code>time_end</code>. </p>", 
        "kind": "fn", 
        "name": "health_service_activities_iterate", 
        "params": [
            {
                "description": "<p>A bitmask containing set of activities you are interested in. </p>", 
                "name": "activity_mask", 
                "type": "HealthActivityMask"
            }, 
            {
                "description": "<p>UTC time of the earliest time you are interested in. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>UTC time of the latest time you are interested in. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }, 
            {
                "description": "<p>The direction in which to iterate. </p>", 
                "name": "direction", 
                "type": "HealthIterationDirection"
            }, 
            {
                "description": "<p>Developer-supplied callback that is called for each activity iterated over. </p>", 
                "name": "callback", 
                "type": "HealthActivityIteratorCB"
            }, 
            {
                "description": "<p>Developer-supplied context pointer that is passed to the callback. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "health_service_aggregate_averaged": {
        "description": "<p>The aggregation function aggregation is applied to the metric metric over the given time range <code>time_start</code> to <code>time_end</code> first, and then an average is computed based on the passed in scope.</p><p>For example, if you want to get the average number of steps taken from 12 AM (midnight) to 9 AM across all days you would specify: <code>time_t</code> <code>time_start</code> = <code>time_start_of_today()</code>; <code>time_t</code> <code>time_end</code> = <code>time_start</code> + (9 * <code>SECONDS_PER_HOUR</code>); HealthValue value = <code>health_service_aggregate_averaged</code>(HealthMetricStepCount, <code>time_start</code>, <code>time_end</code>, HealthAggregationSum, HealthServiceTimeScopeDaily);</p><p>If you want to compute the average heart rate on Mondays and today is a Monday, you would specify: <code>time_t</code> <code>time_start</code> = <code>time_start_of_today()</code>, <code>time_t</code> <code>time_end</code> = <code>time_start</code> + <code>SECONDS_PER_DAY</code>, HealthValue value = <code>health_service_aggregate_averaged</code>(HealthMetricHeartRateBPM, <code>time_start</code>, <code>time_end</code>, HealthAggregationAvg, HealthServiceTimeScopeWeekly); To get the average of the minimum heart rate seen on Mondays for example, you would instead pass in HealthAggregationMin</p><p>Certain HealthAggregation operations are only applicable to certain types of metrics. See the notes above on HealthAggregation for details. Use <code>health_service_metric_aggregate_averaged_accessible</code> to check for applicability at run time.</p><p>", 
        "kind": "fn", 
        "name": "health_service_aggregate_averaged", 
        "params": [
            {
                "description": "<p>Which HealthMetric to query. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>UTC time of the start of the query interval. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>UTC time of the end of the query interval. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }, 
            {
                "description": "<p>the aggregation function to perform on the metric. This operation is performed across the passed in time range <code>time_start</code> to <code>time_end</code>. </p>", 
                "name": "aggregation", 
                "type": "HealthAggregation"
            }, 
            {
                "description": "<p>HealthServiceTimeScope value describing how the average should be computed. Use HealthServiceTimeScopeOnce to not compute an average. </p>", 
                "name": "scope", 
                "type": "HealthServiceTimeScope"
            }
        ], 
        "return_desc": "<p>The average of the aggregation performed on the given metric over the given time range, if available. </p>", 
        "returns": "HealthValue", 
        "warning": null
    }, 
    "health_service_any_activity_accessible": {
        "description": "<p>Check if a certain combination of metric, HealthActivityMask and time span is accessible. Developers should check if the return value is HealthServiceAccessibilityMaskAvailable before calling any other HealthService APIs that involve the given activities. </p>", 
        "kind": "fn", 
        "name": "health_service_any_activity_accessible", 
        "params": [
            {
                "description": "<p>A bitmask of activities you are interested in. </p>", 
                "name": "activity_mask", 
                "type": "HealthActivityMask"
            }, 
            {
                "description": "<p>Earliest UTC time you are interested in. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>Latest UTC time you are interested in. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }
        ], 
        "return_desc": "<p>A HealthServiceAccessibilityMask representing which of the passed HealthActivityMask values are available under the given constraints. </p>", 
        "returns": "HealthServiceAccessibilityMask", 
        "warning": null
    }, 
    "health_service_cancel_metric_alert": {
        "description": "<p>Cancel an metric alert previously created with <code>health_service_register_metric_alert</code>. </p>", 
        "kind": "fn", 
        "name": "health_service_cancel_metric_alert", 
        "params": [
            {
                "description": "<p>the HealthMetricAlert previously returned by <code>health_service_register_metric_alert</code> </p>", 
                "name": "alert", 
                "type": "HealthMetricAlert *"
            }
        ], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "health_service_events_subscribe": {
        "description": "<p>Subscribe to HealthService events. This allocates a cache on the application's heap of up to 2048 bytes that will be de-allocated if you call <code>health_service_events_unsubscribe()</code>. If there's not enough heap available, this function will return false and will not subscribe to any events. </p>", 
        "kind": "fn", 
        "name": "health_service_events_subscribe", 
        "params": [
            {
                "description": "<p>Developer-supplied event handler function. </p>", 
                "name": "handler", 
                "type": "HealthEventHandler"
            }, 
            {
                "description": "<p>Developer-supplied context pointer. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>true on success, false on failure. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "health_service_events_unsubscribe": {
        "description": "<p>Unsubscribe from HealthService events. </p>", 
        "kind": "fn", 
        "name": "health_service_events_unsubscribe", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "health_service_get_heart_rate_sample_period_expiration_sec": {
        "description": "<p>Return how long a heart rate sample period request (sent via <code>health_service_set_heart_rate_sample_period</code>) will remain active after the app exits. If there is no current request by this app, this call will return 0. </p>", 
        "kind": "fn", 
        "name": "health_service_get_heart_rate_sample_period_expiration_sec", 
        "params": [], 
        "return_desc": "<p>The number of seconds the heart rate sample period request will remain active after the app exits, or 0 if there is no active request by this app. </p>", 
        "returns": "uint16_t", 
        "warning": null
    }, 
    "health_service_get_measurement_system_for_display": {
        "description": "<p>Get the preferred measurement system for a given HealthMetric, if the user has chosen a preferred system and it is applicable to that metric. </p>", 
        "kind": "fn", 
        "name": "health_service_get_measurement_system_for_display", 
        "params": [
            {
                "description": "<p>A metric value chosen from HealthMetric. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }
        ], 
        "return_desc": "<p>A value from MeasurementSystem if applicable, else MeasurementSystemUnknown. </p>", 
        "returns": "MeasurementSystem", 
        "warning": null
    }, 
    "health_service_get_minute_history": {
        "description": "<p>Return historical minute data records. This fills in the <code>minute_data</code> array parameter with minute by minute statistics of the user's steps, average watch orientation, etc. The data is returned in time order, with the oldest minute data returned at <code>minute_data</code>[0]. </p>", 
        "kind": "fn", 
        "name": "health_service_get_minute_history", 
        "params": [
            {
                "description": "<p>Pointer to an array of HealthMinuteData records that will be filled in with the historical minute data. </p>", 
                "name": "minute_data", 
                "type": "HealthMinuteData *"
            }, 
            {
                "description": "<p>The maximum number of records the <code>minute_data</code> array can hold. </p>", 
                "name": "max_records", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>On entry, the UTC time of the first requested record. On exit, the UTC time of the first second of the first record actually returned. If <code>time_start</code> on entry is somewhere in the middle of a minute interval, this function behaves as if the caller passed in the start of that minute. </p>", 
                "name": "time_start", 
                "type": "time_t *"
            }, 
            {
                "description": "<p>On entry, the UTC time of the end of the requested range of records. On exit, the UTC time of the end of the last record actually returned (i.e. start time of last record + 60). If <code>time_end</code> on entry is somewhere in the middle of a minute interval, this function behaves as if the caller passed in the end of that minute. </p>", 
                "name": "time_end", 
                "type": "time_t *"
            }
        ], 
        "return_desc": "<p>Actual number of records returned. May be less then the maximum requested. </p>", 
        "returns": "uint32_t", 
        "warning": "<p>If the return value is zero, <code>time_start</code> and <code>time_end</code> are meaningless. It's not guaranteed that all records contain valid data, even if the return value is greater than zero. Check HealthMinuteData.<code>is_invalid</code> to see if a given record contains valid data. </p>"
    }, 
    "health_service_metric_accessible": {
        "description": "<p>Check if a certain combination of metric and time span is accessible using <code>health_service_sum</code> by returning a value of HealthServiceAccessibilityMask. Developers should check if the return value is HealthServiceAccessibilityMaskAvailable before calling <code>health_service_sum</code>. </p>", 
        "kind": "fn", 
        "name": "health_service_metric_accessible", 
        "params": [
            {
                "description": "<p>The metric to query for data. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>Earliest UTC time you are interested in. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>Latest UTC time you are interested in. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }
        ], 
        "return_desc": "<p>A HealthServiceAccessibilityMask representing the accessible metrics in this time range. </p>", 
        "returns": "HealthServiceAccessibilityMask", 
        "warning": null
    }, 
    "health_service_metric_aggregate_averaged_accessible": {
        "description": "<p>Check if a certain combination of metric, time span, aggregation operation, and scope is accessible for calculating aggregated, averaged data by returning a value of HealthServiceAccessibilityMask. Developers should check if the return value is HealthServiceAccessibilityMaskAvailable before calling <code>health_service_aggregate_averaged</code>. </p>", 
        "kind": "fn", 
        "name": "health_service_metric_aggregate_averaged_accessible", 
        "params": [
            {
                "description": "<p>The metric to query for averaged data. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>Earliest UTC time you are interested in. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>Latest UTC time you are interested in. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }, 
            {
                "description": "<p>The aggregation to perform </p>", 
                "name": "aggregation", 
                "type": "HealthAggregation"
            }, 
            {
                "description": "<p>HealthServiceTimeScope value describing how the average should be computed. </p>", 
                "name": "scope", 
                "type": "HealthServiceTimeScope"
            }
        ], 
        "return_desc": "<p>A  value decribing whether averaged data is available. </p>", 
        "returns": "HealthServiceAccessibilityMask", 
        "warning": null
    }, 
    "health_service_metric_averaged_accessible": {
        "description": "<p>Check if a certain combination of metric, time span, and scope is accessible for calculating summed, averaged data by returning a value of HealthServiceAccessibilityMask. Developers should check if the return value is HealthServiceAccessibilityMaskAvailable before calling <code>health_service_sum_averaged</code>. </p>", 
        "kind": "fn", 
        "name": "health_service_metric_averaged_accessible", 
        "params": [
            {
                "description": "<p>The metric to query for averaged data. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>Earliest UTC time you are interested in. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>Latest UTC time you are interested in. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }, 
            {
                "description": "<p>HealthServiceTimeScope value describing how the average should be computed. </p>", 
                "name": "scope", 
                "type": "HealthServiceTimeScope"
            }
        ], 
        "return_desc": "<p>A  value decribing whether averaged data is available. </p>", 
        "returns": "HealthServiceAccessibilityMask", 
        "warning": null
    }, 
    "health_service_peek_current_activities": {
        "description": "<p>Return a HealthActivityMask containing a set of bits, one set for each activity that is currently active. </p>", 
        "kind": "fn", 
        "name": "health_service_peek_current_activities", 
        "params": [], 
        "return_desc": "<p>A bitmask with zero or more HealthActivityMask bits set as appropriate. </p>", 
        "returns": "HealthActivityMask", 
        "warning": null
    }, 
    "health_service_peek_current_value": {
        "description": "<p>Convenience function for peeking at the current value of a metric. This is useful for metrics like HealthMetricHeartRateBPM that represent instantaneous values. It is NOT applicable for metrics like HealthMetricStepCount that must be accumulated over time (it will return 0 if passed that type of metric). This call is equivalent to calling <code>health_service_aggregate_averaged</code>(metric, time(NULL), time(NULL), HealthAggregationAvg, HealthServiceTimeScopeOnce) </p>", 
        "kind": "fn", 
        "name": "health_service_peek_current_value", 
        "params": [
            {
                "description": "<p>The metric to query. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }
        ], 
        "return_desc": "<p>The current value of that metric, if available. </p>", 
        "returns": "HealthValue", 
        "warning": null
    }, 
    "health_service_register_metric_alert": {
        "description": "<p>Register for an alert when a metric crosses the given threshold. When the metric crosses this threshold (either goes above or below it), a HealthEventMetricAlert event will be generated. To cancel this registration, pass the returned HealthMetricAlert value to <code>health_service_cancel_metric_alert</code>. The only metric currently supported by this call is HealthMetricHeartRateBPM, but future versions may support additional metrics. To see if a specific metric is supported by this call, use: `<code>time_t</code> now = time(NULL); HealthServiceAccessibilityMask accessible = <code>health_service_metric_aggregate_averaged_accessible</code>(metric, now, now, HealthAggregationAvg, HealthServiceTimeScopeOnce); bool <code>alert_supported</code> = (accessible & HealthServiceAccessibilityMaskAvailable); ` In the current implementation, only one alert per metric can be registered at a time. Future implementations may support two or more simulataneous alert registrations per metric. To change the alert threshold in the current implementation, cancel the original registration using <code>health_service_cancel_metric_alert</code> before registering the new threshold. </p>", 
        "kind": "fn", 
        "name": "health_service_register_metric_alert", 
        "params": [
            {
                "description": null, 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>the threshold value </p>", 
                "name": "threshold", 
                "type": "HealthValue"
            }
        ], 
        "return_desc": "<p>handle to the alert registration on success, NULL on failure </p>", 
        "returns": "HealthMetricAlert *", 
        "warning": null
    }, 
    "health_service_set_heart_rate_sample_period": {
        "description": "<p>Set the desired sampling period for heart rate readings. Normally, the system will sample the heart rate using a sampling period that is automatically chosen to provide useful information without undue battery drain (it automatically samples more often during periods of intense activity, and less often when the user is idle). If desired though, an application can request a specific sampling period using this call. The system will use this as a suggestion, but does not guarantee that the requested period will be used. The actual sampling period may be greater or less due to system needs or heart rate sensor reading quality issues. Each time a new heart rate reading becomes available, a HealthEventHeartRateUpdate event will be sent to the application's HealthEventHandler. The sample period request will remain in effect the entire time the app is running unless it is explicity cancelled (by calling this mehod again with 0 as the desired interval). If the app exits without first cancelling the request, it will remain in effect even for a limited time afterwards. To determine how long it will remain active after the app exits, use <code>health_service_get_heart_rate_sample_period_expiration_sec</code>. Unless the app explicitly needs to access to historical high-resolution heart rate data, it is best practice to always cancel the sample period request before exiting in order to maximize battery life. Historical heart rate data can be accessed using the <code>health_service_get_minute_history</code> call. </p>", 
        "kind": "fn", 
        "name": "health_service_set_heart_rate_sample_period", 
        "params": [
            {
                "description": "<p>desired interval between heart rate reading updates. Pass 0 to go back to automatically chosen intervals. </p>", 
                "name": "interval_sec", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "health_service_sum": {
        "description": "<p>Return the sum of a HealthMetric's values over a time range. The <code>time_start</code> and <code>time_end</code> parameters define the range of time you want the sum for. </p>", 
        "kind": "fn", 
        "name": "health_service_sum", 
        "params": [
            {
                "description": "<p>The metric to query for data. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>UTC time of the earliest data item to incorporate into the sum. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>UTC time of the most recent data item to incorporate into the sum. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }
        ], 
        "return_desc": "<p>The sum of that metric over the given time range, if available. </p>", 
        "returns": "HealthValue", 
        "warning": "<p>The value returned will be based on daily totals, weighted for the length of the specified time range. This may change in the future. </p>"
    }, 
    "health_service_sum_averaged": {
        "description": "<p>Return the value of a metric's sum over a given time range between <code>time_start</code> and <code>time_end</code>. Using this call you can specify the time range that you are interested in getting the average for, as well as a scope specifier on how to compute an average of the sum. For example, if you want to get the average number of steps taken from 12 AM (midnight) to 9 AM across all days you would specify: <code>time_t</code> <code>time_start</code> = <code>time_start_of_today()</code>; <code>time_t</code> <code>time_end</code> = <code>time_start</code> + (9 * <code>SECONDS_PER_HOUR</code>); HealthValue value = <code>health_service_sum_averaged</code>(HealthMetricStepCount, <code>time_start</code>, <code>time_end</code>, HealthServiceTimeScopeDaily); </p>", 
        "kind": "fn", 
        "name": "health_service_sum_averaged", 
        "params": [
            {
                "description": "<p>Which HealthMetric to query. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }, 
            {
                "description": "<p>UTC time of the start of the query interval. </p>", 
                "name": "time_start", 
                "type": "time_t"
            }, 
            {
                "description": "<p>UTC time of the end of the query interval. </p>", 
                "name": "time_end", 
                "type": "time_t"
            }, 
            {
                "description": "<p>HealthServiceTimeScope value describing how the average should be computed. </p>", 
                "name": "scope", 
                "type": "HealthServiceTimeScope"
            }
        ], 
        "return_desc": "<p>The average of the sum of the given metric over the given time range, if available. </p>", 
        "returns": "HealthValue", 
        "warning": null
    }, 
    "health_service_sum_today": {
        "description": "<p>Convenience wrapper for <code>health_service_sum()</code> that returns the sum for today. </p>", 
        "kind": "fn", 
        "name": "health_service_sum_today", 
        "params": [
            {
                "description": "<p>The metric to query. </p>", 
                "name": "metric", 
                "type": "HealthMetric"
            }
        ], 
        "return_desc": "<p>The sum of that metric's data for today, if available. </p>", 
        "returns": "HealthValue", 
        "warning": null
    }, 
    "heap_bytes_free": {
        "description": "<p>Calculates the number of bytes of heap memory not currently being used by the application. </p>", 
        "kind": "fn", 
        "name": "heap_bytes_free", 
        "params": [], 
        "return_desc": "<p>The number of bytes on the heap not currently being used. </p>", 
        "returns": "size_t", 
        "warning": null
    }, 
    "heap_bytes_used": {
        "description": "<p>Calculates the number of bytes of heap memory currently being used by the application. </p>", 
        "kind": "fn", 
        "name": "heap_bytes_used", 
        "params": [], 
        "return_desc": "<p>The number of bytes on the heap currently being used. </p>", 
        "returns": "size_t", 
        "warning": null
    }, 
    "i18n_get_system_locale": {
        "description": "<p>Get the ISO locale name for the language currently set on the watch. </p>", 
        "kind": "fn", 
        "name": "i18n_get_system_locale", 
        "params": [], 
        "return_desc": "<p>A string containing the ISO locale name (e.g. \"fr\", \"<code>en_US</code>\", ...) </p>", 
        "returns": "const char *", 
        "warning": "<p>It is possible for the locale to change while your app is running. And thus, two calls to <code>i18n_get_system_locale</code> may return different values. </p>"
    }, 
    "launch_get_args": {
        "description": "<p>Get the argument passed to the app when it was launched. </p>", 
        "kind": "fn", 
        "name": "launch_get_args", 
        "params": [], 
        "return_desc": "<p>The argument passed to the app, or 0 if the app wasn't launched from a Launch App action </p>", 
        "returns": "uint32_t", 
        "warning": "<p>Currently the only way to pass arguments to apps is by using an openWatchApp action on a pin. </p>"
    }, 
    "launch_reason": {
        "description": "<p>Provides the method used to launch the current application. </p>", 
        "kind": "fn", 
        "name": "launch_reason", 
        "params": [], 
        "return_desc": "<p>The method or reason the current application was launched </p>", 
        "returns": "AppLaunchReason", 
        "warning": null
    }, 
    "layer_add_child": {
        "description": "<p>Adds the child layer to a given parent layer, making it appear in front of its parent and in front of any existing child layers of the parent. If the child layer was already part of a layer hierarchy, it will be removed from its old parent first. If added successfully, the parent (and children) will be marked dirty automatically. </p>", 
        "kind": "fn", 
        "name": "layer_add_child", 
        "params": [
            {
                "description": "<p>The layer to which to add the child layer </p>", 
                "name": "parent", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>The layer to add to the parent layer </p>", 
                "name": "child", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_convert_point_to_screen": {
        "description": "<p>Converts a point from the layer's local coordinate system to screen coordinates. </p>", 
        "kind": "fn", 
        "name": "layer_convert_point_to_screen", 
        "params": [
            {
                "description": "<p>The view whose coordinate system will be used to convert the value to the screen. </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }, 
            {
                "description": "<p>A point specified in the local coordinate system (bounds) of the layer. </p>", 
                "name": "point", 
                "type": "GPoint"
            }
        ], 
        "return_desc": "<p>The point converted to the coordinate system of the screen. </p>", 
        "returns": "GPoint", 
        "warning": "<p>If the layer isn't part of the view hierarchy the result is undefined. </p>"
    }, 
    "layer_convert_rect_to_screen": {
        "description": "<p>Converts a rectangle from the layer's local coordinate system to screen coordinates. </p>", 
        "kind": "fn", 
        "name": "layer_convert_rect_to_screen", 
        "params": [
            {
                "description": "<p>The view whose coordinate system will be used to convert the value to the screen. </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }, 
            {
                "description": "<p>A rectangle specified in the local coordinate system (bounds) of the layer. </p>", 
                "name": "rect", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>The rectangle converted to the coordinate system of the screen. </p>", 
        "returns": "GRect", 
        "warning": "<p>If the layer isn't part of the view hierarchy the result is undefined. </p>"
    }, 
    "layer_create": {
        "description": "<p><ul><li><p>bounds : origin (0, 0) and a size equal to the frame that is passed in.</p></li><li><p>clips : true</p></li><li><p>hidden : false</p></li><li><p><code>update_proc</code> : NULL (draws nothing) \n\n</li></ul>\n</p>", 
        "kind": "fn", 
        "name": "layer_create", 
        "params": [
            {
                "description": "<p>The frame at which the layer should be initialized. </p>", 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>A pointer to the layer. NULL if the layer could not be created </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "layer_create_with_data": {
        "description": "<p><ul><li><p>bounds : origin (0, 0) and a size equal to the frame that is passed in.</p></li><li><p>clips : true</p></li><li><p>hidden : false</p></li><li><p><code>update_proc</code> : NULL (draws nothing) \n\n\n</li></ul>\n</p>", 
        "kind": "fn", 
        "name": "layer_create_with_data", 
        "params": [
            {
                "description": "<p>The frame at which the layer should be initialized. </p>", 
                "name": "frame", 
                "type": "GRect"
            }, 
            {
                "description": "<p>The size (in bytes) of memory to allocate for callback data. </p>", 
                "name": "data_size", 
                "type": "size_t"
            }
        ], 
        "return_desc": "<p>A pointer to the layer. NULL if the layer could not be created </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "layer_destroy": {
        "description": "<p>Destroys a layer previously created by <code>layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "layer", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_get_bounds": {
        "description": "<p>Gets the bounds of the layer. </p>", 
        "kind": "fn", 
        "name": "layer_get_bounds", 
        "params": [
            {
                "description": "<p>The layer for which to get the bounds </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>The bounds of the layer </p>", 
        "returns": "GRect", 
        "warning": null
    }, 
    "layer_get_clips": {
        "description": "<p>Gets whether clipping is enabled for the layer. If enabled, whatever the layer and its children will draw using their .<code>update_proc</code> callbacks, will be clipped by the this layer's frame. </p>", 
        "kind": "fn", 
        "name": "layer_get_clips", 
        "params": [
            {
                "description": "<p>The layer for which to get the clipping property </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>True if clipping is enabled for the layer, false if clipping is not enabled for the layer. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "layer_get_data": {
        "description": "<p>Gets the data from a layer that has been created with an extra data region. </p>", 
        "kind": "fn", 
        "name": "layer_get_data", 
        "params": [
            {
                "description": "<p>The layer to get the data region from. </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>A void pointer to the data region. </p>", 
        "returns": "void *", 
        "warning": null
    }, 
    "layer_get_frame": {
        "description": "<p>Gets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. If the frame has changed, <code>layer_mark_dirty()</code> will be called automatically. </p>", 
        "kind": "fn", 
        "name": "layer_get_frame", 
        "params": [
            {
                "description": "<p>The layer for which to get the frame </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>The frame of the layer </p>", 
        "returns": "GRect", 
        "warning": null
    }, 
    "layer_get_hidden": {
        "description": "<p>Gets the visibility of the layer. </p>", 
        "kind": "fn", 
        "name": "layer_get_hidden", 
        "params": [
            {
                "description": "<p>The layer for which to get the visibility </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>True if the layer is hidden, false if it is not hidden. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "layer_get_unobstructed_bounds": {
        "description": "<p>Get the largest unobstructed bounds rectangle of a layer. </p>", 
        "kind": "fn", 
        "name": "layer_get_unobstructed_bounds", 
        "params": [
            {
                "description": "<p>The layer for which to get the unobstructed bounds. </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>The unobstructed bounds of the layer. </p>", 
        "returns": "GRect", 
        "warning": null
    }, 
    "layer_get_window": {
        "description": "<p>Gets the window that the layer is currently attached to. </p>", 
        "kind": "fn", 
        "name": "layer_get_window", 
        "params": [
            {
                "description": "<p>The layer for which to get the window </p>", 
                "name": "layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>The window that this layer is currently attached to, or NULL if it has not been added to a window's layer hierarchy. </p>", 
        "returns": "struct Window *", 
        "warning": null
    }, 
    "layer_insert_above_sibling": {
        "description": "<p>Inserts the layer as a sibling in front of another layer. The <code>above_layer</code> has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically. </p>", 
        "kind": "fn", 
        "name": "layer_insert_above_sibling", 
        "params": [
            {
                "description": "<p>The layer to insert into the hierarchy </p>", 
                "name": "layer_to_insert", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>The layer that will be used as the sibling layer below which the insertion will take place </p>", 
                "name": "above_sibling_layer", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_insert_below_sibling": {
        "description": "<p>Inserts the layer as a sibling behind another layer. If the layer to insert was already part of a layer hierarchy, it will be removed from its old parent first. The <code>below_layer</code> has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically. </p>", 
        "kind": "fn", 
        "name": "layer_insert_below_sibling", 
        "params": [
            {
                "description": "<p>The layer to insert into the hierarchy </p>", 
                "name": "layer_to_insert", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>The layer that will be used as the sibling layer above which the insertion will take place </p>", 
                "name": "below_sibling_layer", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_mark_dirty": {
        "description": "<p><ul><li><p>The layer's .<code>update_proc</code> will not be called before this function returns, but will be called asynchronously, shortly.</p></li><li><p>Internally, a call to this function will schedule a re-render of the window that the layer belongs to. In effect, all layers in that window's layer hierarchy will be asked to redraw.</p></li><li><p>If an earlier re-render request is still pending, this function is a no-op. </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "layer_mark_dirty", 
        "params": [
            {
                "description": "<p>The layer to mark dirty </p>", 
                "name": "layer", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_remove_child_layers": {
        "description": "<p>Removes child layers from given layer If removed successfully, the child's parent layer will be marked dirty automatically. </p>", 
        "kind": "fn", 
        "name": "layer_remove_child_layers", 
        "params": [
            {
                "description": "<p>The layer from which to remove all child layers </p>", 
                "name": "parent", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_remove_from_parent": {
        "description": "<p>Removes the layer from its current parent layer If removed successfully, the child's parent layer will be marked dirty automatically. </p>", 
        "kind": "fn", 
        "name": "layer_remove_from_parent", 
        "params": [
            {
                "description": "<p>The layer to remove </p>", 
                "name": "child", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_set_bounds": {
        "description": "<p>Sets the bounds of the layer, which is it's bounding box relative to its frame. If the bounds has changed, <code>layer_mark_dirty()</code> will be called automatically. </p>", 
        "kind": "fn", 
        "name": "layer_set_bounds", 
        "params": [
            {
                "description": "<p>The layer for which to set the bounds </p>", 
                "name": "layer", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>The new bounds </p>", 
                "name": "bounds", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_set_clips": {
        "description": "<p>Sets whether clipping is enabled for the layer. If enabled, whatever the layer and its children will draw using their .<code>update_proc</code> callbacks, will be clipped by the this layer's frame. If the clipping has changed, <code>layer_mark_dirty()</code> will be called automatically. </p>", 
        "kind": "fn", 
        "name": "layer_set_clips", 
        "params": [
            {
                "description": "<p>The layer for which to set the clipping property </p>", 
                "name": "layer", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>Supply true to make the layer clip to its frame, or false to make it non-clipping. </p>", 
                "name": "clips", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_set_frame": {
        "description": "<p>Sets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. The size of the layer's bounds will be extended automatically, so that the bounds cover the new frame. </p>", 
        "kind": "fn", 
        "name": "layer_set_frame", 
        "params": [
            {
                "description": "<p>The layer for which to set the frame </p>", 
                "name": "layer", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>The new frame </p>", 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_set_hidden": {
        "description": "<p>Sets the visibility of the layer. If the visibility has changed, <code>layer_mark_dirty()</code> will be called automatically on the parent layer. </p>", 
        "kind": "fn", 
        "name": "layer_set_hidden", 
        "params": [
            {
                "description": "<p>The layer for which to set the visibility </p>", 
                "name": "layer", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>Supply true to make the layer hidden, or false to make it non-hidden. </p>", 
                "name": "hidden", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "layer_set_update_proc": {
        "description": "<p>Sets the layer's render function. The system will call the <code>update_proc</code> automatically when the layer needs to redraw itself, see also <code>layer_mark_dirty()</code>. </p>", 
        "kind": "fn", 
        "name": "layer_set_update_proc", 
        "params": [
            {
                "description": "<p>Pointer to the layer structure. </p>", 
                "name": "layer", 
                "type": "Layer *"
            }, 
            {
                "description": "<p>Pointer to the function that will be called when the layer needs to be rendered. Typically, one performs a series of drawing commands in the implementation of the <code>update_proc</code>, see Drawing Primitives, Drawing Paths and Drawing Text. </p>", 
                "name": "update_proc", 
                "type": "LayerUpdateProc"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "light_enable": {
        "description": "<p>Turn the watch's backlight on or put it back into automatic control. Developers should take care when calling this function, keeping Pebble's backlight on for long periods of time will rapidly deplete the battery. </p>", 
        "kind": "fn", 
        "name": "light_enable", 
        "params": [
            {
                "description": "<p>Turn the backlight on if true, otherwise false to put it back into automatic control. </p>", 
                "name": "enable", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "light_enable_interaction": {
        "description": "<p>Trigger the backlight and schedule a timer to automatically disable the backlight after a short delay. This is the preferred method of interacting with the backlight. </p>", 
        "kind": "fn", 
        "name": "light_enable_interaction", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "localtime": {
        "description": "<p>convert the time value pointed at by clock to a struct tm which contains the time adjusted for the local timezone </p>", 
        "kind": "fn", 
        "name": "localtime", 
        "params": [
            {
                "description": "<p>A pointer to an object of type <code>time_t</code> that contains a time value </p>", 
                "name": "timep", 
                "type": "const time_t *"
            }
        ], 
        "return_desc": "<p>A pointer to a struct tm containing the broken out time value adjusted for the local timezone </p>", 
        "returns": "struct tm *", 
        "warning": null
    }, 
    "memory_cache_flush": {
        "description": "<p>Flushes the data cache and invalidates the instruction cache for the given region of memory, if necessary. This is only required when your app is loading or modifying code in memory and intends to execute it. On some platforms, code executed may be cached internally to improve performance. After writing to memory, but before executing, this function must be called in order to avoid undefined behavior. On platforms without caching, this performs no operation. </p>", 
        "kind": "fn", 
        "name": "memory_cache_flush", 
        "params": [
            {
                "description": "<p>The beginning of the buffer to flush </p>", 
                "name": "start", 
                "type": "void *"
            }, 
            {
                "description": "<p>How many bytes to flush </p>", 
                "name": "size", 
                "type": "size_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_cell_basic_draw": {
        "description": "<p>Section drawing function to draw a basic section cell with the title, subtitle, and icon of the section. Call this function inside the .<code>draw_row</code> callback implementation, see MenuLayerCallbacks. Note that if the size of <code>cell_layer</code> is too small to fit all of the cell items specified, not all of them may be drawn. </p>", 
        "kind": "fn", 
        "name": "menu_cell_basic_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The layer of the cell to draw </p>", 
                "name": "cell_layer", 
                "type": "const Layer *"
            }, 
            {
                "description": "<p>If non-null, draws a title in larger text (24 points, bold Raster Gothic system font). </p>", 
                "name": "title", 
                "type": "const char *"
            }, 
            {
                "description": "<p>If non-null, draws a subtitle in smaller text (18 points, Raster Gothic system font). If NULL, the title will be centered vertically inside the menu cell. </p>", 
                "name": "subtitle", 
                "type": "const char *"
            }, 
            {
                "description": "<p>If non-null, draws an icon to the left of the text. If NULL, the icon will be omitted and the leftover space is used for the title and subtitle. </p>", 
                "name": "icon", 
                "type": "GBitmap *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_cell_basic_header_draw": {
        "description": "<p>Section header drawing function to draw a basic section header cell layout with the title of the section. Call this function inside the .<code>draw_header</code> callback implementation, see MenuLayerCallbacks. </p>", 
        "kind": "fn", 
        "name": "menu_cell_basic_header_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The layer of the cell to draw </p>", 
                "name": "cell_layer", 
                "type": "const Layer *"
            }, 
            {
                "description": "<p>If non-null, draws the title in small text (14 points, bold Raster Gothic system font). </p>", 
                "name": "title", 
                "type": "const char *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_cell_layer_is_highlighted": {
        "description": "<p>Returns whether or not the given cell layer is highlighted. Using this for determining highlight behaviour is preferable to using <code>menu_layer_get_selected_index</code>. Row drawing callbacks may be invoked multiple times with a different highlight status on the same cell in order to handle partially highlighted cells during animation. </p>", 
        "kind": "fn", 
        "name": "menu_cell_layer_is_highlighted", 
        "params": [
            {
                "description": "<p>The Layers for the cell to check highlight status. </p>", 
                "name": "cell_layer", 
                "type": "const Layer *"
            }
        ], 
        "return_desc": "<p>true if the given cell layer is highlighted in the menu. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "menu_cell_title_draw": {
        "description": "<p>Cell drawing function to draw a basic menu cell layout with title, subtitle Cell drawing function to draw a menu cell layout with only one big title. Call this function inside the .<code>draw_row</code> callback implementation, see MenuLayerCallbacks. </p>", 
        "kind": "fn", 
        "name": "menu_cell_title_draw", 
        "params": [
            {
                "description": "<p>The destination graphics context </p>", 
                "name": "ctx", 
                "type": "GContext *"
            }, 
            {
                "description": "<p>The layer of the cell to draw </p>", 
                "name": "cell_layer", 
                "type": "const Layer *"
            }, 
            {
                "description": "<p>If non-null, draws a title in larger text (28 points, bold Raster Gothic system font). </p>", 
                "name": "title", 
                "type": "const char *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_index_compare": {
        "description": "<p>Comparator function to determine the order of two MenuIndex values. </p>", 
        "kind": "fn", 
        "name": "menu_index_compare", 
        "params": [
            {
                "description": "<p>Pointer to the menu index of the first item </p>", 
                "name": "a", 
                "type": "const MenuIndex *"
            }, 
            {
                "description": "<p>Pointer to the menu index of the second item </p>", 
                "name": "b", 
                "type": "const MenuIndex *"
            }
        ], 
        "return_desc": "<p>0 if A and B are equal, 1 if A has a higher section & row combination than B or else -1 </p>", 
        "returns": "int16_t", 
        "warning": null
    }, 
    "menu_layer_create": {
        "description": "<p><ul><li><p>Clips: true</p></li><li><p>Hidden: false</p></li><li><p>Content size: frame.size</p></li><li><p>Content offset: GPointZero</p></li><li><p>Callbacks: None (NULL for each one)</p></li><li><p>Callback context: NULL</p></li><li><p>After the relevant callbacks are called to populate the menu, the item at MenuIndex(0, 0) will be selected initially. </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "menu_layer_create", 
        "params": [
            {
                "description": null, 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>A pointer to the MenuLayer. NULL if the MenuLayer could not be created </p>", 
        "returns": "MenuLayer *", 
        "warning": null
    }, 
    "menu_layer_destroy": {
        "description": "<p>Destroys a MenuLayer previously created by <code>menu_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "menu_layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_get_center_focused": {
        "description": "<p>True, if the MenuLayer generally scrolls such that the selected row is in the center. </p>", 
        "kind": "fn", 
        "name": "menu_layer_get_center_focused", 
        "params": [
            {
                "description": null, 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "bool", 
        "warning": null
    }, 
    "menu_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the MenuLayer, which is the parent for the sub- layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "menu_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the MenuLayer for which to get the \"root\" Layer </p>", 
                "name": "menu_layer", 
                "type": "const MenuLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the MenuLayer. </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "menu_layer_get_scroll_layer": {
        "description": "<p>Gets the ScrollLayer of the MenuLayer, which is the layer responsible for the scrolling of the MenuLayer. </p>", 
        "kind": "fn", 
        "name": "menu_layer_get_scroll_layer", 
        "params": [
            {
                "description": "<p>Pointer to the MenuLayer for which to get the ScrollLayer </p>", 
                "name": "menu_layer", 
                "type": "const MenuLayer *"
            }
        ], 
        "return_desc": "<p>The ScrollLayer of the MenuLayer. </p>", 
        "returns": "ScrollLayer *", 
        "warning": null
    }, 
    "menu_layer_get_selected_index": {
        "description": "<p>Gets the MenuIndex of the currently selected menu item. </p>", 
        "kind": "fn", 
        "name": "menu_layer_get_selected_index", 
        "params": [
            {
                "description": "<p>The MenuLayer for which to get the current selected index. </p>", 
                "name": "menu_layer", 
                "type": "const MenuLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "MenuIndex", 
        "warning": "<p>This function should not be used to determine whether a cell should be highlighted or not. See <code>menu_cell_layer_is_highlighted</code> for more information. </p>"
    }, 
    "menu_layer_is_index_selected": {
        "description": "<p>Returns whether or not the specified cell index is currently selected. </p>", 
        "kind": "fn", 
        "name": "menu_layer_is_index_selected", 
        "params": [
            {
                "description": "<p>The MenuLayer to use when determining if the index is selected. </p>", 
                "name": "menu_layer", 
                "type": "const MenuLayer *"
            }, 
            {
                "description": "<p>The MenuIndex of the cell to check for selection. </p>", 
                "name": "index", 
                "type": "MenuIndex *"
            }
        ], 
        "return_desc": null, 
        "returns": "bool", 
        "warning": "<p>This function should not be used to determine whether a cell is highlighted or not. See <code>menu_cell_layer_is_highlighted</code> for more information. </p>"
    }, 
    "menu_layer_pad_bottom_enable": {
        "description": "<p>This enables or disables padding at the bottom of the MenuLayer. Padding at the bottom of the layer keeps the bottom item from being at the very bottom of the screen. Padding is turned on by default for all MenuLayers. The color of the padded area will be the background color set using <code>menu_layer_set_normal_colors()</code>. To color the padding a different color, use MenuLayerDrawBackgroundCallback. </p>", 
        "kind": "fn", 
        "name": "menu_layer_pad_bottom_enable", 
        "params": [
            {
                "description": "<p>The menu layer for which to enable or disable the padding. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>True = enable padding, False = disable padding. </p>", 
                "name": "enable", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_reload_data": {
        "description": "<p>Reloads the data of the menu. This causes the menu to re-request the menu item data, by calling the relevant callbacks. The current selection and scroll position will not be changed. See the note with <code>menu_layer_set_selected_index()</code> for the behavior if the old selection is no longer valid. </p>", 
        "kind": "fn", 
        "name": "menu_layer_reload_data", 
        "params": [
            {
                "description": "<p>The MenuLayer for which to reload the data. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_set_callbacks": {
        "description": "<p>Sets the callbacks for the MenuLayer. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_callbacks", 
        "params": [
            {
                "description": "<p>Pointer to the MenuLayer for which to set the callbacks and callback context. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>The new callback context. This is passed into each of the callbacks and can be set to point to application provided data. </p>", 
                "name": "callback_context", 
                "type": "void *"
            }, 
            {
                "description": "<p>The new callbacks for the MenuLayer. The storage for this data structure must be long lived. Therefore, it cannot be stack-allocated. </p>", 
                "name": "callbacks", 
                "type": "MenuLayerCallbacks"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_set_center_focused": {
        "description": "<p>Controls if the MenuLayer generally scrolls such that the selected row is in the center. For platforms with a round display (<code>PBL_ROUND</code>) the default is true, otherwise false is the default. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_center_focused", 
        "params": [
            {
                "description": "<p>The menu layer for which to enable or disable the behavior. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>true = enable the mode, false = disable it. </p>", 
                "name": "center_focused", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_set_click_config_onto_window": {
        "description": "<p>Convenience function to set the ClickConfigProvider callback on the given window to the MenuLayer internal click config provider. This internal click configuration provider, will set up the default UP & DOWN scrolling / menu item selection behavior. This function calls <code>scroll_layer_set_click_config_onto_window</code> to accomplish this. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_click_config_onto_window", 
        "params": [
            {
                "description": "<p>The MenuLayer that needs to receive click events. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>The window for which to set the click configuration. </p>", 
                "name": "window", 
                "type": "struct Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_set_highlight_colors": {
        "description": "<p>Set the default colors to be used for cells when it is in a highlighted state. The GContext's text and fill colors will be set appropriately prior to calling the .<code>draw_row</code> callback. If this function is not explicitly called on a MenuLayer, it will default to black background with white foreground. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_highlight_colors", 
        "params": [
            {
                "description": "<p>The MenuLayer for which to set the colors. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>The color to be used for the background of the cell. </p>", 
                "name": "background", 
                "type": "GColor"
            }, 
            {
                "description": "<p>The color to be used for the foreground and text of the cell. </p>", 
                "name": "foreground", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_set_normal_colors": {
        "description": "<p>Set the default colors to be used for cells when it is in a normal state (not highlighted). The GContext's text and fill colors will be set appropriately prior to calling the .<code>draw_row</code> callback. If this function is not explicitly called on a MenuLayer, it will default to white background with black foreground. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_normal_colors", 
        "params": [
            {
                "description": "<p>The MenuLayer for which to set the colors. </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>The color to be used for the background of the cell. </p>", 
                "name": "background", 
                "type": "GColor"
            }, 
            {
                "description": "<p>The color to be used for the foreground and text of the cell. </p>", 
                "name": "foreground", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "menu_layer_set_selected_index": {
        "description": "<p>Selects the item with given MenuIndex. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_selected_index", 
        "params": [
            {
                "description": "<p>The MenuLayer for which to change the selection </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>The index of the item to select </p>", 
                "name": "index", 
                "type": "MenuIndex"
            }, 
            {
                "description": "<p>The alignment of the new selection </p>", 
                "name": "scroll_align", 
                "type": "MenuRowAlign"
            }, 
            {
                "description": "<p>Supply true to animate changing the selection, or false to change the selection instantly. </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the section and/or row index exceeds the avaible number of sections or resp. rows, the exceeding index/indices will be capped, effectively selecting the last section and/or row, resp. </p>"
    }, 
    "menu_layer_set_selected_next": {
        "description": "<p>Selects the next or previous item, relative to the current selection. </p>", 
        "kind": "fn", 
        "name": "menu_layer_set_selected_next", 
        "params": [
            {
                "description": "<p>The MenuLayer for which to select the next item </p>", 
                "name": "menu_layer", 
                "type": "MenuLayer *"
            }, 
            {
                "description": "<p>Supply false to select the next item in the list (downwards), or true to select the previous item in the list (upwards). </p>", 
                "name": "up", 
                "type": "bool"
            }, 
            {
                "description": "<p>The alignment of the new selection </p>", 
                "name": "scroll_align", 
                "type": "MenuRowAlign"
            }, 
            {
                "description": "<p>Supply true to animate changing the selection, or false to change the selection instantly. </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If there is no next/previous item, this function is a no-op. </p>"
    }, 
    "mktime": {
        "description": "<p>convert the broken-down time structure to a timestamp expressed in Coordinated Universal Time (UTC) </p>", 
        "kind": "fn", 
        "name": "mktime", 
        "params": [
            {
                "description": "<p>A pointer to an object of type tm that contains broken-down time </p>", 
                "name": "tb", 
                "type": "struct tm *"
            }
        ], 
        "return_desc": "<p>The number of seconds since epoch, January 1st 1970 </p>", 
        "returns": "time_t", 
        "warning": null
    }, 
    "number_window_create": {
        "description": "<p>Creates a new NumberWindow on the heap and initalizes it with the default values. </p>", 
        "kind": "fn", 
        "name": "number_window_create", 
        "params": [
            {
                "description": "<p>The title or prompt to display in the NumberWindow. Must be long-lived and cannot be stack-allocated. </p>", 
                "name": "label", 
                "type": "const char *"
            }, 
            {
                "description": "<p>The callbacks </p>", 
                "name": "callbacks", 
                "type": "NumberWindowCallbacks"
            }, 
            {
                "description": "<p>Pointer to application specific data that is passed </p>", 
                "name": "callback_context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>A pointer to the NumberWindow. NULL if the NumberWindow could not be created </p>", 
        "returns": "NumberWindow *", 
        "warning": "<p>The number window is not pushed to the window stack. Use <code>window_stack_push()</code> to do this. </p>"
    }, 
    "number_window_destroy": {
        "description": "<p>Destroys a NumberWindow previously created by <code>number_window_create</code>. </p>", 
        "kind": "fn", 
        "name": "number_window_destroy", 
        "params": [
            {
                "description": null, 
                "name": "number_window", 
                "type": "NumberWindow *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "number_window_get_value": {
        "description": "<p>Gets the current value. </p>", 
        "kind": "fn", 
        "name": "number_window_get_value", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to get the current value </p>", 
                "name": "numberwindow", 
                "type": "const NumberWindow *"
            }
        ], 
        "return_desc": "<p>The current value </p>", 
        "returns": "int32_t", 
        "warning": null
    }, 
    "number_window_get_window": {
        "description": "<p>Gets the \"root\" Window of the number window. </p>", 
        "kind": "fn", 
        "name": "number_window_get_window", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to get the \"root\" Window </p>", 
                "name": "numberwindow", 
                "type": "NumberWindow *"
            }
        ], 
        "return_desc": "<p>The \"root\" Window of the number window. </p>", 
        "returns": "Window *", 
        "warning": null
    }, 
    "number_window_set_label": {
        "description": "<p>Sets the text of the title or prompt label. </p>", 
        "kind": "fn", 
        "name": "number_window_set_label", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to set the label text </p>", 
                "name": "numberwindow", 
                "type": "NumberWindow *"
            }, 
            {
                "description": "<p>The new label text. Must be long-lived and cannot be stack-allocated. </p>", 
                "name": "label", 
                "type": "const char *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "number_window_set_max": {
        "description": "<p>Sets the maximum value this field can hold. </p>", 
        "kind": "fn", 
        "name": "number_window_set_max", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to set the maximum value </p>", 
                "name": "numberwindow", 
                "type": "NumberWindow *"
            }, 
            {
                "description": "<p>The maximum value </p>", 
                "name": "max", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "number_window_set_min": {
        "description": "<p>Sets the minimum value this field can hold. </p>", 
        "kind": "fn", 
        "name": "number_window_set_min", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to set the minimum value </p>", 
                "name": "numberwindow", 
                "type": "NumberWindow *"
            }, 
            {
                "description": "<p>The minimum value </p>", 
                "name": "min", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "number_window_set_step_size": {
        "description": "<p>Sets the amount by which to increment/decrement by on a button click. </p>", 
        "kind": "fn", 
        "name": "number_window_set_step_size", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to set the step increment </p>", 
                "name": "numberwindow", 
                "type": "NumberWindow *"
            }, 
            {
                "description": "<p>The new step increment </p>", 
                "name": "step", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "number_window_set_value": {
        "description": "<p>Sets the current value of the field. </p>", 
        "kind": "fn", 
        "name": "number_window_set_value", 
        "params": [
            {
                "description": "<p>Pointer to the NumberWindow for which to set the current value </p>", 
                "name": "numberwindow", 
                "type": "NumberWindow *"
            }, 
            {
                "description": "<p>The new current value </p>", 
                "name": "value", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "persist_delete": {
        "description": "<p>Deletes the value of a key from persistent storage. </p>", 
        "kind": "fn", 
        "name": "persist_delete", 
        "params": [
            {
                "description": "<p>The key of the field to delete from. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "status_t", 
        "warning": null
    }, 
    "persist_exists": {
        "description": "<p>Checks whether a value has been set for a given key in persistent storage. </p>", 
        "kind": "fn", 
        "name": "persist_exists", 
        "params": [
            {
                "description": "<p>The key of the field to check. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>true if a value exists, otherwise false. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "persist_get_size": {
        "description": "<p>Gets the size of a value for a given key in persistent storage. </p>", 
        "kind": "fn", 
        "name": "persist_get_size", 
        "params": [
            {
                "description": "<p>The key of the field to lookup the data size. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>The size of the value in bytes or <code>E_DOES_NOT_EXIST</code> if there is no field matching the given key. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "persist_read_bool": {
        "description": "<p>Reads a bool value for a given key from persistent storage. If the value has not yet been set, this will return false. </p>", 
        "kind": "fn", 
        "name": "persist_read_bool", 
        "params": [
            {
                "description": "<p>The key of the field to read from. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>The bool value of the key to read from. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "persist_read_data": {
        "description": "<p>Reads a blob of data for a given key from persistent storage into a given buffer. If the value has not yet been set, the given buffer is left unchanged. </p>", 
        "kind": "fn", 
        "name": "persist_read_data", 
        "params": [
            {
                "description": "<p>The key of the field to read from. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The pointer to a buffer to be written to. </p>", 
                "name": "buffer", 
                "type": "void *"
            }, 
            {
                "description": "<p>The maximum size of the given buffer. </p>", 
                "name": "buffer_size", 
                "type": "const size_t"
            }
        ], 
        "return_desc": "<p>The number of bytes written into the buffer or <code>E_DOES_NOT_EXIST</code> if there is no field matching the given key. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "persist_read_int": {
        "description": "<p>Reads an int value for a given key from persistent storage. </p>", 
        "kind": "fn", 
        "name": "persist_read_int", 
        "params": [
            {
                "description": "<p>The key of the field to read from. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": "<p>The int value of the key to read from. </p>", 
        "returns": "int32_t", 
        "warning": "<p>The int is a signed 32-bit integer. If the value has not yet been set, this will return 0. </p>"
    }, 
    "persist_read_string": {
        "description": "<p>Reads a string for a given key from persistent storage into a given buffer. The string will be null terminated. If the value has not yet been set, the given buffer is left unchanged. </p>", 
        "kind": "fn", 
        "name": "persist_read_string", 
        "params": [
            {
                "description": "<p>The key of the field to read from. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The pointer to a buffer to be written to. </p>", 
                "name": "buffer", 
                "type": "char *"
            }, 
            {
                "description": "<p>The maximum size of the given buffer. This includes the null character. </p>", 
                "name": "buffer_size", 
                "type": "const size_t"
            }
        ], 
        "return_desc": "<p>The number of bytes written into the buffer or <code>E_DOES_NOT_EXIST</code> if there is no field matching the given key. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "persist_write_bool": {
        "description": "<p>Writes a bool value flag for a given key into persistent storage. </p>", 
        "kind": "fn", 
        "name": "persist_write_bool", 
        "params": [
            {
                "description": "<p>The key of the field to write to. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The boolean value to write. </p>", 
                "name": "value", 
                "type": "const bool"
            }
        ], 
        "return_desc": "<p>The number of bytes written if successful, a value from StatusCode otherwise. </p>", 
        "returns": "status_t", 
        "warning": null
    }, 
    "persist_write_data": {
        "description": "<p>Writes a blob of data of a specified size in bytes for a given key into persistent storage. The maximum size is <code>PERSIST_DATA_MAX_LENGTH</code>. </p>", 
        "kind": "fn", 
        "name": "persist_write_data", 
        "params": [
            {
                "description": "<p>The key of the field to write to. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The pointer to the blob of data. </p>", 
                "name": "data", 
                "type": "const void *"
            }, 
            {
                "description": "<p>The size in bytes. </p>", 
                "name": "size", 
                "type": "const size_t"
            }
        ], 
        "return_desc": "<p>The number of bytes written if successful, a value from StatusCode otherwise. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "persist_write_int": {
        "description": "<p>Writes an int value for a given key into persistent storage. </p>", 
        "kind": "fn", 
        "name": "persist_write_int", 
        "params": [
            {
                "description": "<p>The key of the field to write to. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The int value to write. </p>", 
                "name": "value", 
                "type": "const int32_t"
            }
        ], 
        "return_desc": "<p>The number of bytes written if successful, a value from StatusCode otherwise. </p>", 
        "returns": "status_t", 
        "warning": "<p>The int is a signed 32-bit integer. </p>"
    }, 
    "persist_write_string": {
        "description": "<p>Writes a string a given key into persistent storage. The maximum size is <code>PERSIST_STRING_MAX_LENGTH</code> including the null terminator. </p>", 
        "kind": "fn", 
        "name": "persist_write_string", 
        "params": [
            {
                "description": "<p>The key of the field to write to. </p>", 
                "name": "key", 
                "type": "const uint32_t"
            }, 
            {
                "description": "<p>The pointer to null terminated string. </p>", 
                "name": "cstring", 
                "type": "const char *"
            }
        ], 
        "return_desc": "<p>The number of bytes written if successful, a value from StatusCode otherwise. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "preferred_result_display_duration": {
        "description": "<p>Get the recommended amount of milliseconds a result window should be visible before it should automatically close. </p>", 
        "kind": "fn", 
        "name": "preferred_result_display_duration", 
        "params": [], 
        "return_desc": "<p>The recommended result window timeout duration in milliseconds </p>", 
        "returns": "uint32_t", 
        "warning": "<p>It is the application developer's responsibility to automatically close a result window. </p>"
    }, 
    "property_animation_clone": {
        "description": "<p>Convenience function to clone a property animation instance. </p>", 
        "kind": "def", 
        "name": "property_animation_clone", 
        "params": [], 
        "return_desc": "<p>A clone of the original Animation </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_create": {
        "description": "<p>Creates a new PropertyAnimation on the heap and and initializes it with the specified values. The same defaults are used as with <code>animation_create()</code>. If the <code>from_value</code> or the <code>to_value</code> is NULL, the getter accessor will be called to get the current value of the property and be used instead. </p>", 
        "kind": "fn", 
        "name": "property_animation_create", 
        "params": [
            {
                "description": "<p>Pointer to the implementation of the animation. In most cases, it makes sense to pass in a static const struct pointer. </p>", 
                "name": "implementation", 
                "type": "const PropertyAnimationImplementation *"
            }, 
            {
                "description": "<p>Pointer to the \"subject\" being animated. This will be passed in when the getter/ setter accessors are called, see PropertyAnimationAccessors, GPointSetter, and friends. The value of this pointer will be copied into the .subject field of the PropertyAnimation struct. </p>", 
                "name": "subject", 
                "type": "void *"
            }, 
            {
                "description": "<p>Pointer to the value that the subject should animate from </p>", 
                "name": "from_value", 
                "type": "void *"
            }, 
            {
                "description": "<p>Pointer to the value that the subject should animate to </p>", 
                "name": "to_value", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>A handle to the property animation. NULL if animation could not be created </p>", 
        "returns": "PropertyAnimation *", 
        "warning": "<p>Pass in NULL as one of the value arguments to have it set automatically to the subject's current property value, as returned by the getter function. Also note that passing in NULL for both <code>from_value</code> and <code>to_value</code>, will result in the animation having the same from- and to- values, effectively not doing anything. </p>"
    }, 
    "property_animation_create_bounds_origin": {
        "description": "<p>Convenience function to create and initialize a property animation that animates the bound's origin of a Layer. It sets up the PropertyAnimation to use <code>layer_set_bounds()</code> and <code>layer_get_bounds()</code> as accessors and uses the layer parameter as the subject for the animation. The same defaults are used as with <code>animation_create()</code>. </p>", 
        "kind": "fn", 
        "name": "property_animation_create_bounds_origin", 
        "params": [
            {
                "description": "<p>the layer that will be animated </p>", 
                "name": "layer", 
                "type": "struct Layer *"
            }, 
            {
                "description": null, 
                "name": "from", 
                "type": "GPoint *"
            }, 
            {
                "description": null, 
                "name": "to", 
                "type": "GPoint *"
            }
        ], 
        "return_desc": "<p>A handle to the property animation. NULL if animation could not be created </p>", 
        "returns": "PropertyAnimation *", 
        "warning": null
    }, 
    "property_animation_create_layer_frame": {
        "description": "<p>Convenience function to create and initialize a property animation that animates the frame of a Layer. It sets up the PropertyAnimation to use <code>layer_set_frame()</code> and <code>layer_get_frame()</code> as accessors and uses the layer parameter as the subject for the animation. The same defaults are used as with <code>animation_create()</code>. </p>", 
        "kind": "fn", 
        "name": "property_animation_create_layer_frame", 
        "params": [
            {
                "description": "<p>the layer that will be animated </p>", 
                "name": "layer", 
                "type": "struct Layer *"
            }, 
            {
                "description": "<p>the frame that the layer should animate from </p>", 
                "name": "from_frame", 
                "type": "GRect *"
            }, 
            {
                "description": "<p>the frame that the layer should animate to </p>", 
                "name": "to_frame", 
                "type": "GRect *"
            }
        ], 
        "return_desc": "<p>A handle to the property animation. NULL if animation could not be created </p>", 
        "returns": "PropertyAnimation *", 
        "warning": "<p>Pass in NULL as one of the frame arguments to have it set automatically to the layer's current frame. This will result in a call to <code>layer_get_frame()</code> to get the current frame of the layer. </p>"
    }, 
    "property_animation_destroy": {
        "description": "<p>Destroy a property animation allocated by <code>property_animation_create()</code> or relatives. </p>", 
        "kind": "fn", 
        "name": "property_animation_destroy", 
        "params": [
            {
                "description": "<p>the return value from <code>property_animation_create</code> </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "property_animation_from": {
        "description": "<p>Helper function used by the <code>property_animation_get</code>|<code>set_from_</code>.* macros. </p>", 
        "kind": "fn", 
        "name": "property_animation_from", 
        "params": [
            {
                "description": "<p>Handle to the property animation </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>Pointer to the value </p>", 
                "name": "from", 
                "type": "void *"
            }, 
            {
                "description": "<p>Size of the from value </p>", 
                "name": "size", 
                "type": "size_t"
            }, 
            {
                "description": "<p>true to set new value, false to retrieve existing one </p>", 
                "name": "set", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure (usually a bad <code>animation_h</code>) </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "property_animation_get_animation": {
        "description": "<p>Convenience function to retrieve an animation instance from a property animation instance. </p>", 
        "kind": "fn", 
        "name": "property_animation_get_animation", 
        "params": [
            {
                "description": "<p>The property animation </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }
        ], 
        "return_desc": "<p>The Animation within this PropertyAnimation </p>", 
        "returns": "Animation *", 
        "warning": null
    }, 
    "property_animation_get_from_gpoint": {
        "description": "<p>Convenience function to retrieve the 'from' GPoint value from property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_get_from_gpoint", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_get_from_grect": {
        "description": "<p>Convenience function to retrieve the 'from' GRect value from property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_get_from_grect", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_get_from_int16": {
        "description": "<p>Convenience function to retrieve the 'from' <code>int16_t</code> value from property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_get_from_int16", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_get_subject": {
        "description": "<p>Retrieve the subject of a property animation. </p>", 
        "kind": "def", 
        "name": "property_animation_get_subject", 
        "params": [], 
        "return_desc": "<p>The subject of this PropertyAnimation </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_get_to_gpoint": {
        "description": "<p>Convenience function to retrieve the 'to' GPoint value from property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_get_to_gpoint", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_get_to_grect": {
        "description": "<p>Convenience function to retrieve the 'to' GRect value from property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_get_to_grect", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_get_to_int16": {
        "description": "<p>Convenience function to retrieve the 'to' <code>int16_t</code> value from property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_get_to_int16", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_from_gpoint": {
        "description": "<p>Convenience function to set the 'from' GPoint value of property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_set_from_gpoint", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_from_grect": {
        "description": "<p>Convenience function to set the 'from' GRect value of property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_set_from_grect", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_from_int16": {
        "description": "<p>Convenience function to set the 'from' <code>int16_t</code> value of property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_set_from_int16", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_subject": {
        "description": "<p>Set the subject of a property animation. </p>", 
        "kind": "def", 
        "name": "property_animation_set_subject", 
        "params": [], 
        "return_desc": null, 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_to_gpoint": {
        "description": "<p>Convenience function to set the 'to' GPoint value of property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_set_to_gpoint", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_to_grect": {
        "description": "<p>Convenience function to set the 'to' GRect value of property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_set_to_grect", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_set_to_int16": {
        "description": "<p>Convenience function to set the 'to' <code>int16_t</code> value of property animation handle. </p>", 
        "kind": "def", 
        "name": "property_animation_set_to_int16", 
        "params": [], 
        "return_desc": "<p>true on success, false on failure </p>", 
        "returns": "", 
        "warning": null
    }, 
    "property_animation_subject": {
        "description": "<p>Helper function used by the <code>property_animation_get</code>|<code>set_subject</code> macros. </p>", 
        "kind": "fn", 
        "name": "property_animation_subject", 
        "params": [
            {
                "description": "<p>Handle to the property animation </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>The subject to get or set. </p>", 
                "name": "subject", 
                "type": "void **"
            }, 
            {
                "description": "<p>true to set new subject, false to retrieve existing value </p>", 
                "name": "set", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure (usually a bad <code>animation_h</code>) </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "property_animation_to": {
        "description": "<p>Helper function used by the <code>property_animation_get</code>|<code>set_to_</code>.* macros. </p>", 
        "kind": "fn", 
        "name": "property_animation_to", 
        "params": [
            {
                "description": "<p>handle to the property animation </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>Pointer to the value </p>", 
                "name": "to", 
                "type": "void *"
            }, 
            {
                "description": "<p>Size of the to value </p>", 
                "name": "size", 
                "type": "size_t"
            }, 
            {
                "description": "<p>true to set new value, false to retrieve existing one </p>", 
                "name": "set", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>true if successful, false on failure (usually a bad <code>animation_h</code>) </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "property_animation_update_gcolor8": {
        "description": "<p>Default update callback for a property animations to update a property of type GColor8. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types GColor8Getter and GColor8Setter. The implementation of this function will calculate the next rectangle of the animation and call the setter to set the new value upon the subject. </p>", 
        "kind": "fn", 
        "name": "property_animation_update_gcolor8", 
        "params": [
            {
                "description": "<p>The property animation for which the update is requested. </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>The current normalized distance. See AnimationUpdateImplementation </p>", 
                "name": "distance_normalized", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>"
    }, 
    "property_animation_update_gpoint": {
        "description": "<p>Default update callback for a property animations to update a property of type GPoint. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types GPointGetter and GPointSetter. The implementation of this function will calculate the next point of the animation and call the setter to set the new point upon the subject. </p>", 
        "kind": "fn", 
        "name": "property_animation_update_gpoint", 
        "params": [
            {
                "description": "<p>The property animation for which the update is requested. </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>The current normalized distance. See AnimationUpdateImplementation </p>", 
                "name": "distance_normalized", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>"
    }, 
    "property_animation_update_grect": {
        "description": "<p>Default update callback for a property animations to update a property of type GRect. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types GRectGetter and GRectSetter. The implementation of this function will calculate the next rectangle of the animation and call the setter to set the new rectangle upon the subject. </p>", 
        "kind": "fn", 
        "name": "property_animation_update_grect", 
        "params": [
            {
                "description": "<p>The property animation for which the update is requested. </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>The current normalized distance. See AnimationUpdateImplementation </p>", 
                "name": "distance_normalized", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>"
    }, 
    "property_animation_update_int16": {
        "description": "<p>Default update callback for a property animations to update a property of type <code>int16_t</code>. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types Int16Getter and Int16Setter. The implementation of this function will calculate the next value of the animation and call the setter to set the new value upon the subject. </p>", 
        "kind": "fn", 
        "name": "property_animation_update_int16", 
        "params": [
            {
                "description": "<p>The property animation for which the update is requested. </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>The current normalized distance. See AnimationUpdateImplementation </p>", 
                "name": "distance_normalized", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>"
    }, 
    "property_animation_update_uint32": {
        "description": "<p>Default update callback for a property animations to update a property of type <code>uint32_t</code>. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types UInt32Getter and UInt32Setter. The implementation of this function will calculate the next value of the animation and call the setter to set the new value upon the subject. </p>", 
        "kind": "fn", 
        "name": "property_animation_update_uint32", 
        "params": [
            {
                "description": "<p>The property animation for which the update is requested. </p>", 
                "name": "property_animation", 
                "type": "PropertyAnimation *"
            }, 
            {
                "description": "<p>The current normalized distance. See AnimationUpdateImplementation </p>", 
                "name": "distance_normalized", 
                "type": "const uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>"
    }, 
    "psleep": {
        "description": "<p>Waits for a certain amount of milliseconds. </p>", 
        "kind": "fn", 
        "name": "psleep", 
        "params": [
            {
                "description": "<p>The number of milliseconds to wait for </p>", 
                "name": "millis", 
                "type": "int"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "resource_get_handle": {
        "description": "<p>appinfo.json. The \"name\" field of each resource is prefixed by <code>RESOURCE_ID_</code> and made visible to the application (through the build/src/<code>resource_ids</code>.auto.h header which is automatically included).</p><p>For example, given the following fragment of appinfo.json: ...\n\"resources\":{\n\"media\":[\n{\n\"name\":\"<code>MY_ICON</code>\",\n\"file\":\"img/icon.png\",\n\"type\":\"png\",\n},\n...\n The generated file identifier for this resource is <code>RESOURCE_ID_MY_ICON</code>. To get a resource handle for that resource write: ResHandlerh=<code>resource_get_handle</code>(<code>RESOURCE_ID_MY_ICON</code>);\n </p>", 
        "kind": "fn", 
        "name": "resource_get_handle", 
        "params": [
            {
                "description": "<p>The resource ID</p>", 
                "name": "resource_id", 
                "type": "uint32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "ResHandle", 
        "warning": null
    }, 
    "resource_load": {
        "description": "<p>Copies the bytes for the resource with a given handle from flash storage into a given buffer. </p>", 
        "kind": "fn", 
        "name": "resource_load", 
        "params": [
            {
                "description": "<p>The handle to the resource </p>", 
                "name": "h", 
                "type": "ResHandle"
            }, 
            {
                "description": "<p>The buffer to load the resource data into </p>", 
                "name": "buffer", 
                "type": "uint8_t *"
            }, 
            {
                "description": "<p>The maximum number of bytes to copy </p>", 
                "name": "max_length", 
                "type": "size_t"
            }
        ], 
        "return_desc": "<p>The number of bytes actually copied </p>", 
        "returns": "size_t", 
        "warning": null
    }, 
    "resource_load_byte_range": {
        "description": "<p>Copies a range of bytes from a resource with a given handle into a given buffer. </p>", 
        "kind": "fn", 
        "name": "resource_load_byte_range", 
        "params": [
            {
                "description": "<p>The handle to the resource </p>", 
                "name": "h", 
                "type": "ResHandle"
            }, 
            {
                "description": "<p>The offset in bytes at which to start reading from the resource </p>", 
                "name": "start_offset", 
                "type": "uint32_t"
            }, 
            {
                "description": "<p>The buffer to load the resource data into </p>", 
                "name": "buffer", 
                "type": "uint8_t *"
            }, 
            {
                "description": "<p>The maximum number of bytes to copy </p>", 
                "name": "num_bytes", 
                "type": "size_t"
            }
        ], 
        "return_desc": "<p>The number of bytes actually copied </p>", 
        "returns": "size_t", 
        "warning": null
    }, 
    "resource_size": {
        "description": "<p>Gets the size of the resource given a resource handle. </p>", 
        "kind": "fn", 
        "name": "resource_size", 
        "params": [
            {
                "description": "<p>The handle to the resource </p>", 
                "name": "h", 
                "type": "ResHandle"
            }
        ], 
        "return_desc": "<p>The size of the resource in bytes </p>", 
        "returns": "size_t", 
        "warning": null
    }, 
    "rot_bitmap_layer_create": {
        "description": "<p><ul><li><p>Angle: 0</p></li><li><p>Compositing mode: GCompOpAssign</p></li><li><p>Corner clip color: GColorClear</p></li></ul>\n</p><p>", 
        "kind": "fn", 
        "name": "rot_bitmap_layer_create", 
        "params": [
            {
                "description": "<p>The bitmap to display in this RotBitmapLayer </p>", 
                "name": "bitmap", 
                "type": "GBitmap *"
            }
        ], 
        "return_desc": "<p>A pointer to the RotBitmapLayer. NULL if the RotBitmapLayer could not be created </p>", 
        "returns": "RotBitmapLayer *", 
        "warning": null
    }, 
    "rot_bitmap_layer_destroy": {
        "description": "<p>Destroys a RotBitmapLayer and frees all associated memory. </p>", 
        "kind": "fn", 
        "name": "rot_bitmap_layer_destroy", 
        "params": [
            {
                "description": "<p>The RotBitmapLayer to destroy. </p>", 
                "name": "bitmap", 
                "type": "RotBitmapLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>It is the developer responsibility to free the GBitmap. </p>"
    }, 
    "rot_bitmap_layer_increment_angle": {
        "description": "<p>Change the rotation angle of this RotBitmapLayer. </p>", 
        "kind": "fn", 
        "name": "rot_bitmap_layer_increment_angle", 
        "params": [
            {
                "description": "<p>The RotBitmapLayer on which to change the rotation </p>", 
                "name": "bitmap", 
                "type": "RotBitmapLayer *"
            }, 
            {
                "description": "<p>The rotation angle change </p>", 
                "name": "angle_change", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "rot_bitmap_layer_set_angle": {
        "description": "<p>Sets the rotation angle of this RotBitmapLayer. </p>", 
        "kind": "fn", 
        "name": "rot_bitmap_layer_set_angle", 
        "params": [
            {
                "description": "<p>The RotBitmapLayer on which to change the rotation </p>", 
                "name": "bitmap", 
                "type": "RotBitmapLayer *"
            }, 
            {
                "description": "<p>Rotation is an integer between 0 (no rotation) and 0x10000 (360 degree rotation). </p>", 
                "name": "angle", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "rot_bitmap_layer_set_corner_clip_color": {
        "description": "<p>Defines what color to use in areas that are not covered by the source bitmap. By default this is GColorClear. </p>", 
        "kind": "fn", 
        "name": "rot_bitmap_layer_set_corner_clip_color", 
        "params": [
            {
                "description": "<p>The RotBitmapLayer on which to change the corner clip color </p>", 
                "name": "bitmap", 
                "type": "RotBitmapLayer *"
            }, 
            {
                "description": "<p>The corner clip color </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "rot_bitmap_set_compositing_mode": {
        "description": "<p>Sets the compositing mode of how the bitmap image is composited onto what has been drawn beneath the RotBitmapLayer. By default this is GCompOpAssign. The RotBitmapLayer is automatically marked dirty after this operation. </p>", 
        "kind": "fn", 
        "name": "rot_bitmap_set_compositing_mode", 
        "params": [
            {
                "description": "<p>The RotBitmapLayer on which to change the rotation </p>", 
                "name": "bitmap", 
                "type": "RotBitmapLayer *"
            }, 
            {
                "description": "<p>The compositing mode to set </p>", 
                "name": "mode", 
                "type": "GCompOp"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "rot_bitmap_set_src_ic": {
        "description": "<p>For example, if you pass GPoint(0, 0), the image will rotate around the top-left corner.</p><p>This point is always projected at the center of the RotBitmapLayer. Calling this function automatically adjusts the width and height of the RotBitmapLayer so that the entire bitmap can fit inside the layer at all rotation angles.</p><p>", 
        "kind": "fn", 
        "name": "rot_bitmap_set_src_ic", 
        "params": [
            {
                "description": "<p>The RotBitmapLayer on which to change the rotation </p>", 
                "name": "bitmap", 
                "type": "RotBitmapLayer *"
            }, 
            {
                "description": "<p>The only point in the original image that will not be affected by the rotation. </p>", 
                "name": "ic", 
                "type": "GPoint"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_add_child": {
        "description": "<p>Adds the child layer to the content sub-layer of the ScrollLayer. This will make the child layer part of the scrollable contents. The content sub-layer of the ScrollLayer will become the parent of the child layer. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_add_child", 
        "params": [
            {
                "description": "<p>The ScrollLayer to which to add the child layer. </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The Layer to add to the content sub-layer of the ScrollLayer. </p>", 
                "name": "child", 
                "type": "Layer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>You may need to update the size of the scrollable contents using <code>scroll_layer_set_content_size()</code>. </p>"
    }, 
    "scroll_layer_create": {
        "description": "<p><ul><li><p>Clips: true</p></li><li><p>Hidden: false</p></li><li><p>Content size: frame.size</p></li><li><p>Content offset: GPointZero</p></li><li><p>Callbacks: None (NULL for each one)</p></li><li><p>Callback context: NULL </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "scroll_layer_create", 
        "params": [
            {
                "description": null, 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>A pointer to the ScrollLayer. NULL if the ScrollLayer could not be created </p>", 
        "returns": "ScrollLayer *", 
        "warning": null
    }, 
    "scroll_layer_destroy": {
        "description": "<p>Destroys a ScrollLayer previously created by <code>scroll_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_get_content_indicator": {
        "description": "<p>Gets the ContentIndicator for a ScrollLayer. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_get_content_indicator", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to get the ContentIndicator </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }
        ], 
        "return_desc": "<p>A pointer to the ContentIndicator, or NULL upon failure. </p>", 
        "returns": "ContentIndicator *", 
        "warning": null
    }, 
    "scroll_layer_get_content_offset": {
        "description": "<p>Gets the point by which the contents are offset. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_get_content_offset", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to get the content offset </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "GPoint", 
        "warning": null
    }, 
    "scroll_layer_get_content_size": {
        "description": "<p>Gets the size of the contents layer. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_get_content_size", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to get the content size </p>", 
                "name": "scroll_layer", 
                "type": "const ScrollLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "GSize", 
        "warning": null
    }, 
    "scroll_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the scroll layer, which is the parent for the sub- layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the ScrollLayer for which to get the \"root\" Layer </p>", 
                "name": "scroll_layer", 
                "type": "const ScrollLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the scroll layer. </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "scroll_layer_get_paging": {
        "description": "<p>Check whether or not the ScrollLayer uses paging when pressing buttons. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_get_paging", 
        "params": [
            {
                "description": "<p>The scroll layer for which to get the paging behavior. </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }
        ], 
        "return_desc": "<p>True, if paging is enabled; false otherwise. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "scroll_layer_get_shadow_hidden": {
        "description": "<p>Gets the visibility of the scroll layer shadow. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_get_shadow_hidden", 
        "params": [
            {
                "description": "<p>The scroll layer for which to get the visibility </p>", 
                "name": "scroll_layer", 
                "type": "const ScrollLayer *"
            }
        ], 
        "return_desc": "<p>True if the shadow is hidden, false if it is not hidden. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "scroll_layer_scroll_down_click_handler": {
        "description": "<p>The click handlers for the DOWN button that the scroll layer will install as part of <code>scroll_layer_set_click_config_onto_window()</code>. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_scroll_down_click_handler", 
        "params": [
            {
                "description": "<p>The click recognizer for which the handler is called </p>", 
                "name": "recognizer", 
                "type": "ClickRecognizerRef"
            }, 
            {
                "description": "<p>A void pointer to the ScrollLayer that is the context of the click event </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This handler is exposed, in case one wants to implement an alternative handler for the DOWN button, as a way to invoke the default behavior. </p>"
    }, 
    "scroll_layer_scroll_up_click_handler": {
        "description": "<p>The click handlers for the UP button that the scroll layer will install as part of <code>scroll_layer_set_click_config_onto_window()</code>. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_scroll_up_click_handler", 
        "params": [
            {
                "description": "<p>The click recognizer for which the handler is called </p>", 
                "name": "recognizer", 
                "type": "ClickRecognizerRef"
            }, 
            {
                "description": "<p>A void pointer to the ScrollLayer that is the context of the click event </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This handler is exposed, in case one wants to implement an alternative handler for the UP button, as a way to invoke the default behavior. </p>"
    }, 
    "scroll_layer_set_callbacks": {
        "description": "<p>Sets the callbacks that the scroll layer exposes. The context as set by <code>scroll_layer_set_context()</code> is passed into each of the callbacks. See ScrollLayerCallbacks for the different callbacks. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_callbacks", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to assign new callbacks. </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The new callbacks. </p>", 
                "name": "callbacks", 
                "type": "ScrollLayerCallbacks"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the context is NULL, a pointer to <code>scroll_layer</code> is used as context parameter instead when calling callbacks. </p>"
    }, 
    "scroll_layer_set_click_config_onto_window": {
        "description": "<p>If you application has set a .<code>click_config_provider</code> callback using <code>scroll_layer_set_callbacks()</code>, this will be called by the internal click config provider, after configuring the UP & DOWN buttons. This allows your application to configure the SELECT button behavior and optionally override the UP & DOWN button behavior. The callback context for the SELECT click recognizer is automatically set to the scroll layer's context (see <code>scroll_layer_set_context()</code> ). This context is passed into ClickHandler callbacks. For the UP and DOWN buttons, the scroll layer itself is passed in by default as the callback context in order to deal with those buttons presses to scroll up and down automatically. \n\n</p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_click_config_onto_window", 
        "params": [
            {
                "description": "<p>The ScrollLayer that needs to receive click events. </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The window for which to set the click configuration. </p>", 
                "name": "window", 
                "type": "struct Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_set_content_offset": {
        "description": "<p><p>The .x field must be 0. Horizontal scrolling is not supported. </p>\n\n</p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_content_offset", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to set the content offset </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The final content offset </p>", 
                "name": "offset", 
                "type": "GPoint"
            }, 
            {
                "description": "<p>Pass in true to animate to the new content offset, or false to set the new content offset without animating. </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>When scrolling down, the offset's .y decrements. When scrolling up, the offset's .y increments. If scrolled completely to the top, the offset is GPointZero. </p>"
    }, 
    "scroll_layer_set_content_size": {
        "description": "<p>Sets the size of the contents layer. This determines the area that is scrollable. At the moment, this needs to be set \"manually\" and is not derived from the geometry of the contents layers. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_content_size", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to set the content size. </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The new content size. </p>", 
                "name": "size", 
                "type": "GSize"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_set_context": {
        "description": "<p>Sets a new callback context. This context is passed into the scroll layer's callbacks and also the ClickHandler for the SELECT button. If NULL or not set, the context defaults to a pointer to the ScrollLayer itself. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_context", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to assign the new callback context. </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The new callback context. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_set_frame": {
        "description": "<p>Set the frame of the scroll layer and adjusts the internal layers' geometry accordingly. The scroll layer is marked dirty automatically. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_frame", 
        "params": [
            {
                "description": "<p>The ScrollLayer for which to set the frame </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>The new frame </p>", 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_set_paging": {
        "description": "<p>Enables or disables paging of the ScrollLayer (default: disabled). When enabled, every button press will change the scroll offset by the frame's height. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_paging", 
        "params": [
            {
                "description": "<p>The scroll layer for which to enable or disable paging </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>True, if paging should be enabled. False to enable. </p>", 
                "name": "paging_enabled", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "scroll_layer_set_shadow_hidden": {
        "description": "<p>Sets the visibility of the scroll layer shadow. If the visibility has changed, <code>layer_mark_dirty()</code> will be called automatically on the scroll layer. </p>", 
        "kind": "fn", 
        "name": "scroll_layer_set_shadow_hidden", 
        "params": [
            {
                "description": "<p>The scroll layer for which to set the shadow visibility </p>", 
                "name": "scroll_layer", 
                "type": "ScrollLayer *"
            }, 
            {
                "description": "<p>Supply true to make the shadow hidden, or false to make it non-hidden. </p>", 
                "name": "hidden", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "simple_menu_layer_create": {
        "description": "<p>Creates a new SimpleMenuLayer on the heap and initializes it. It also sets the internal click configuration provider onto given window. </p>", 
        "kind": "fn", 
        "name": "simple_menu_layer_create", 
        "params": [
            {
                "description": "<p>The frame at which to initialize the menu </p>", 
                "name": "frame", 
                "type": "GRect"
            }, 
            {
                "description": "<p>The window onto which to set the click configuration provider </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>Array with sections that need to be displayed in the menu </p>", 
                "name": "sections", 
                "type": "const SimpleMenuSection *"
            }, 
            {
                "description": "<p>The number of sections in the sections array. </p>", 
                "name": "num_sections", 
                "type": "int32_t"
            }, 
            {
                "description": "<p>Pointer to application specific data, that is passed into the callbacks. </p>", 
                "name": "callback_context", 
                "type": "void *"
            }
        ], 
        "return_desc": "<p>A pointer to the SimpleMenuLayer. NULL if the SimpleMenuLayer could not be created </p>", 
        "returns": "SimpleMenuLayer *", 
        "warning": "<p>The sections array is not deep-copied and can therefore not be stack allocated, but needs to be backed by long-lived storage. </p>"
    }, 
    "simple_menu_layer_destroy": {
        "description": "<p>Destroys a SimpleMenuLayer previously created by <code>simple_menu_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "simple_menu_layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "menu_layer", 
                "type": "SimpleMenuLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "simple_menu_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the simple menu layer, which is the parent for the sub-layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "simple_menu_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the SimpleMenuLayer for which to get the \"root\" Layer </p>", 
                "name": "simple_menu", 
                "type": "const SimpleMenuLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the menu layer. </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "simple_menu_layer_get_menu_layer": {
        "description": "", 
        "kind": "fn", 
        "name": "simple_menu_layer_get_menu_layer", 
        "params": [
            {
                "description": "<p>The SimpleMenuLayer to get the MenuLayer from. </p>", 
                "name": "simple_menu", 
                "type": "SimpleMenuLayer *"
            }
        ], 
        "return_desc": "<p>The MenuLayer. </p>", 
        "returns": "MenuLayer *", 
        "warning": null
    }, 
    "simple_menu_layer_get_selected_index": {
        "description": "<p>Gets the row index of the currently selection menu item. </p>", 
        "kind": "fn", 
        "name": "simple_menu_layer_get_selected_index", 
        "params": [
            {
                "description": "<p>The SimpleMenuLayer for which to get the current selected row index. </p>", 
                "name": "simple_menu", 
                "type": "const SimpleMenuLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "int", 
        "warning": null
    }, 
    "simple_menu_layer_set_selected_index": {
        "description": "<p>Selects the item in the first section at given row index. </p>", 
        "kind": "fn", 
        "name": "simple_menu_layer_set_selected_index", 
        "params": [
            {
                "description": "<p>The SimpleMenuLayer for which to change the selection </p>", 
                "name": "simple_menu", 
                "type": "SimpleMenuLayer *"
            }, 
            {
                "description": "<p>The row index of the item to select </p>", 
                "name": "index", 
                "type": "int32_t"
            }, 
            {
                "description": "<p>Supply true to animate changing the selection, or false to change the selection instantly. </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "sin_lookup": {
        "description": "<p>Look-up the sine of the given angle from a pre-computed table. </p>", 
        "kind": "fn", 
        "name": "sin_lookup", 
        "params": [
            {
                "description": "<p>The angle for which to compute the cosine. The angle value is scaled linearly, such that a value of 0x10000 corresponds to 360 degrees or 2 PI radians. </p>", 
                "name": "angle", 
                "type": "int32_t"
            }
        ], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "smartstrap_attribute_begin_write": {
        "description": "<p>Begins a write request for the specified attribute and returns a buffer into which the app should write the data before calling <code>smartstrap_attribute_end_write</code>. </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_begin_write", 
        "params": [
            {
                "description": "<p>The attribute to begin writing for. </p>", 
                "name": "attribute", 
                "type": "SmartstrapAttribute *"
            }, 
            {
                "description": "<p>The buffer to write the data into. </p>", 
                "name": "buffer", 
                "type": "uint8_t **"
            }, 
            {
                "description": "<p>The length of the buffer in bytes. </p>", 
                "name": "buffer_length", 
                "type": "size_t *"
            }
        ], 
        "return_desc": "<p>SmartstrapResultOk if a write operation was started and the buffer and <code>buffer_length</code> parameters were set, or an error otherwise. </p>", 
        "returns": "SmartstrapResult", 
        "warning": "<p>The buffer must not be used after <code>smartstrap_attribute_end_write</code> is called. </p>"
    }, 
    "smartstrap_attribute_create": {
        "description": "<p>Creates and returns a SmartstrapAttribute for the specified service and attribute. This API will allocate an internal buffer of the requested length on the app's heap. </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_create", 
        "params": [
            {
                "description": "<p>The ServiceId to create the attribute for. </p>", 
                "name": "service_id", 
                "type": "SmartstrapServiceId"
            }, 
            {
                "description": "<p>The AttributeId to create the attribute for. </p>", 
                "name": "attribute_id", 
                "type": "SmartstrapAttributeId"
            }, 
            {
                "description": "<p>The length of the internal buffer which will be used to store the read and write requests for this attribute. </p>", 
                "name": "buffer_length", 
                "type": "size_t"
            }
        ], 
        "return_desc": "<p>The newly created SmartstrapAttribute or NULL if an internal error occured or if the specified length is greater than <code>SMARTSTRAP_ATTRIBUTE_LENGTH_MAXIMUM</code>. </p>", 
        "returns": "SmartstrapAttribute *", 
        "warning": "<p>Creating an attribute will result in power being applied to the smartstrap port (if it isn't already) and connection establishment to begin. </p>"
    }, 
    "smartstrap_attribute_destroy": {
        "description": "<p>Destroys a SmartstrapAttribute. No further handlers will be called for this attribute and it may not be used for any future requests. </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_destroy", 
        "params": [
            {
                "description": "<p>The SmartstrapAttribute which should be destroyed. </p>", 
                "name": "attribute", 
                "type": "SmartstrapAttribute *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If power was being applied to the smartstrap port, no <code>availability_did_change</code> handler is subscribed, and the last attribute is being destroyed, this will cause the smartstrap power to be turned off. </p>"
    }, 
    "smartstrap_attribute_end_write": {
        "description": "<p>This should be called by the app when it is done writing to the buffer provided by <code>smartstrap_begin_write</code> and the data is ready to be sent to the smartstrap. </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_end_write", 
        "params": [
            {
                "description": "<p>The attribute to begin writing for. </p>", 
                "name": "attribute", 
                "type": "SmartstrapAttribute *"
            }, 
            {
                "description": "<p>The length of the data to be written, in bytes. </p>", 
                "name": "write_length", 
                "type": "size_t"
            }, 
            {
                "description": "<p>Whether or not a read request on this attribute should be automatically triggered following a successful write request. </p>", 
                "name": "request_read", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>SmartstrapResultOk if a write operation was queued to be sent to the smartstrap. The <code>did_write</code> handler will be called when the request is written to the smartstrap, and if <code>request_read</code> was set to true, the <code>did_read</code> handler will be called when the read is complete. </p>", 
        "returns": "SmartstrapResult", 
        "warning": null
    }, 
    "smartstrap_attribute_get_attribute_id": {
        "description": "<p>Gets the AttributeId which the attribute was created for (see <code>smartstrap_attribute_create</code>). </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_get_attribute_id", 
        "params": [
            {
                "description": "<p>The SmartstrapAttribute for which to obtain the attribute ID. </p>", 
                "name": "attribute", 
                "type": "SmartstrapAttribute *"
            }
        ], 
        "return_desc": "<p>The SmartstrapAttributeId which the attribute was created with. </p>", 
        "returns": "SmartstrapAttributeId", 
        "warning": null
    }, 
    "smartstrap_attribute_get_service_id": {
        "description": "<p>Returns the ServiceId which the attribute was created for (see <code>smartstrap_attribute_create</code>). </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_get_service_id", 
        "params": [
            {
                "description": "<p>The SmartstrapAttribute for which to obtain the service ID. </p>", 
                "name": "attribute", 
                "type": "SmartstrapAttribute *"
            }
        ], 
        "return_desc": "<p>The SmartstrapServiceId which the attribute was created with. </p>", 
        "returns": "SmartstrapServiceId", 
        "warning": null
    }, 
    "smartstrap_attribute_read": {
        "description": "<p>Performs a read request for the specified attribute. The <code>did_read</code> callback will be called when the response is received from the smartstrap or when an error occurs. </p>", 
        "kind": "fn", 
        "name": "smartstrap_attribute_read", 
        "params": [
            {
                "description": "<p>The attribute to be perform the read request on. </p>", 
                "name": "attribute", 
                "type": "SmartstrapAttribute *"
            }
        ], 
        "return_desc": "<p>SmartstrapResultOk if the read operation was started. The <code>did_read</code> callback will be called once the read request has been completed. </p>", 
        "returns": "SmartstrapResult", 
        "warning": null
    }, 
    "smartstrap_service_is_available": {
        "description": "<p>Checks whether or not the specified service is currently supported by a connected smartstrap. </p>", 
        "kind": "fn", 
        "name": "smartstrap_service_is_available", 
        "params": [
            {
                "description": "<p>The SmartstrapServiceId of the service to check for availability. </p>", 
                "name": "service_id", 
                "type": "SmartstrapServiceId"
            }
        ], 
        "return_desc": "<p>Whether or not the service is available. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "smartstrap_set_timeout": {
        "description": "<p>Changes the value of the timeout which is used for smartstrap requests. This timeout is started after the request is completely sent to the smartstrap and will be canceled only if the entire response is received before it triggers. The new timeout value will take affect only for requests made after this API is called. </p>", 
        "kind": "fn", 
        "name": "smartstrap_set_timeout", 
        "params": [
            {
                "description": "<p>The duration of the timeout to set, in milliseconds. </p>", 
                "name": "timeout_ms", 
                "type": "uint16_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>The maximum allowed timeout is currently 1000ms. If a larger value is passed, it will be internally lowered to the maximum. </p>"
    }, 
    "smartstrap_subscribe": {
        "description": "<p>Subscribes handlers to be called after certain smartstrap events occur. </p>", 
        "kind": "fn", 
        "name": "smartstrap_subscribe", 
        "params": [
            {
                "description": null, 
                "name": "handlers", 
                "type": "SmartstrapHandlers"
            }
        ], 
        "return_desc": "<p>SmartstrapResultNotPresent if the watch does not have a smartstrap port or SmartstrapResultOk otherwise. </p>", 
        "returns": "SmartstrapResult", 
        "warning": "<p>Registering an <code>availability_did_change</code> handler will cause power to be applied to the smartstrap port and connection establishment to begin. </p>"
    }, 
    "smartstrap_unsubscribe": {
        "description": "<p>Unsubscribes the handlers. The handlers will no longer be called, but in-flight requests will otherwise be unaffected. </p>", 
        "kind": "fn", 
        "name": "smartstrap_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If power was being applied to the smartstrap port and there are no attributes have been created (or they have all been destroyed), this will cause the smartstrap power to be turned off. </p>"
    }, 
    "status_bar_layer_create": {
        "description": "<p><ul><li><p>Text color: GColorBlack</p></li><li><p>Background color: GColorWhite</p></li><li><p>Frame: GRect(0, 0, <code>screen_width</code>, <code>STATUS_BAR_LAYER_HEIGHT</code>) The status bar is automatically marked dirty after this operation. You can call <code>layer_set_frame()</code> to create a StatusBarLayer of a different width.</p></li></ul>\n</p><p>//Changethestatusbarwidthtomakespacefortheactionbar\n<code>int16_twidth</code>=<code>layer_get_bounds</code>(<code>root_layer</code>).size.w-<code>ACTION_BAR_WIDTH</code>;\nGRectframe=GRect(0,0,width,<code>STATUS_BAR_LAYER_HEIGHT</code>);\n<code>layer_set_frame</code>(<code>status_bar_layer_get_layer</code>(<code>status_bar</code>),frame);\n<code>layer_add_child</code>(<code>root_layer</code>,<code>status_bar_layer_get_layer</code>(<code>status_bar</code>));", 
        "kind": "fn", 
        "name": "status_bar_layer_create", 
        "params": [], 
        "return_desc": "<p>A pointer to the StatusBarLayer, which will be allocated to the heap, NULL if the StatusBarLayer could not be created </p>", 
        "returns": "StatusBarLayer *", 
        "warning": null
    }, 
    "status_bar_layer_destroy": {
        "description": "<p>Destroys a StatusBarLayer previously created by <code>status_bar_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "status_bar_layer_destroy", 
        "params": [
            {
                "description": "<p>The StatusBarLayer to destroy </p>", 
                "name": "status_bar_layer", 
                "type": "StatusBarLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "status_bar_layer_get_background_color": {
        "description": "<p>Gets background color of StatusBarLayer. </p>", 
        "kind": "fn", 
        "name": "status_bar_layer_get_background_color", 
        "params": [
            {
                "description": "<p>The StatusBarLayer of which to get the color </p>", 
                "name": "status_bar_layer", 
                "type": "const StatusBarLayer *"
            }
        ], 
        "return_desc": "<p>GColor of background color property </p>", 
        "returns": "GColor", 
        "warning": null
    }, 
    "status_bar_layer_get_foreground_color": {
        "description": "<p>Gets foreground color of StatusBarLayer. </p>", 
        "kind": "fn", 
        "name": "status_bar_layer_get_foreground_color", 
        "params": [
            {
                "description": "<p>The StatusBarLayer of which to get the color </p>", 
                "name": "status_bar_layer", 
                "type": "const StatusBarLayer *"
            }
        ], 
        "return_desc": "<p>GColor of foreground color property </p>", 
        "returns": "GColor", 
        "warning": null
    }, 
    "status_bar_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the status bar, which is the parent for the sub- layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "status_bar_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the StatusBarLayer for which to get the \"root\" Layer </p>", 
                "name": "status_bar_layer", 
                "type": "StatusBarLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the status bar. </p>", 
        "returns": "Layer *", 
        "warning": "<p>The result is always equal to (Layer *) <code>status_bar_layer</code>. </p>"
    }, 
    "status_bar_layer_set_colors": {
        "description": "<p>Sets the background and foreground colors of StatusBarLayer. </p>", 
        "kind": "fn", 
        "name": "status_bar_layer_set_colors", 
        "params": [
            {
                "description": "<p>The StatusBarLayer of which to set the colors </p>", 
                "name": "status_bar_layer", 
                "type": "StatusBarLayer *"
            }, 
            {
                "description": "<p>The new GColor to set for background </p>", 
                "name": "background", 
                "type": "GColor"
            }, 
            {
                "description": "<p>The new GColor to set for text and other foreground elements </p>", 
                "name": "foreground", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "status_bar_layer_set_separator_mode": {
        "description": "<p>Sets the mode of the StatusBarLayer separator, to help divide it from content. </p>", 
        "kind": "fn", 
        "name": "status_bar_layer_set_separator_mode", 
        "params": [
            {
                "description": "<p>The StatusBarLayer of which to set the separator mode </p>", 
                "name": "status_bar_layer", 
                "type": "StatusBarLayer *"
            }, 
            {
                "description": "<p>Determines the separator mode </p>", 
                "name": "mode", 
                "type": "StatusBarLayerSeparatorMode"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "status_t": {
        "description": "<p>Return value for system operations. See StatusCode for possible values. </p>", 
        "kind": "typedef", 
        "name": "status_t", 
        "params": [], 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null
    }, 
    "strftime": {
        "description": "<p>Format the time value at tm according to fmt and place the result in a buffer s of size max. </p>", 
        "kind": "fn", 
        "name": "strftime", 
        "params": [
            {
                "description": "<p>A preallocation char array of size max </p>", 
                "name": "s", 
                "type": "char *"
            }, 
            {
                "description": "<p>the size of the array s </p>", 
                "name": "maxsize", 
                "type": "size_t"
            }, 
            {
                "description": "<p>a formatting string </p>", 
                "name": "format", 
                "type": "const char *"
            }, 
            {
                "description": "<p>A pointer to a struct tm containing a broken out time value </p>", 
                "name": "tm_p", 
                "type": "const struct tm *"
            }
        ], 
        "return_desc": "<p>The number of bytes placed in the array s, not including the null byte, 0 if the value does not fit. </p>", 
        "returns": "int", 
        "warning": null
    }, 
    "text_layer_create": {
        "description": "<p><ul><li><p>Font: Raster Gothic 14-point Boldface (system font)</p></li><li><p>Text Alignment: GTextAlignmentLeft</p></li><li><p>Text color: GColorBlack</p></li><li><p>Background color: GColorWhite</p></li><li><p>Clips: true</p></li><li><p>Hidden: false</p></li><li><p>Caching: false</p></li></ul>\n</p><p>The text layer is automatically marked dirty after this operation.", 
        "kind": "fn", 
        "name": "text_layer_create", 
        "params": [
            {
                "description": "<p>The frame with which to initialze the TextLayer </p>", 
                "name": "frame", 
                "type": "GRect"
            }
        ], 
        "return_desc": "<p>A pointer to the TextLayer. NULL if the TextLayer could not be created </p>", 
        "returns": "TextLayer *", 
        "warning": null
    }, 
    "text_layer_destroy": {
        "description": "<p>Destroys a TextLayer previously created by <code>text_layer_create</code>. </p>", 
        "kind": "fn", 
        "name": "text_layer_destroy", 
        "params": [
            {
                "description": null, 
                "name": "text_layer", 
                "type": "TextLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_enable_screen_text_flow_and_paging": {
        "description": "<p>Enables text flow following the boundaries of the screen and pagination that introduces extra line spacing at page breaks to avoid partially clipped lines for the TextLayer. If the TextLayer is part of a ScrollLayer the ScrollLayer's frame will be used to configure paging. </p>", 
        "kind": "fn", 
        "name": "text_layer_enable_screen_text_flow_and_paging", 
        "params": [
            {
                "description": "<p>The TextLayer for which to enable text flow and paging </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>Additional amount of pixels to inset to the inside of the screen for text flow </p>", 
                "name": "inset", 
                "type": "uint8_t"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Make sure the TextLayer is part of the view hierarchy before calling this function. Otherwise it has no effect. </p>"
    }, 
    "text_layer_get_content_size": {
        "description": "<p>Calculates the size occupied by the current text of the TextLayer. </p>", 
        "kind": "fn", 
        "name": "text_layer_get_content_size", 
        "params": [
            {
                "description": "<p>the TextLayer for which to calculate the text's size </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }
        ], 
        "return_desc": "<p>The size occupied by the current text of the TextLayer </p>", 
        "returns": "GSize", 
        "warning": null
    }, 
    "text_layer_get_layer": {
        "description": "<p>Gets the \"root\" Layer of the text layer, which is the parent for the sub- layers used for its implementation. </p>", 
        "kind": "fn", 
        "name": "text_layer_get_layer", 
        "params": [
            {
                "description": "<p>Pointer to the TextLayer for which to get the \"root\" Layer </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }
        ], 
        "return_desc": "<p>The \"root\" Layer of the text layer. </p>", 
        "returns": "Layer *", 
        "warning": null
    }, 
    "text_layer_get_text": {
        "description": "<p>Gets the pointer to the string that the TextLayer is using. </p>", 
        "kind": "fn", 
        "name": "text_layer_get_text", 
        "params": [
            {
                "description": "<p>The TextLayer for which to get the text </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "const char *", 
        "warning": null
    }, 
    "text_layer_restore_default_text_flow_and_paging": {
        "description": "<p>Restores text flow and paging for the TextLayer to the rectangular defaults. </p>", 
        "kind": "fn", 
        "name": "text_layer_restore_default_text_flow_and_paging", 
        "params": [
            {
                "description": "<p>The TextLayer for which to restore text flow and paging </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_set_background_color": {
        "description": "<p>Sets the background color of the bounding box that will be drawn behind the text. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_background_color", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the background color </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new GColor to set the background to </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_set_font": {
        "description": "<p>Sets the font of the TextLayer. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_font", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the font </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new GFont for the TextLayer </p>", 
                "name": "font", 
                "type": "GFont"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_set_overflow_mode": {
        "description": "<p>Sets the line break mode of the TextLayer. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_overflow_mode", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the overflow mode </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new GTextOverflowMode to set </p>", 
                "name": "line_mode", 
                "type": "GTextOverflowMode"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_set_size": {
        "description": "<p>Update the size of the text layer This is a convenience function to update the frame of the TextLayer. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_size", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the size </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new size for the TextLayer </p>", 
                "name": "max_size", 
                "type": "const GSize"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_set_text": {
        "description": "<p>Sets the pointer to the string where the TextLayer is supposed to find the text at a later point in time, when it needs to draw itself. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_text", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the text </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new text to set onto the TextLayer. This must be a null-terminated and valid UTF-8 string! </p>", 
                "name": "text", 
                "type": "const char *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>The string is not copied, so its buffer most likely cannot be stack allocated, but is recommended to be a buffer that is long-lived, at least as long as the TextLayer is part of a visible Layer hierarchy. </p>"
    }, 
    "text_layer_set_text_alignment": {
        "description": "<p>Sets the alignment of the TextLayer. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_text_alignment", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the alignment </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new text alignment for the TextLayer </p>", 
                "name": "text_alignment", 
                "type": "GTextAlignment"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "text_layer_set_text_color": {
        "description": "<p>Sets the color of text that will be drawn. </p>", 
        "kind": "fn", 
        "name": "text_layer_set_text_color", 
        "params": [
            {
                "description": "<p>The TextLayer of which to set the text color </p>", 
                "name": "text_layer", 
                "type": "TextLayer *"
            }, 
            {
                "description": "<p>The new GColor to set the text color to </p>", 
                "name": "color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "tick_timer_service_subscribe": {
        "description": "<p>Subscribe to the tick timer event service. Once subscribed, the handler gets called on every requested unit change. Calling this function multiple times will override the units and handler (i.e., only\u00a0 the\u00a0last\u00a0<code>tick_units</code> and\u00a0handler passed\u00a0will\u00a0be\u00a0used). </p>", 
        "kind": "fn", 
        "name": "tick_timer_service_subscribe", 
        "params": [
            {
                "description": "<p>a bitmask of all the units that have changed </p>", 
                "name": "tick_units", 
                "type": "TimeUnits"
            }, 
            {
                "description": "<p>The callback to be executed on tick events </p>", 
                "name": "handler", 
                "type": "TickHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "tick_timer_service_unsubscribe": {
        "description": "<p>Unsubscribe from the tick timer event service. Once unsubscribed, the previously registered handler will no longer be called. </p>", 
        "kind": "fn", 
        "name": "tick_timer_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "time": {
        "description": "<p>Obtain the number of seconds since epoch. Note that the epoch is not adjusted for Timezones and Daylight Savings. </p>", 
        "kind": "fn", 
        "name": "time", 
        "params": [
            {
                "description": "<p>Optionally points to an address of a <code>time_t</code> variable to store the time in. If you only want to use the return value, you may pass NULL into tloc instead </p>", 
                "name": "tloc", 
                "type": "time_t *"
            }
        ], 
        "return_desc": "<p>The number of seconds since epoch, January 1st 1970 </p>", 
        "returns": "time_t", 
        "warning": null
    }, 
    "time_ms": {
        "description": "<p>Obtain the number of seconds and milliseconds part since the epoch. This is a non-standard C function provided for convenience. </p>", 
        "kind": "fn", 
        "name": "time_ms", 
        "params": [
            {
                "description": null, 
                "name": "t_utc", 
                "type": "time_t *"
            }, 
            {
                "description": "<p>Optionally points to an address of a <code>uint16_t</code> variable to store the number of milliseconds since the last second in. If you only want to use the return value, you may pass NULL into <code>out_ms</code> instead </p>", 
                "name": "out_ms", 
                "type": "uint16_t *"
            }
        ], 
        "return_desc": "<p>The number of milliseconds since the last second </p>", 
        "returns": "uint16_t", 
        "warning": null
    }, 
    "time_start_of_today": {
        "description": "<p>Return the UTC time that corresponds to the start of today (midnight). </p>", 
        "kind": "fn", 
        "name": "time_start_of_today", 
        "params": [], 
        "return_desc": "<p>the UTC time corresponding to the start of today (midnight) </p>", 
        "returns": "time_t", 
        "warning": null
    }, 
    "unobstructed_area_service_subscribe": {
        "description": "<p>Subscribe to be notified when the app's unobstructed area changes. When an unobstructed area begins changing, the <code>will_change</code> handler will be called, and every <code>will_change</code> call is always paired with a <code>did_change</code> call that occurs when it is done changing given that the <code>will_change</code> and <code>did_change</code> handlers are set. When subscribing while the unobstructed area is changing, the <code>will_change</code> handler will be called after subscription in the next event loop. </p>", 
        "kind": "fn", 
        "name": "unobstructed_area_service_subscribe", 
        "params": [
            {
                "description": "<p>The handlers that should be called when the unobstructed area changes. </p>", 
                "name": "handlers", 
                "type": "UnobstructedAreaHandlers"
            }, 
            {
                "description": "<p>A user-provided context that will be passed to the callback handlers. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "unobstructed_area_service_unsubscribe": {
        "description": "<p>Unsubscribe from notifications about changes to the app's unobstructed area. </p>", 
        "kind": "fn", 
        "name": "unobstructed_area_service_unsubscribe", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "uuid_equal": {
        "description": "<p>Compares two UUIDs. </p>", 
        "kind": "fn", 
        "name": "uuid_equal", 
        "params": [
            {
                "description": null, 
                "name": "uu1", 
                "type": "const Uuid *"
            }, 
            {
                "description": null, 
                "name": "uu2", 
                "type": "const Uuid *"
            }
        ], 
        "return_desc": "<p>True if the two UUIDs are equal, false if they are not. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "uuid_to_string": {
        "description": "<p>Writes UUID in a string form into buffer that looks like the following... {12345678-1234-5678-1234-567812345678} or {NULL UUID} if NULL was passed. </p>", 
        "kind": "fn", 
        "name": "uuid_to_string", 
        "params": [
            {
                "description": "<p>The Uuid to write into the buffer as human-readable string </p>", 
                "name": "uuid", 
                "type": "const Uuid *"
            }, 
            {
                "description": "<p>Memory to write the string to. Must be at least <code>UUID_STRING_BUFFER_LENGTH</code> bytes long. </p>", 
                "name": "buffer", 
                "type": "char *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "vibes_cancel": {
        "description": "<p>Cancel any in-flight vibe patterns; this is a no-op if there is no on-going vibe. </p>", 
        "kind": "fn", 
        "name": "vibes_cancel", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "vibes_double_pulse": {
        "description": "<p>Makes the watch emit two brief vibrations. </p>", 
        "kind": "fn", 
        "name": "vibes_double_pulse", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "vibes_enqueue_custom_pattern": {
        "description": "<p>Makes the watch emit a \u2018custom\u2019 vibration pattern. </p>", 
        "kind": "fn", 
        "name": "vibes_enqueue_custom_pattern", 
        "params": [
            {
                "description": "<p>An arbitrary vibration pattern </p>", 
                "name": "pattern", 
                "type": "VibePattern"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "vibes_long_pulse": {
        "description": "<p>Makes the watch emit one long vibration. </p>", 
        "kind": "fn", 
        "name": "vibes_long_pulse", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "vibes_short_pulse": {
        "description": "<p>Makes the watch emit one short vibration. </p>", 
        "kind": "fn", 
        "name": "vibes_short_pulse", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "wakeup_cancel": {
        "description": "<p>Cancels a wakeup event. </p>", 
        "kind": "fn", 
        "name": "wakeup_cancel", 
        "params": [
            {
                "description": "<p>Wakeup event to cancel </p>", 
                "name": "wakeup_id", 
                "type": "WakeupId"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "wakeup_cancel_all": {
        "description": "<p>Cancels all wakeup event for the app. </p>", 
        "kind": "fn", 
        "name": "wakeup_cancel_all", 
        "params": [], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "wakeup_get_launch_event": {
        "description": "<p>Retrieves the wakeup event info for an app that was launched by a <code>wakeup_event</code> (ie. <code>launch_reason()</code> === <code>APP_LAUNCH_WAKEUP</code>) so that an app may display information regarding the wakeup event. </p>", 
        "kind": "fn", 
        "name": "wakeup_get_launch_event", 
        "params": [
            {
                "description": "<p>WakeupId for the wakeup event that caused the app to wakeup </p>", 
                "name": "wakeup_id", 
                "type": "WakeupId *"
            }, 
            {
                "description": "<p>App provided reason for the wakeup event </p>", 
                "name": "cookie", 
                "type": "int32_t *"
            }
        ], 
        "return_desc": "<p>True if app was launched due to a wakeup event, false otherwise </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "wakeup_query": {
        "description": "<p>Checks if the current WakeupId is still scheduled and therefore valid. </p>", 
        "kind": "fn", 
        "name": "wakeup_query", 
        "params": [
            {
                "description": "<p>Wakeup event to query for validity and scheduled time </p>", 
                "name": "wakeup_id", 
                "type": "WakeupId"
            }, 
            {
                "description": "<p>Optionally points to an address of a <code>time_t</code> variable to store the time that the wakeup event is scheduled to occur. (The time is in UTC, but local time when <code>clock_is_timezone_set</code> returns false). You may pass NULL instead if you do not need it. </p>", 
                "name": "timestamp", 
                "type": "time_t *"
            }
        ], 
        "return_desc": "<p>True if WakeupId is still scheduled, false if it doesn't exist or has already occurred </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "wakeup_schedule": {
        "description": "<p>Registers a wakeup event that triggers a callback at the specified time. Applications may only schedule up to 8 wakeup events. Wakeup events are given a 1 minute duration window, in that no application may schedule a wakeup event with 1 minute of a currently scheduled wakeup event. </p>", 
        "kind": "fn", 
        "name": "wakeup_schedule", 
        "params": [
            {
                "description": "<p>The requested time (UTC) for the wakeup event to occur </p>", 
                "name": "timestamp", 
                "type": "time_t"
            }, 
            {
                "description": "<p>The application specific reason for the wakeup event </p>", 
                "name": "cookie", 
                "type": "int32_t"
            }, 
            {
                "description": "<p>On powering on Pebble, will alert user when notifications were missed due to Pebble being off. </p>", 
                "name": "notify_if_missed", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>negative values indicate errors (StatusCode) <code>E_RANGE</code> if the event cannot be scheduled due to another event in that period. <code>E_INVALID_ARGUMENT</code> if the time requested is in the past. <code>E_OUT_OF_RESOURCES</code> if the application has already scheduled all 8 wakeup events. <code>E_INTERNAL</code> if a system error occurred during scheduling. </p>", 
        "returns": "WakeupId", 
        "warning": null
    }, 
    "wakeup_service_subscribe": {
        "description": "<p>Registers a WakeupHandler to be called when wakeup events occur. </p>", 
        "kind": "fn", 
        "name": "wakeup_service_subscribe", 
        "params": [
            {
                "description": "<p>The callback that gets called when the wakeup event occurs </p>", 
                "name": "handler", 
                "type": "WakeupHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "watch_info_get_color": {
        "description": "", 
        "kind": "fn", 
        "name": "watch_info_get_color", 
        "params": [], 
        "return_desc": null, 
        "returns": "WatchInfoColor", 
        "warning": null
    }, 
    "watch_info_get_firmware_version": {
        "description": "<p>Provides the version of the firmware running on the watch. </p>", 
        "kind": "fn", 
        "name": "watch_info_get_firmware_version", 
        "params": [], 
        "return_desc": "<p>WatchInfoVersion representing the version of the firmware running on the watch. </p>", 
        "returns": "WatchInfoVersion", 
        "warning": null
    }, 
    "watch_info_get_model": {
        "description": "<p>Provides the model of the watch. </p>", 
        "kind": "fn", 
        "name": "watch_info_get_model", 
        "params": [], 
        "return_desc": "<p>WatchInfoModel representing the model of the watch. </p>", 
        "returns": "WatchInfoModel", 
        "warning": null
    }, 
    "window_create": {
        "description": "<p><ul><li><p>Background color : GColorWhite</p></li><li><p>Root layer's <code>update_proc</code> : function that fills the window's background using <code>background_color</code>.</p></li><li><p><code>click_config_provider</code> : NULL</p></li><li><p><code>window_handlers</code> : all NULL </li></ul>\n</p>", 
        "kind": "fn", 
        "name": "window_create", 
        "params": [], 
        "return_desc": "<p>A pointer to the window. NULL if the window could not be created </p>", 
        "returns": "Window *", 
        "warning": null
    }, 
    "window_destroy": {
        "description": "<p>Destroys a Window previously created by <code>window_create</code>. </p>", 
        "kind": "fn", 
        "name": "window_destroy", 
        "params": [
            {
                "description": null, 
                "name": "window", 
                "type": "Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_get_click_config_context": {
        "description": "<p>Gets the current click configuration provider context of the window. </p>", 
        "kind": "fn", 
        "name": "window_get_click_config_context", 
        "params": [
            {
                "description": "<p>The window for which to get the click config provider context </p>", 
                "name": "window", 
                "type": "Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null
    }, 
    "window_get_click_config_provider": {
        "description": "<p>Gets the current click configuration provider of the window. </p>", 
        "kind": "fn", 
        "name": "window_get_click_config_provider", 
        "params": [
            {
                "description": "<p>The window for which to get the click config provider </p>", 
                "name": "window", 
                "type": "const Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "ClickConfigProvider", 
        "warning": null
    }, 
    "window_get_root_layer": {
        "description": "<p>Gets the root Layer of the window. The root layer is the layer at the bottom of the layer hierarchy for this window. It is the window's \"canvas\" if you will. By default, the root layer only draws a solid fill with the window's background color. </p>", 
        "kind": "fn", 
        "name": "window_get_root_layer", 
        "params": [
            {
                "description": "<p>The window for which to get the root layer </p>", 
                "name": "window", 
                "type": "const Window *"
            }
        ], 
        "return_desc": "<p>The window's root layer </p>", 
        "returns": "struct Layer *", 
        "warning": null
    }, 
    "window_get_user_data": {
        "description": "<p>Gets the pointer to developer-supplied data that was previously set using <code>window_set_user_data()</code>. </p>", 
        "kind": "fn", 
        "name": "window_get_user_data", 
        "params": [
            {
                "description": "<p>The window for which to get the user data </p>", 
                "name": "window", 
                "type": "const Window *"
            }
        ], 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null
    }, 
    "window_is_loaded": {
        "description": "<p>Gets whether the window has been loaded. If a window is loaded, its .load handler has been called (and the .unload handler has not been called since). </p>", 
        "kind": "fn", 
        "name": "window_is_loaded", 
        "params": [
            {
                "description": "<p>The window to query its loaded status </p>", 
                "name": "window", 
                "type": "Window *"
            }
        ], 
        "return_desc": "<p>true if the window is currently loaded or false if not. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "window_long_click_subscribe": {
        "description": "<p><p>The back button cannot be overridden with a long click. </p>", 
        "kind": "fn", 
        "name": "window_long_click_subscribe", 
        "params": [
            {
                "description": "<p>The button events to subscribe to. </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>Milliseconds after which \"handler\" is fired. A value of 0 means to use the system default 500ms. </p>", 
                "name": "delay_ms", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>The ClickHandler to fire as soon as the button has been held for <code>delay_ms</code>. This may be NULL to have no down handler. </p>", 
                "name": "down_handler", 
                "type": "ClickHandler"
            }, 
            {
                "description": "<p>The ClickHandler to fire on the release of a long click. This may be NULL to have no up handler. </p>", 
                "name": "up_handler", 
                "type": "ClickHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from the ClickConfigProvider. </p>"
    }, 
    "window_multi_click_subscribe": {
        "description": "<p>Subscribe to multi click events. </p>", 
        "kind": "fn", 
        "name": "window_multi_click_subscribe", 
        "params": [
            {
                "description": "<p>The button events to subscribe to. </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>Minimum number of clicks before handler is fired. Defaults to 2. </p>", 
                "name": "min_clicks", 
                "type": "uint8_t"
            }, 
            {
                "description": "<p>Maximum number of clicks after which the click counter is reset. A value of 0 means use \"min\" also as \"max\". </p>", 
                "name": "max_clicks", 
                "type": "uint8_t"
            }, 
            {
                "description": "<p>The delay after which a sequence of clicks is considered finished, and the click counter is reset. A value of 0 means to use the system default 300ms. </p>", 
                "name": "timeout", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>Defaults to false. When true, only the handler for the last multi-click is called. </p>", 
                "name": "last_click_only", 
                "type": "bool"
            }, 
            {
                "description": "<p>The ClickHandler to fire on this event. Fired for multi-clicks, as \"filtered\" by the <code>last_click_only</code>, min, and max parameters. </p>", 
                "name": "handler", 
                "type": "ClickHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from the ClickConfigProvider. </p>"
    }, 
    "window_raw_click_subscribe": {
        "description": "<p><p>The back button cannot be overridden with a raw click. </p>", 
        "kind": "fn", 
        "name": "window_raw_click_subscribe", 
        "params": [
            {
                "description": "<p>The button events to subscribe to. </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>The ClickHandler to fire as soon as the button has been pressed. This may be NULL to have no down handler. </p>", 
                "name": "down_handler", 
                "type": "ClickHandler"
            }, 
            {
                "description": "<p>The ClickHandler to fire on the release of the button. This may be NULL to have no up handler. </p>", 
                "name": "up_handler", 
                "type": "ClickHandler"
            }, 
            {
                "description": "<p>If this context is not NULL, it will override the general context. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p>"
    }, 
    "window_set_background_color": {
        "description": "<p>Sets the background color of the window, which is drawn automatically by the root layer of the window. </p>", 
        "kind": "fn", 
        "name": "window_set_background_color", 
        "params": [
            {
                "description": "<p>The window for which to set the background color </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>The new background color </p>", 
                "name": "background_color", 
                "type": "GColor"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_set_click_config_provider": {
        "description": "<p>Sets the click configuration provider callback function on the window. This will automatically setup the input handlers of the window as well to use the click recognizer subsystem. </p>", 
        "kind": "fn", 
        "name": "window_set_click_config_provider", 
        "params": [
            {
                "description": "<p>The window for which to set the click config provider </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>The callback that will be called to configure the click recognizers with the window </p>", 
                "name": "click_config_provider", 
                "type": "ClickConfigProvider"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_set_click_config_provider_with_context": {
        "description": "<p>Same as <code>window_set_click_config_provider()</code>, but will assign a custom context pointer (instead of the window pointer) that will be passed into the ClickHandler click event handlers. </p>", 
        "kind": "fn", 
        "name": "window_set_click_config_provider_with_context", 
        "params": [
            {
                "description": "<p>The window for which to set the click config provider </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>The callback that will be called to configure the click recognizers with the window </p>", 
                "name": "click_config_provider", 
                "type": "ClickConfigProvider"
            }, 
            {
                "description": "<p>Pointer to application specific data that will be passed to the click configuration provider callback (defaults to the window). </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_set_click_context": {
        "description": "<p>Set the context that will be passed to handlers for the given button's events. By default the context passed to handlers is equal to the ClickConfigProvider context (defaults to the window). </p>", 
        "kind": "fn", 
        "name": "window_set_click_context", 
        "params": [
            {
                "description": "<p>The button to set the context for. </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>Set the context that will be passed to handlers for the given button's events. </p>", 
                "name": "context", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p>"
    }, 
    "window_set_user_data": {
        "description": "<p>Sets a pointer to developer-supplied data that the window uses, to provide a means to access the data at later times in one of the window event handlers. </p>", 
        "kind": "fn", 
        "name": "window_set_user_data", 
        "params": [
            {
                "description": "<p>The window for which to set the user data </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>A pointer to user data. </p>", 
                "name": "data", 
                "type": "void *"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_set_window_handlers": {
        "description": "<p>Sets the window handlers of the window. These handlers get called e.g. when the user enters or leaves the window. </p>", 
        "kind": "fn", 
        "name": "window_set_window_handlers", 
        "params": [
            {
                "description": "<p>The window for which to set the window handlers </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>The handlers for the specified window </p>", 
                "name": "handlers", 
                "type": "WindowHandlers"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_single_click_subscribe": {
        "description": "<p><p><code>window_single_click_subscribe()</code> and <code>window_single_repeating_click_subscribe()</code> conflict, and cannot both be used on the same button. </p>\n<p>When there is a <code>multi_click</code> and/or <code>long_click</code> setup, there will be a delay before the single click </p>\n\n\n\n</p>", 
        "kind": "fn", 
        "name": "window_single_click_subscribe", 
        "params": [
            {
                "description": "<p>The button events to subscribe to. </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>The ClickHandler to fire on this event. handler will get fired. On the other hand, when there is no <code>multi_click</code> nor <code>long_click</code> setup, the single click handler will fire directly on button down. </p>", 
                "name": "handler", 
                "type": "ClickHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from the ClickConfigProvider. </p>"
    }, 
    "window_single_repeating_click_subscribe": {
        "description": "<p><p><code>window_single_click_subscribe()</code> and <code>window_single_repeating_click_subscribe()</code> conflict, and cannot both be used on the same button. </p>\n<p>The back button cannot be overridden with a repeating click. </p>\n\n</p>", 
        "kind": "fn", 
        "name": "window_single_repeating_click_subscribe", 
        "params": [
            {
                "description": "<p>The button events to subscribe to. </p>", 
                "name": "button_id", 
                "type": "ButtonId"
            }, 
            {
                "description": "<p>When holding down, how many milliseconds before the handler is fired again. A value of 0ms means \"no repeat timer\". The minimum is 30ms, and values below will be disregarded. If there is a long-click handler subscribed on this button, <code>repeat_interval_ms</code> will not be used. </p>", 
                "name": "repeat_interval_ms", 
                "type": "uint16_t"
            }, 
            {
                "description": "<p>The ClickHandler to fire on this event. </p>", 
                "name": "handler", 
                "type": "ClickHandler"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from the ClickConfigProvider. </p>"
    }, 
    "window_stack_contains_window": {
        "description": "<p>Checks if the window is on the window stack. </p>", 
        "kind": "fn", 
        "name": "window_stack_contains_window", 
        "params": [
            {
                "description": "<p>The window to look for on the window stack </p>", 
                "name": "window", 
                "type": "Window *"
            }
        ], 
        "return_desc": "<p>true if the window is currently on the window stack. </p>", 
        "returns": "bool", 
        "warning": null
    }, 
    "window_stack_get_top_window": {
        "description": "<p>Gets the topmost window on the stack that belongs to the app. </p>", 
        "kind": "fn", 
        "name": "window_stack_get_top_window", 
        "params": [], 
        "return_desc": "<p>The topmost window on the stack that belongs to the app or NULL if no app window could be found. </p>", 
        "returns": "Window *", 
        "warning": null
    }, 
    "window_stack_pop": {
        "description": "<p>Pops the topmost window on the navigation stack. </p>", 
        "kind": "fn", 
        "name": "window_stack_pop", 
        "params": [
            {
                "description": "<p>See <code>window_stack_remove()</code> </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>The window that is popped, or NULL if there are no windows to pop. </p>", 
        "returns": "Window *", 
        "warning": null
    }, 
    "window_stack_pop_all": {
        "description": "<p>Pops all windows. See <code>window_stack_remove()</code> for a description of the animated parameter and notes. </p>", 
        "kind": "fn", 
        "name": "window_stack_pop_all", 
        "params": [
            {
                "description": null, 
                "name": "animated", 
                "type": "const bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_stack_push": {
        "description": "<p>Pushes the given window on the window navigation stack, on top of the current topmost window of the app. </p>", 
        "kind": "fn", 
        "name": "window_stack_push", 
        "params": [
            {
                "description": "<p>The window to push on top </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>Pass in true to animate the push using a sliding animation, or false to skip the animation. </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": null, 
        "returns": "void", 
        "warning": null
    }, 
    "window_stack_remove": {
        "description": "<p>Removes a given window from the window stack that belongs to the app task. </p>", 
        "kind": "fn", 
        "name": "window_stack_remove", 
        "params": [
            {
                "description": "<p>The window to remove. If the window is NULL or if it is not on the stack, this function is a no-op. </p>", 
                "name": "window", 
                "type": "Window *"
            }, 
            {
                "description": "<p>Pass in true to animate the removal of the window using a side-to-side sliding animation to reveal the next window. This is only used in case the window happens to be on top of the window stack (thus visible). </p>", 
                "name": "animated", 
                "type": "bool"
            }
        ], 
        "return_desc": "<p>True if window was successfully removed, false otherwise. </p>", 
        "returns": "bool", 
        "warning": "<p>If there are no windows for the app left on the stack, the app will be killed by the system, shortly. To avoid this, make sure to push another window shortly after or before removing the last window. </p>"
    }
}